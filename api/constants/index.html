
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Dirk Adler">
      
      
      <link rel="icon" href="../../img/php-rdkafka.svg">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.4">
    
    
      
        <title>Constants - PHP Kafka Client</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.db9e7362.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#constants" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="PHP Kafka Client" class="md-header__button md-logo" aria-label="PHP Kafka Client" data-md-component="logo">
      
  <img src="../../img/php-rdkafka.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PHP Kafka Client
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Constants
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/idealo/php-rdkafka-ffi/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    idealo/php-rdkafka-ffi
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      Getting started
    </a>
  </li>

      
        
  
  
    
  


  
  
  
    <li class="md-tabs__item">
      <a href="../" class="md-tabs__link md-tabs__link--active">
        Api
      </a>
    </li>
  

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../benchmarks/" class="md-tabs__link">
      Benchmarks
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../try-out/" class="md-tabs__link">
      Try out
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../changelog/" class="md-tabs__link">
      Changelog
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../contributing/" class="md-tabs__link">
      Contributing
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../license/" class="md-tabs__link">
      License
    </a>
  </li>

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="PHP Kafka Client" class="md-nav__button md-logo" aria-label="PHP Kafka Client" data-md-component="logo">
      
  <img src="../../img/php-rdkafka.svg" alt="logo">

    </a>
    PHP Kafka Client
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/idealo/php-rdkafka-ffi/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    idealo/php-rdkafka-ffi
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Getting started
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Api
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Api" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Api
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Overview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/" class="md-nav__link">
        RdKafka
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Constants
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Constants
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_print" class="md-nav__link">
    RD_KAFKA_LOG_PRINT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog" class="md-nav__link">
    RD_KAFKA_LOG_SYSLOG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog_print" class="md-nav__link">
    RD_KAFKA_LOG_SYSLOG_PRINT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_CONSISTENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_MURMUR2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_FNV1A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_destroy_f_no_consumer_close" class="md-nav__link">
    RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_partition_ua" class="md-nav__link">
    RD_KAFKA_PARTITION_UA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_beginning" class="md-nav__link">
    RD_KAFKA_OFFSET_BEGINNING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_end" class="md-nav__link">
    RD_KAFKA_OFFSET_END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_stored" class="md-nav__link">
    RD_KAFKA_OFFSET_STORED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_invalid" class="md-nav__link">
    RD_KAFKA_OFFSET_INVALID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_tail_base" class="md-nav__link">
    RD_KAFKA_OFFSET_TAIL_BASE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_free" class="md-nav__link">
    RD_KAFKA_MSG_F_FREE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_copy" class="md-nav__link">
    RD_KAFKA_MSG_F_COPY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_block" class="md-nav__link">
    RD_KAFKA_MSG_F_BLOCK
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_partition" class="md-nav__link">
    RD_KAFKA_MSG_F_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_queue" class="md-nav__link">
    RD_KAFKA_PURGE_F_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_inflight" class="md-nav__link">
    RD_KAFKA_PURGE_F_INFLIGHT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_non_blocking" class="md-nav__link">
    RD_KAFKA_PURGE_F_NON_BLOCKING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_none" class="md-nav__link">
    RD_KAFKA_EVENT_NONE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_dr" class="md-nav__link">
    RD_KAFKA_EVENT_DR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_fetch" class="md-nav__link">
    RD_KAFKA_EVENT_FETCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_log" class="md-nav__link">
    RD_KAFKA_EVENT_LOG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_error" class="md-nav__link">
    RD_KAFKA_EVENT_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_rebalance" class="md-nav__link">
    RD_KAFKA_EVENT_REBALANCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_offset_commit" class="md-nav__link">
    RD_KAFKA_EVENT_OFFSET_COMMIT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_stats" class="md-nav__link">
    RD_KAFKA_EVENT_STATS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createtopics_result" class="md-nav__link">
    RD_KAFKA_EVENT_CREATETOPICS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletetopics_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETETOPICS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createpartitions_result" class="md-nav__link">
    RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconfigs_result" class="md-nav__link">
    RD_KAFKA_EVENT_ALTERCONFIGS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconfigs_result" class="md-nav__link">
    RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_producer" class="md-nav__link">
    RD_KAFKA_PRODUCER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer" class="md-nav__link">
    RD_KAFKA_CONSUMER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_not_available" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_create_time" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_CREATE_TIME
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_log_append_time" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__begin" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BEGIN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_msg" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BAD_MSG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_compression" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BAD_COMPRESSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__destroy" class="md-nav__link">
    RD_KAFKA_RESP_ERR__DESTROY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fail" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FAIL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__transport" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TRANSPORT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__crit_sys_resource" class="md-nav__link">
    RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__resolve" class="md-nav__link">
    RD_KAFKA_RESP_ERR__RESOLVE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__msg_timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR__MSG_TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partition_eof" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PARTITION_EOF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_partition" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fs" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_topic" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__all_brokers_down" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_arg" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INVALID_ARG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__queue_full" class="md-nav__link">
    RD_KAFKA_RESP_ERR__QUEUE_FULL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__isr_insuff" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ISR_INSUFF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__node_update" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NODE_UPDATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__ssl" class="md-nav__link">
    RD_KAFKA_RESP_ERR__SSL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_coord" class="md-nav__link">
    RD_KAFKA_RESP_ERR__WAIT_COORD
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR__IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__prev_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__existing_subscription" class="md-nav__link">
    RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assign_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__revoke_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__conflict" class="md-nav__link">
    RD_KAFKA_RESP_ERR__CONFLICT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__state" class="md-nav__link">
    RD_KAFKA_RESP_ERR__STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_protocol" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_implemented" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__authentication" class="md-nav__link">
    RD_KAFKA_RESP_ERR__AUTHENTICATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__no_offset" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NO_OFFSET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__outdated" class="md-nav__link">
    RD_KAFKA_RESP_ERR__OUTDATED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out_queue" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unsupported_feature" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_cache" class="md-nav__link">
    RD_KAFKA_RESP_ERR__WAIT_CACHE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__intr" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INTR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_serialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__KEY_SERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_serialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_deserialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_deserialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partial" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PARTIAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__read_only" class="md-nav__link">
    RD_KAFKA_RESP_ERR__READ_ONLY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noent" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__underflow" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNDERFLOW
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INVALID_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__retry" class="md-nav__link">
    RD_KAFKA_RESP_ERR__RETRY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_queue" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PURGE_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_inflight" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PURGE_INFLIGHT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fatal" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FATAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__inconsistent" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INCONSISTENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__gapless_guarantee" class="md-nav__link">
    RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__max_poll_exceeded" class="md-nav__link">
    RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__end" class="md-nav__link">
    RD_KAFKA_RESP_ERR__END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_error" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NO_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_out_of_range" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_MSG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_or_part" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg_size" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_leader_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_leader_for_partition" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_request_timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_broker_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_replica_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_msg_size_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_ctrl_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_metadata_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_network_exception" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_load_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_coordinator_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator_for_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_exception" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_record_list_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas_after_append" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_required_acks" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_generation" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_group_protocol" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_group_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_GROUP_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_member_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_session_timeout" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_rebalance_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_commit_offset_size" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_cluster_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_timestamp" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_sasl_mechanism" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_sasl_state" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_version" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_already_exists" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replication_factor" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replica_assignment" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_config" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_controller" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_CONTROLLER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_request" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REQUEST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_for_message_format" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_policy_violation" class="md-nav__link">
    RD_KAFKA_RESP_ERR_POLICY_VIOLATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_out_of_order_sequence_number" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_sequence_number" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_txn_state" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TXN_STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_id_mapping" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_transaction_timeout" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_concurrent_transactions" class="md-nav__link">
    RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transaction_coordinator_fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transactional_id_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_security_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_SECURITY_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_operation_not_attempted" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_kafka_storage_error" class="md-nav__link">
    RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_log_dir_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_sasl_authentication_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_producer_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_reassignment_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_auth_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_owner_mismatch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_request_not_allowed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_expired" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_principal_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_non_empty_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_id_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fetch_session_id_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_fetch_session_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_listener_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_deletion_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_end" class="md-nav__link">
    RD_KAFKA_VTYPE_END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_topic" class="md-nav__link">
    RD_KAFKA_VTYPE_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_rkt" class="md-nav__link">
    RD_KAFKA_VTYPE_RKT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_partition" class="md-nav__link">
    RD_KAFKA_VTYPE_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_value" class="md-nav__link">
    RD_KAFKA_VTYPE_VALUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_key" class="md-nav__link">
    RD_KAFKA_VTYPE_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_opaque" class="md-nav__link">
    RD_KAFKA_VTYPE_OPAQUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_msgflags" class="md-nav__link">
    RD_KAFKA_VTYPE_MSGFLAGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_timestamp" class="md-nav__link">
    RD_KAFKA_VTYPE_TIMESTAMP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_header" class="md-nav__link">
    RD_KAFKA_VTYPE_HEADER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_headers" class="md-nav__link">
    RD_KAFKA_VTYPE_HEADERS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_not_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_NOT_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_possibly_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_unknown" class="md-nav__link">
    RD_KAFKA_CONF_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_invalid" class="md-nav__link">
    RD_KAFKA_CONF_INVALID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_ok" class="md-nav__link">
    RD_KAFKA_CONF_OK
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_any" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_ANY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createtopics" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_CREATETOPICS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletetopics" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETETOPICS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createpartitions" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_CREATEPARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconfigs" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_ALTERCONFIGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconfigs" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_unknown_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_topic_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_default_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_static_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_default_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source__cnt" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_unknown" class="md-nav__link">
    RD_KAFKA_RESOURCE_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_any" class="md-nav__link">
    RD_KAFKA_RESOURCE_ANY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_topic" class="md-nav__link">
    RD_KAFKA_RESOURCE_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_group" class="md-nav__link">
    RD_KAFKA_RESOURCE_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_broker" class="md-nav__link">
    RD_KAFKA_RESOURCE_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt" class="md-nav__link">
    RD_KAFKA_RESOURCE__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_leader_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_leader_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_broker_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_member_id_required" class="md-nav__link">
    RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_preferred_leader_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_max_size_reached" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_oauthbearer_token_refresh" class="md-nav__link">
    RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_public_key" class="md-nav__link">
    RD_KAFKA_CERT_PUBLIC_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_private_key" class="md-nav__link">
    RD_KAFKA_CERT_PRIVATE_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_ca" class="md-nav__link">
    RD_KAFKA_CERT_CA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert__cnt" class="md-nav__link">
    RD_KAFKA_CERT__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pkcs12" class="md-nav__link">
    RD_KAFKA_CERT_ENC_PKCS12
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_der" class="md-nav__link">
    RD_KAFKA_CERT_ENC_DER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pem" class="md-nav__link">
    RD_KAFKA_CERT_ENC_PEM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc__cnt" class="md-nav__link">
    RD_KAFKA_CERT_ENC__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_main" class="md-nav__link">
    RD_KAFKA_THREAD_MAIN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_background" class="md-nav__link">
    RD_KAFKA_THREAD_BACKGROUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_broker" class="md-nav__link">
    RD_KAFKA_THREAD_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_broker" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_load_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_configured" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOT_CONFIGURED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__application" class="md-nav__link">
    RD_KAFKA_RESP_ERR__APPLICATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_instance_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_eligible_leaders_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_election_not_needed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_reassignment_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_subscribed_to_topic" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_record" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_RECORD
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unstable_offset_commit" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleterecords_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETERECORDS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletegroups_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETEGROUPS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteconsumergroupoffsets_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assignment_lost" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noop" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOOP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_throttling_quota_exceeded" class="md-nav__link">
    RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_producer_fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PRODUCER_FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_resource_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_resource" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unacceptable_credential" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_voter_set" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_update_version" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_feature_update_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_principal_deserialization_failure" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleterecords" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETERECORDS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletegroups" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETEGROUPS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteconsumergroupoffsets" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__auto_offset_reset" class="md-nav__link">
    RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_supported_methods" class="md-nav__link">
    RD_KAFKA_SUPPORTED_METHODS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_1" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_1" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_1" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_1" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_1" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_2" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_2" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_2" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_2" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_2" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_3" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_3" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_3" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_3" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_3" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_4" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_4" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_4" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_4" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_4" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_5" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_5" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_5" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_5" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_5" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_6" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_6" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_6" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_6" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_6" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_7" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_7" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_7" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_7" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_7" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_8" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_8" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_8" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_8" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_8" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_9" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_9" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_9" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_9" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_9" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_10" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_10" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_10" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_10" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_10" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_11" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_11" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_11" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_11" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_11" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_12" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_12" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_12" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_12" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_12" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_13" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_13" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_13" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_13" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_13" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_14" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_14" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_14" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_14" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_14" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_15" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_15" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_15" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_15" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_15" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_16" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_16" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_16" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_16" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_16" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_17" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_17" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_17" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_17" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_17" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../functions/" class="md-nav__link">
        Functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_5" type="checkbox" id="__nav_2_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_5">
          RdKafka
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="RdKafka" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_5">
          <span class="md-nav__icon md-icon"></span>
          RdKafka
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Conf/" class="md-nav__link">
        Conf
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Consumer/" class="md-nav__link">
        Consumer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/ConsumerTopic/" class="md-nav__link">
        ConsumerTopic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Event/" class="md-nav__link">
        Event
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Exception/" class="md-nav__link">
        Exception
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaConsumer/" class="md-nav__link">
        KafkaConsumer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaConsumerTopic/" class="md-nav__link">
        KafkaConsumerTopic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/KafkaErrorException/" class="md-nav__link">
        KafkaErrorException
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Message/" class="md-nav__link">
        Message
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/" class="md-nav__link">
        Metadata
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Producer/" class="md-nav__link">
        Producer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/ProducerTopic/" class="md-nav__link">
        ProducerTopic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Queue/" class="md-nav__link">
        Queue
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Topic/" class="md-nav__link">
        Topic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicConf/" class="md-nav__link">
        TopicConf
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicPartition/" class="md-nav__link">
        TopicPartition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/TopicPartitionList/" class="md-nav__link">
        TopicPartitionList
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_5_18" type="checkbox" id="__nav_2_5_18" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_5_18">
          Admin
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Admin" data-md-level="3">
        <label class="md-nav__title" for="__nav_2_5_18">
          <span class="md-nav__icon md-icon"></span>
          Admin
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/AlterConfigsOptions/" class="md-nav__link">
        AlterConfigsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/Client/" class="md-nav__link">
        Client
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigEntry/" class="md-nav__link">
        ConfigEntry
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigResource/" class="md-nav__link">
        ConfigResource
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/ConfigResourceResult/" class="md-nav__link">
        ConfigResourceResult
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/CreatePartitionsOptions/" class="md-nav__link">
        CreatePartitionsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/CreateTopicsOptions/" class="md-nav__link">
        CreateTopicsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteConsumerGroupOffsets/" class="md-nav__link">
        DeleteConsumerGroupOffsets
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/" class="md-nav__link">
        DeleteConsumerGroupOffsetsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteGroup/" class="md-nav__link">
        DeleteGroup
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteGroupsOptions/" class="md-nav__link">
        DeleteGroupsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteRecords/" class="md-nav__link">
        DeleteRecords
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteRecordsOptions/" class="md-nav__link">
        DeleteRecordsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteTopic/" class="md-nav__link">
        DeleteTopic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DeleteTopicsOptions/" class="md-nav__link">
        DeleteTopicsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/DescribeConfigsOptions/" class="md-nav__link">
        DescribeConfigsOptions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/GroupResult/" class="md-nav__link">
        GroupResult
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/NewPartitions/" class="md-nav__link">
        NewPartitions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/NewTopic/" class="md-nav__link">
        NewTopic
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/Options/" class="md-nav__link">
        Options
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Admin/TopicResult/" class="md-nav__link">
        TopicResult
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_5_19" type="checkbox" id="__nav_2_5_19" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_5_19">
          FFI
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="FFI" data-md-level="3">
        <label class="md-nav__title" for="__nav_2_5_19">
          <span class="md-nav__icon md-icon"></span>
          FFI
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/CallbackProxy/" class="md-nav__link">
        CallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/ConsumeCallbackProxy/" class="md-nav__link">
        ConsumeCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/DrMsgCallbackProxy/" class="md-nav__link">
        DrMsgCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/ErrorCallbackProxy/" class="md-nav__link">
        ErrorCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/Library/" class="md-nav__link">
        Library
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/LogCallbackProxy/" class="md-nav__link">
        LogCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/Methods/" class="md-nav__link">
        Methods
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/NativePartitionerCallbackProxy/" class="md-nav__link">
        NativePartitionerCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/OffsetCommitCallbackProxy/" class="md-nav__link">
        OffsetCommitCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/OpaqueMap/" class="md-nav__link">
        OpaqueMap
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/PartitionerCallbackProxy/" class="md-nav__link">
        PartitionerCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/RebalanceCallbackProxy/" class="md-nav__link">
        RebalanceCallbackProxy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/FFI/StatsCallbackProxy/" class="md-nav__link">
        StatsCallbackProxy
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_5_20" type="checkbox" id="__nav_2_5_20" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_5_20">
          Metadata
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Metadata" data-md-level="3">
        <label class="md-nav__title" for="__nav_2_5_20">
          <span class="md-nav__icon md-icon"></span>
          Metadata
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Broker/" class="md-nav__link">
        Broker
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Collection/" class="md-nav__link">
        Collection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Partition/" class="md-nav__link">
        Partition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Metadata/Topic/" class="md-nav__link">
        Topic
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_5_21" type="checkbox" id="__nav_2_5_21" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_5_21">
          Test
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Test" data-md-level="3">
        <label class="md-nav__title" for="__nav_2_5_21">
          <span class="md-nav__icon md-icon"></span>
          Test
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Test/ApiKey/" class="md-nav__link">
        ApiKey
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../RdKafka/Test/MockCluster/" class="md-nav__link">
        MockCluster
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../benchmarks/" class="md-nav__link">
        Benchmarks
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../try-out/" class="md-nav__link">
        Try out
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../changelog/" class="md-nav__link">
        Changelog
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../license/" class="md-nav__link">
        License
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_print" class="md-nav__link">
    RD_KAFKA_LOG_PRINT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog" class="md-nav__link">
    RD_KAFKA_LOG_SYSLOG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_log_syslog_print" class="md-nav__link">
    RD_KAFKA_LOG_SYSLOG_PRINT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_CONSISTENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_consistent_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_MURMUR2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_murmur2_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_FNV1A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_partitioner_fnv1a_random" class="md-nav__link">
    RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_destroy_f_no_consumer_close" class="md-nav__link">
    RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_partition_ua" class="md-nav__link">
    RD_KAFKA_PARTITION_UA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_beginning" class="md-nav__link">
    RD_KAFKA_OFFSET_BEGINNING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_end" class="md-nav__link">
    RD_KAFKA_OFFSET_END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_stored" class="md-nav__link">
    RD_KAFKA_OFFSET_STORED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_invalid" class="md-nav__link">
    RD_KAFKA_OFFSET_INVALID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_offset_tail_base" class="md-nav__link">
    RD_KAFKA_OFFSET_TAIL_BASE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_free" class="md-nav__link">
    RD_KAFKA_MSG_F_FREE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_copy" class="md-nav__link">
    RD_KAFKA_MSG_F_COPY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_block" class="md-nav__link">
    RD_KAFKA_MSG_F_BLOCK
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_f_partition" class="md-nav__link">
    RD_KAFKA_MSG_F_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_queue" class="md-nav__link">
    RD_KAFKA_PURGE_F_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_inflight" class="md-nav__link">
    RD_KAFKA_PURGE_F_INFLIGHT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_purge_f_non_blocking" class="md-nav__link">
    RD_KAFKA_PURGE_F_NON_BLOCKING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_none" class="md-nav__link">
    RD_KAFKA_EVENT_NONE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_dr" class="md-nav__link">
    RD_KAFKA_EVENT_DR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_fetch" class="md-nav__link">
    RD_KAFKA_EVENT_FETCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_log" class="md-nav__link">
    RD_KAFKA_EVENT_LOG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_error" class="md-nav__link">
    RD_KAFKA_EVENT_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_rebalance" class="md-nav__link">
    RD_KAFKA_EVENT_REBALANCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_offset_commit" class="md-nav__link">
    RD_KAFKA_EVENT_OFFSET_COMMIT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_stats" class="md-nav__link">
    RD_KAFKA_EVENT_STATS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createtopics_result" class="md-nav__link">
    RD_KAFKA_EVENT_CREATETOPICS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletetopics_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETETOPICS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_createpartitions_result" class="md-nav__link">
    RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_alterconfigs_result" class="md-nav__link">
    RD_KAFKA_EVENT_ALTERCONFIGS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_describeconfigs_result" class="md-nav__link">
    RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_producer" class="md-nav__link">
    RD_KAFKA_PRODUCER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_consumer" class="md-nav__link">
    RD_KAFKA_CONSUMER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_not_available" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_create_time" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_CREATE_TIME
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_timestamp_log_append_time" class="md-nav__link">
    RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__begin" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BEGIN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_msg" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BAD_MSG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__bad_compression" class="md-nav__link">
    RD_KAFKA_RESP_ERR__BAD_COMPRESSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__destroy" class="md-nav__link">
    RD_KAFKA_RESP_ERR__DESTROY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fail" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FAIL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__transport" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TRANSPORT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__crit_sys_resource" class="md-nav__link">
    RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__resolve" class="md-nav__link">
    RD_KAFKA_RESP_ERR__RESOLVE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__msg_timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR__MSG_TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partition_eof" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PARTITION_EOF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_partition" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fs" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_topic" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__all_brokers_down" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_arg" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INVALID_ARG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__queue_full" class="md-nav__link">
    RD_KAFKA_RESP_ERR__QUEUE_FULL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__isr_insuff" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ISR_INSUFF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__node_update" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NODE_UPDATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__ssl" class="md-nav__link">
    RD_KAFKA_RESP_ERR__SSL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_coord" class="md-nav__link">
    RD_KAFKA_RESP_ERR__WAIT_COORD
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR__IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__prev_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__existing_subscription" class="md-nav__link">
    RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assign_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__revoke_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__conflict" class="md-nav__link">
    RD_KAFKA_RESP_ERR__CONFLICT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__state" class="md-nav__link">
    RD_KAFKA_RESP_ERR__STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_protocol" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_implemented" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__authentication" class="md-nav__link">
    RD_KAFKA_RESP_ERR__AUTHENTICATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__no_offset" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NO_OFFSET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__outdated" class="md-nav__link">
    RD_KAFKA_RESP_ERR__OUTDATED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__timed_out_queue" class="md-nav__link">
    RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unsupported_feature" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__wait_cache" class="md-nav__link">
    RD_KAFKA_RESP_ERR__WAIT_CACHE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__intr" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INTR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_serialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__KEY_SERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_serialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__key_deserialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__value_deserialization" class="md-nav__link">
    RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__partial" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PARTIAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__read_only" class="md-nav__link">
    RD_KAFKA_RESP_ERR__READ_ONLY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noent" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__underflow" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNDERFLOW
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__invalid_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INVALID_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__retry" class="md-nav__link">
    RD_KAFKA_RESP_ERR__RETRY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_queue" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PURGE_QUEUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__purge_inflight" class="md-nav__link">
    RD_KAFKA_RESP_ERR__PURGE_INFLIGHT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fatal" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FATAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__inconsistent" class="md-nav__link">
    RD_KAFKA_RESP_ERR__INCONSISTENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__gapless_guarantee" class="md-nav__link">
    RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__max_poll_exceeded" class="md-nav__link">
    RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__end" class="md-nav__link">
    RD_KAFKA_RESP_ERR__END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_error" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NO_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_out_of_range" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_MSG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_topic_or_part" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_msg_size" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_leader_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_leader_for_partition" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_request_timed_out" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_broker_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_replica_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_msg_size_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_ctrl_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_metadata_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_network_exception" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_load_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_coordinator_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator_for_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_exception" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_record_list_too_large" class="md-nav__link">
    RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_enough_replicas_after_append" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_required_acks" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_generation" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_group_protocol" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_group_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_GROUP_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_member_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_session_timeout" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_rebalance_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_commit_offset_size" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_cluster_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_timestamp" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_sasl_mechanism" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_illegal_sasl_state" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_version" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_already_exists" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_partitions" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replication_factor" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_replica_assignment" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_config" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_controller" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_CONTROLLER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_request" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_REQUEST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_for_message_format" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_policy_violation" class="md-nav__link">
    RD_KAFKA_RESP_ERR_POLICY_VIOLATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_out_of_order_sequence_number" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_sequence_number" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_txn_state" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TXN_STATE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_producer_id_mapping" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_transaction_timeout" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_concurrent_transactions" class="md-nav__link">
    RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transaction_coordinator_fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_transactional_id_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_security_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_SECURITY_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_operation_not_attempted" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_kafka_storage_error" class="md-nav__link">
    RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_log_dir_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_sasl_authentication_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_producer_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_reassignment_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_auth_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_owner_mismatch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_request_not_allowed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_authorization_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_delegation_token_expired" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_principal_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_non_empty_group" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_id_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fetch_session_id_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_fetch_session_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_listener_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_topic_deletion_disabled" class="md-nav__link">
    RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_end" class="md-nav__link">
    RD_KAFKA_VTYPE_END
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_topic" class="md-nav__link">
    RD_KAFKA_VTYPE_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_rkt" class="md-nav__link">
    RD_KAFKA_VTYPE_RKT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_partition" class="md-nav__link">
    RD_KAFKA_VTYPE_PARTITION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_value" class="md-nav__link">
    RD_KAFKA_VTYPE_VALUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_key" class="md-nav__link">
    RD_KAFKA_VTYPE_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_opaque" class="md-nav__link">
    RD_KAFKA_VTYPE_OPAQUE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_msgflags" class="md-nav__link">
    RD_KAFKA_VTYPE_MSGFLAGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_timestamp" class="md-nav__link">
    RD_KAFKA_VTYPE_TIMESTAMP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_header" class="md-nav__link">
    RD_KAFKA_VTYPE_HEADER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_vtype_headers" class="md-nav__link">
    RD_KAFKA_VTYPE_HEADERS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_not_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_NOT_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_possibly_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_msg_status_persisted" class="md-nav__link">
    RD_KAFKA_MSG_STATUS_PERSISTED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_unknown" class="md-nav__link">
    RD_KAFKA_CONF_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_invalid" class="md-nav__link">
    RD_KAFKA_CONF_INVALID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_conf_ok" class="md-nav__link">
    RD_KAFKA_CONF_OK
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_any" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_ANY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createtopics" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_CREATETOPICS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletetopics" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETETOPICS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_createpartitions" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_CREATEPARTITIONS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_alterconfigs" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_ALTERCONFIGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_describeconfigs" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_unknown_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_topic_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_dynamic_default_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_static_broker_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source_default_config" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_config_source__cnt" class="md-nav__link">
    RD_KAFKA_CONFIG_SOURCE__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_unknown" class="md-nav__link">
    RD_KAFKA_RESOURCE_UNKNOWN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_any" class="md-nav__link">
    RD_KAFKA_RESOURCE_ANY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_topic" class="md-nav__link">
    RD_KAFKA_RESOURCE_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_group" class="md-nav__link">
    RD_KAFKA_RESOURCE_GROUP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource_broker" class="md-nav__link">
    RD_KAFKA_RESOURCE_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resource__cnt" class="md-nav__link">
    RD_KAFKA_RESOURCE__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_leader_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unknown_leader_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_stale_broker_epoch" class="md-nav__link">
    RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_offset_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_member_id_required" class="md-nav__link">
    RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_preferred_leader_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_max_size_reached" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_oauthbearer_token_refresh" class="md-nav__link">
    RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_public_key" class="md-nav__link">
    RD_KAFKA_CERT_PUBLIC_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_private_key" class="md-nav__link">
    RD_KAFKA_CERT_PRIVATE_KEY
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_ca" class="md-nav__link">
    RD_KAFKA_CERT_CA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert__cnt" class="md-nav__link">
    RD_KAFKA_CERT__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pkcs12" class="md-nav__link">
    RD_KAFKA_CERT_ENC_PKCS12
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_der" class="md-nav__link">
    RD_KAFKA_CERT_ENC_DER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc_pem" class="md-nav__link">
    RD_KAFKA_CERT_ENC_PEM
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cert_enc__cnt" class="md-nav__link">
    RD_KAFKA_CERT_ENC__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_main" class="md-nav__link">
    RD_KAFKA_THREAD_MAIN
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_background" class="md-nav__link">
    RD_KAFKA_THREAD_BACKGROUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_thread_broker" class="md-nav__link">
    RD_KAFKA_THREAD_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__unknown_broker" class="md-nav__link">
    RD_KAFKA_RESP_ERR__UNKNOWN_BROKER
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_load_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_coordinator_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_not_coordinator" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__not_configured" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOT_CONFIGURED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR__FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__application" class="md-nav__link">
    RD_KAFKA_RESP_ERR__APPLICATION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_fenced_instance_id" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_eligible_leaders_not_available" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_election_not_needed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_no_reassignment_in_progress" class="md-nav__link">
    RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_group_subscribed_to_topic" class="md-nav__link">
    RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_record" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_RECORD
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unstable_offset_commit" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleterecords_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETERECORDS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deletegroups_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETEGROUPS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_event_deleteconsumergroupoffsets_result" class="md-nav__link">
    RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__assignment_lost" class="md-nav__link">
    RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__noop" class="md-nav__link">
    RD_KAFKA_RESP_ERR__NOOP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_throttling_quota_exceeded" class="md-nav__link">
    RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_producer_fenced" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PRODUCER_FENCED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_resource_not_found" class="md-nav__link">
    RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_duplicate_resource" class="md-nav__link">
    RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unacceptable_credential" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_inconsistent_voter_set" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_invalid_update_version" class="md-nav__link">
    RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_feature_update_failed" class="md-nav__link">
    RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_principal_deserialization_failure" class="md-nav__link">
    RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleterecords" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETERECORDS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deletegroups" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETEGROUPS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op_deleteconsumergroupoffsets" class="md-nav__link">
    RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err__auto_offset_reset" class="md-nav__link">
    RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_supported_methods" class="md-nav__link">
    RD_KAFKA_SUPPORTED_METHODS
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_1" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_1" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_1" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_1" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_1" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_2" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_2" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_2" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_2" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_2" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_3" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_3" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_3" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_3" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_3" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_4" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_4" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_4" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_4" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_4" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_5" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_5" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_5" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_5" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_5" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_6" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_6" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_6" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_6" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_6" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_7" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_7" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_7" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_7" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_7" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_8" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_8" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_8" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_8" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_8" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_9" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_9" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_9" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_9" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_9" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_10" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_10" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_10" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_10" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_10" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_11" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_11" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_11" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_11" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_11" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_12" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_12" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_12" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_12" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_12" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_13" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_13" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_13" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_13" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_13" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_14" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_14" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_14" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_14" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_14" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_15" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_15" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_15" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_15" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_15" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_16" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_16" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_16" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_16" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_16" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_version_17" class="md-nav__link">
    RD_KAFKA_VERSION
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_unsupported_compression_type_17" class="md-nav__link">
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_resp_err_end_all_17" class="md-nav__link">
    RD_KAFKA_RESP_ERR_END_ALL
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_admin_op__cnt_17" class="md-nav__link">
    RD_KAFKA_ADMIN_OP__CNT
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rd_kafka_cdef_17" class="md-nav__link">
    RD_KAFKA_CDEF
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/idealo/php-rdkafka-ffi/edit/master/docs/api/constants.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="constants">Constants<a class="headerlink" href="#constants" title="Permanent link">&para;</a></h1>
<h3 id="rd_kafka_log_print">RD_KAFKA_LOG_PRINT<a class="headerlink" href="#rd_kafka_log_print" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_PRINT</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>
<h3 id="rd_kafka_log_syslog">RD_KAFKA_LOG_SYSLOG<a class="headerlink" href="#rd_kafka_log_syslog" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_SYSLOG</span> <span class="o">=</span> <span class="mi">101</span>
</code></pre></div>
<h3 id="rd_kafka_log_syslog_print">RD_KAFKA_LOG_SYSLOG_PRINT<a class="headerlink" href="#rd_kafka_log_syslog_print" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_LOG_SYSLOG_PRINT</span> <span class="o">=</span> <span class="mi">102</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_random">RD_KAFKA_MSG_PARTITIONER_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_random" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_RANDOM</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_consistent">RD_KAFKA_MSG_PARTITIONER_CONSISTENT<a class="headerlink" href="#rd_kafka_msg_partitioner_consistent" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_CONSISTENT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_consistent_random">RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_consistent_random" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_murmur2">RD_KAFKA_MSG_PARTITIONER_MURMUR2<a class="headerlink" href="#rd_kafka_msg_partitioner_murmur2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_MURMUR2</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_murmur2_random">RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_murmur2_random" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_fnv1a">RD_KAFKA_MSG_PARTITIONER_FNV1A<a class="headerlink" href="#rd_kafka_msg_partitioner_fnv1a" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_FNV1A</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<h3 id="rd_kafka_msg_partitioner_fnv1a_random">RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM<a class="headerlink" href="#rd_kafka_msg_partitioner_fnv1a_random" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<h3 id="rd_kafka_destroy_f_no_consumer_close">RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE<a class="headerlink" href="#rd_kafka_destroy_f_no_consumer_close" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_partition_ua">RD_KAFKA_PARTITION_UA<a class="headerlink" href="#rd_kafka_partition_ua" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PARTITION_UA</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Unassigned partition. </p>
<p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3002d1858385de283ea004893e352863"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3002d1858385de283ea004893e352863 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_beginning">RD_KAFKA_OFFSET_BEGINNING<a class="headerlink" href="#rd_kafka_offset_beginning" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_BEGINNING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>Start consuming from beginning of kafka partition queue: oldest msg </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_end">RD_KAFKA_OFFSET_END<a class="headerlink" href="#rd_kafka_offset_end" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_END</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Start consuming from end of kafka partition queue: next msg </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_stored">RD_KAFKA_OFFSET_STORED<a class="headerlink" href="#rd_kafka_offset_stored" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_STORED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span>
</code></pre></div>
<p>Start consuming from offset retrieved from offset store </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_invalid">RD_KAFKA_OFFSET_INVALID<a class="headerlink" href="#rd_kafka_offset_invalid" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1001</span>
</code></pre></div>
<p>Invalid offset </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1 </a></li>
</ul>
</div>
<h3 id="rd_kafka_offset_tail_base">RD_KAFKA_OFFSET_TAIL_BASE<a class="headerlink" href="#rd_kafka_offset_tail_base" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_OFFSET_TAIL_BASE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2000</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_msg_f_free">RD_KAFKA_MSG_F_FREE<a class="headerlink" href="#rd_kafka_msg_f_free" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_FREE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Producer message flags. </p>
<p>Delegate freeing of payload to rdkafka. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_copy">RD_KAFKA_MSG_F_COPY<a class="headerlink" href="#rd_kafka_msg_f_copy" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_COPY</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>rdkafka will make a copy of the payload. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_block">RD_KAFKA_MSG_F_BLOCK<a class="headerlink" href="#rd_kafka_msg_f_block" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_BLOCK</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call rd_kafka_poll() (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the produce() call when the message queue is full. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2 </a></li>
</ul>
</div>
<h3 id="rd_kafka_msg_f_partition">RD_KAFKA_MSG_F_PARTITION<a class="headerlink" href="#rd_kafka_msg_f_partition" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_F_PARTITION</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_purge_f_queue">RD_KAFKA_PURGE_F_QUEUE<a class="headerlink" href="#rd_kafka_purge_f_queue" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_QUEUE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_purge_f_inflight">RD_KAFKA_PURGE_F_INFLIGHT<a class="headerlink" href="#rd_kafka_purge_f_inflight" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_INFLIGHT</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_purge_f_non_blocking">RD_KAFKA_PURGE_F_NON_BLOCKING<a class="headerlink" href="#rd_kafka_purge_f_non_blocking" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PURGE_F_NON_BLOCKING</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_none">RD_KAFKA_EVENT_NONE<a class="headerlink" href="#rd_kafka_event_none" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_NONE</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_dr">RD_KAFKA_EVENT_DR<a class="headerlink" href="#rd_kafka_event_dr" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DR</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Producer Delivery report batch </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_fetch">RD_KAFKA_EVENT_FETCH<a class="headerlink" href="#rd_kafka_event_fetch" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_FETCH</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Fetched message (consumer) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_log">RD_KAFKA_EVENT_LOG<a class="headerlink" href="#rd_kafka_event_log" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_LOG</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Log message </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_error">RD_KAFKA_EVENT_ERROR<a class="headerlink" href="#rd_kafka_event_error" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ERROR</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>Error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_rebalance">RD_KAFKA_EVENT_REBALANCE<a class="headerlink" href="#rd_kafka_event_rebalance" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_REBALANCE</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Group rebalance (consumer) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_offset_commit">RD_KAFKA_EVENT_OFFSET_COMMIT<a class="headerlink" href="#rd_kafka_event_offset_commit" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_OFFSET_COMMIT</span> <span class="o">=</span> <span class="mi">32</span>
</code></pre></div>
<p>Offset commit result </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437 </a></li>
</ul>
</div>
<h3 id="rd_kafka_event_stats">RD_KAFKA_EVENT_STATS<a class="headerlink" href="#rd_kafka_event_stats" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_STATS</span> <span class="o">=</span> <span class="mi">64</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_createtopics_result">RD_KAFKA_EVENT_CREATETOPICS_RESULT<a class="headerlink" href="#rd_kafka_event_createtopics_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_CREATETOPICS_RESULT</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_deletetopics_result">RD_KAFKA_EVENT_DELETETOPICS_RESULT<a class="headerlink" href="#rd_kafka_event_deletetopics_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETETOPICS_RESULT</span> <span class="o">=</span> <span class="mi">101</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_createpartitions_result">RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT<a class="headerlink" href="#rd_kafka_event_createpartitions_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT</span> <span class="o">=</span> <span class="mi">102</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_alterconfigs_result">RD_KAFKA_EVENT_ALTERCONFIGS_RESULT<a class="headerlink" href="#rd_kafka_event_alterconfigs_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_ALTERCONFIGS_RESULT</span> <span class="o">=</span> <span class="mi">103</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_describeconfigs_result">RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT<a class="headerlink" href="#rd_kafka_event_describeconfigs_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT</span> <span class="o">=</span> <span class="mi">104</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_producer">RD_KAFKA_PRODUCER<a class="headerlink" href="#rd_kafka_producer" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_PRODUCER</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Producer client </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </a></li>
</ul>
</div>
<h3 id="rd_kafka_consumer">RD_KAFKA_CONSUMER<a class="headerlink" href="#rd_kafka_consumer" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONSUMER</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Consumer client </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_not_available">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_timestamp_not_available" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Timestamp not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_create_time">RD_KAFKA_TIMESTAMP_CREATE_TIME<a class="headerlink" href="#rd_kafka_timestamp_create_time" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_CREATE_TIME</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Message creation time </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_timestamp_log_append_time">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME<a class="headerlink" href="#rd_kafka_timestamp_log_append_time" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Log append time </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__begin">RD_KAFKA_RESP_ERR__BEGIN<a class="headerlink" href="#rd_kafka_resp_err__begin" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BEGIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">200</span>
</code></pre></div>
<p>Begin internal error codes </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__bad_msg">RD_KAFKA_RESP_ERR__BAD_MSG<a class="headerlink" href="#rd_kafka_resp_err__bad_msg" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BAD_MSG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">199</span>
</code></pre></div>
<p>Received message is incorrect </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__bad_compression">RD_KAFKA_RESP_ERR__BAD_COMPRESSION<a class="headerlink" href="#rd_kafka_resp_err__bad_compression" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">198</span>
</code></pre></div>
<p>Bad/unknown compression </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__destroy">RD_KAFKA_RESP_ERR__DESTROY<a class="headerlink" href="#rd_kafka_resp_err__destroy" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__DESTROY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">197</span>
</code></pre></div>
<p>Broker is going away </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fail">RD_KAFKA_RESP_ERR__FAIL<a class="headerlink" href="#rd_kafka_resp_err__fail" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FAIL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">196</span>
</code></pre></div>
<p>Generic failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__transport">RD_KAFKA_RESP_ERR__TRANSPORT<a class="headerlink" href="#rd_kafka_resp_err__transport" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TRANSPORT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">195</span>
</code></pre></div>
<p>Broker transport failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__crit_sys_resource">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE<a class="headerlink" href="#rd_kafka_resp_err__crit_sys_resource" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">194</span>
</code></pre></div>
<p>Critical system resource </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__resolve">RD_KAFKA_RESP_ERR__RESOLVE<a class="headerlink" href="#rd_kafka_resp_err__resolve" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__RESOLVE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">193</span>
</code></pre></div>
<p>Failed to resolve broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__msg_timed_out">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err__msg_timed_out" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">192</span>
</code></pre></div>
<p>Produced message timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__partition_eof">RD_KAFKA_RESP_ERR__PARTITION_EOF<a class="headerlink" href="#rd_kafka_resp_err__partition_eof" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PARTITION_EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">191</span>
</code></pre></div>
<p>Reached the end of the topic+partition queue on the broker. Not really an error. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_partition">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION<a class="headerlink" href="#rd_kafka_resp_err__unknown_partition" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">190</span>
</code></pre></div>
<p>Permanent: Partition does not exist in cluster. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__fs">RD_KAFKA_RESP_ERR__FS<a class="headerlink" href="#rd_kafka_resp_err__fs" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">189</span>
</code></pre></div>
<p>File or filesystem error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_topic">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC<a class="headerlink" href="#rd_kafka_resp_err__unknown_topic" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">188</span>
</code></pre></div>
<p>Permanent: Topic does not exist in cluster. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__all_brokers_down">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN<a class="headerlink" href="#rd_kafka_resp_err__all_brokers_down" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">187</span>
</code></pre></div>
<p>All broker connections are down. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__invalid_arg">RD_KAFKA_RESP_ERR__INVALID_ARG<a class="headerlink" href="#rd_kafka_resp_err__invalid_arg" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INVALID_ARG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">186</span>
</code></pre></div>
<p>Invalid argument, or invalid configuration </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__timed_out">RD_KAFKA_RESP_ERR__TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err__timed_out" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TIMED_OUT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">185</span>
</code></pre></div>
<p>Operation timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__queue_full">RD_KAFKA_RESP_ERR__QUEUE_FULL<a class="headerlink" href="#rd_kafka_resp_err__queue_full" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__QUEUE_FULL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">184</span>
</code></pre></div>
<p>Queue is full </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__isr_insuff">RD_KAFKA_RESP_ERR__ISR_INSUFF<a class="headerlink" href="#rd_kafka_resp_err__isr_insuff" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ISR_INSUFF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">183</span>
</code></pre></div>
<p>ISR count &lt; required.acks </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__node_update">RD_KAFKA_RESP_ERR__NODE_UPDATE<a class="headerlink" href="#rd_kafka_resp_err__node_update" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NODE_UPDATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">182</span>
</code></pre></div>
<p>Broker node update </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__ssl">RD_KAFKA_RESP_ERR__SSL<a class="headerlink" href="#rd_kafka_resp_err__ssl" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__SSL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">181</span>
</code></pre></div>
<p>SSL error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__wait_coord">RD_KAFKA_RESP_ERR__WAIT_COORD<a class="headerlink" href="#rd_kafka_resp_err__wait_coord" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__WAIT_COORD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span>
</code></pre></div>
<p>Waiting for coordinator to become available. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_group">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP<a class="headerlink" href="#rd_kafka_resp_err__unknown_group" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">179</span>
</code></pre></div>
<p>Unknown client group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__in_progress">RD_KAFKA_RESP_ERR__IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err__in_progress" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__IN_PROGRESS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">178</span>
</code></pre></div>
<p>Operation in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__prev_in_progress">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err__prev_in_progress" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">177</span>
</code></pre></div>
<p>Previous operation in progress, wait for it to finish. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__existing_subscription">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION<a class="headerlink" href="#rd_kafka_resp_err__existing_subscription" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">176</span>
</code></pre></div>
<p>This operation would interfere with an existing subscription </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__assign_partitions">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err__assign_partitions" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">175</span>
</code></pre></div>
<p>Assigned partitions (rebalance_cb) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__revoke_partitions">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err__revoke_partitions" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">174</span>
</code></pre></div>
<p>Revoked partitions (rebalance_cb) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__conflict">RD_KAFKA_RESP_ERR__CONFLICT<a class="headerlink" href="#rd_kafka_resp_err__conflict" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__CONFLICT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">173</span>
</code></pre></div>
<p>Conflicting use </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__state">RD_KAFKA_RESP_ERR__STATE<a class="headerlink" href="#rd_kafka_resp_err__state" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">172</span>
</code></pre></div>
<p>Wrong state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unknown_protocol">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL<a class="headerlink" href="#rd_kafka_resp_err__unknown_protocol" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">171</span>
</code></pre></div>
<p>Unknown protocol </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__not_implemented">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED<a class="headerlink" href="#rd_kafka_resp_err__not_implemented" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">170</span>
</code></pre></div>
<p>Not implemented </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__authentication">RD_KAFKA_RESP_ERR__AUTHENTICATION<a class="headerlink" href="#rd_kafka_resp_err__authentication" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__AUTHENTICATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">169</span>
</code></pre></div>
<p>Authentication failure </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__no_offset">RD_KAFKA_RESP_ERR__NO_OFFSET<a class="headerlink" href="#rd_kafka_resp_err__no_offset" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NO_OFFSET</span> <span class="o">=</span> <span class="o">-</span><span class="mi">168</span>
</code></pre></div>
<p>No stored offset </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__outdated">RD_KAFKA_RESP_ERR__OUTDATED<a class="headerlink" href="#rd_kafka_resp_err__outdated" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__OUTDATED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">167</span>
</code></pre></div>
<p>Outdated </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__timed_out_queue">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE<a class="headerlink" href="#rd_kafka_resp_err__timed_out_queue" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">166</span>
</code></pre></div>
<p>Timed out in queue </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__unsupported_feature">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE<a class="headerlink" href="#rd_kafka_resp_err__unsupported_feature" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">165</span>
</code></pre></div>
<p>Feature not supported by broker </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__wait_cache">RD_KAFKA_RESP_ERR__WAIT_CACHE<a class="headerlink" href="#rd_kafka_resp_err__wait_cache" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__WAIT_CACHE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">164</span>
</code></pre></div>
<p>Awaiting cache update </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err__intr">RD_KAFKA_RESP_ERR__INTR<a class="headerlink" href="#rd_kafka_resp_err__intr" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INTR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">163</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__key_serialization">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__key_serialization" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">162</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__value_serialization">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__value_serialization" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">161</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__key_deserialization">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__key_deserialization" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">160</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__value_deserialization">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION<a class="headerlink" href="#rd_kafka_resp_err__value_deserialization" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">159</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__partial">RD_KAFKA_RESP_ERR__PARTIAL<a class="headerlink" href="#rd_kafka_resp_err__partial" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PARTIAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">158</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__read_only">RD_KAFKA_RESP_ERR__READ_ONLY<a class="headerlink" href="#rd_kafka_resp_err__read_only" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__READ_ONLY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">157</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__noent">RD_KAFKA_RESP_ERR__NOENT<a class="headerlink" href="#rd_kafka_resp_err__noent" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">156</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__underflow">RD_KAFKA_RESP_ERR__UNDERFLOW<a class="headerlink" href="#rd_kafka_resp_err__underflow" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNDERFLOW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">155</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__invalid_type">RD_KAFKA_RESP_ERR__INVALID_TYPE<a class="headerlink" href="#rd_kafka_resp_err__invalid_type" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INVALID_TYPE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">154</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__retry">RD_KAFKA_RESP_ERR__RETRY<a class="headerlink" href="#rd_kafka_resp_err__retry" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__RETRY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">153</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__purge_queue">RD_KAFKA_RESP_ERR__PURGE_QUEUE<a class="headerlink" href="#rd_kafka_resp_err__purge_queue" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PURGE_QUEUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">152</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__purge_inflight">RD_KAFKA_RESP_ERR__PURGE_INFLIGHT<a class="headerlink" href="#rd_kafka_resp_err__purge_inflight" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__PURGE_INFLIGHT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">151</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__fatal">RD_KAFKA_RESP_ERR__FATAL<a class="headerlink" href="#rd_kafka_resp_err__fatal" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FATAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__inconsistent">RD_KAFKA_RESP_ERR__INCONSISTENT<a class="headerlink" href="#rd_kafka_resp_err__inconsistent" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__INCONSISTENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">149</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__gapless_guarantee">RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE<a class="headerlink" href="#rd_kafka_resp_err__gapless_guarantee" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">148</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__max_poll_exceeded">RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED<a class="headerlink" href="#rd_kafka_resp_err__max_poll_exceeded" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">147</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__end">RD_KAFKA_RESP_ERR__END<a class="headerlink" href="#rd_kafka_resp_err__end" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__END</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
</code></pre></div>
<p>End internal error codes </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown">RD_KAFKA_RESP_ERR_UNKNOWN<a class="headerlink" href="#rd_kafka_resp_err_unknown" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Unknown broker error </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_no_error">RD_KAFKA_RESP_ERR_NO_ERROR<a class="headerlink" href="#rd_kafka_resp_err_no_error" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NO_ERROR</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Success </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_offset_out_of_range">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE<a class="headerlink" href="#rd_kafka_resp_err_offset_out_of_range" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Offset out of range </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_msg">RD_KAFKA_RESP_ERR_INVALID_MSG<a class="headerlink" href="#rd_kafka_resp_err_invalid_msg" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_MSG</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>Invalid message </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_topic_or_part">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART<a class="headerlink" href="#rd_kafka_resp_err_unknown_topic_or_part" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>Unknown topic or partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_msg_size">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE<a class="headerlink" href="#rd_kafka_resp_err_invalid_msg_size" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>Invalid message size </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_leader_not_available">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_leader_not_available" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>Leader not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_leader_for_partition">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION<a class="headerlink" href="#rd_kafka_resp_err_not_leader_for_partition" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>Not leader for partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_request_timed_out">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT<a class="headerlink" href="#rd_kafka_resp_err_request_timed_out" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>Request timed out </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_broker_not_available">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_broker_not_available" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>Broker not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_replica_not_available">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_replica_not_available" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
<p>Replica not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_msg_size_too_large">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_msg_size_too_large" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
<p>Message size too large </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_stale_ctrl_epoch">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_stale_ctrl_epoch" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div>
<p>StaleControllerEpochCode </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_offset_metadata_too_large">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_offset_metadata_too_large" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</span> <span class="o">=</span> <span class="mi">12</span>
</code></pre></div>
<p>Offset metadata string too large </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_network_exception">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION<a class="headerlink" href="#rd_kafka_resp_err_network_exception" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</span> <span class="o">=</span> <span class="mi">13</span>
</code></pre></div>
<p>Broker disconnected before response received </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_load_in_progress">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_group_load_in_progress" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">14</span>
</code></pre></div>
<p>Group coordinator load in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_coordinator_not_available">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_group_coordinator_not_available" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div>
<p>Group coordinator not available </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_coordinator_for_group">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP<a class="headerlink" href="#rd_kafka_resp_err_not_coordinator_for_group" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
<p>Not coordinator for group </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_exception">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION<a class="headerlink" href="#rd_kafka_resp_err_topic_exception" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</span> <span class="o">=</span> <span class="mi">17</span>
</code></pre></div>
<p>Invalid topic </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_record_list_too_large">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE<a class="headerlink" href="#rd_kafka_resp_err_record_list_too_large" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</span> <span class="o">=</span> <span class="mi">18</span>
</code></pre></div>
<p>Message batch larger than configured server segment size </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_enough_replicas">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS<a class="headerlink" href="#rd_kafka_resp_err_not_enough_replicas" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</span> <span class="o">=</span> <span class="mi">19</span>
</code></pre></div>
<p>Not enough in-sync replicas </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_enough_replicas_after_append">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND<a class="headerlink" href="#rd_kafka_resp_err_not_enough_replicas_after_append" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</span> <span class="o">=</span> <span class="mi">20</span>
</code></pre></div>
<p>Message(s) written to insufficient number of in-sync replicas </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_required_acks">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS<a class="headerlink" href="#rd_kafka_resp_err_invalid_required_acks" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</span> <span class="o">=</span> <span class="mi">21</span>
</code></pre></div>
<p>Invalid required acks value </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_illegal_generation">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION<a class="headerlink" href="#rd_kafka_resp_err_illegal_generation" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</span> <span class="o">=</span> <span class="mi">22</span>
</code></pre></div>
<p>Specified group generation id is not valid </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_inconsistent_group_protocol">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL<a class="headerlink" href="#rd_kafka_resp_err_inconsistent_group_protocol" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</span> <span class="o">=</span> <span class="mi">23</span>
</code></pre></div>
<p>Inconsistent group protocol </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_group_id">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID<a class="headerlink" href="#rd_kafka_resp_err_invalid_group_id" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</span> <span class="o">=</span> <span class="mi">24</span>
</code></pre></div>
<p>Invalid group.id </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unknown_member_id">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_member_id" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</span> <span class="o">=</span> <span class="mi">25</span>
</code></pre></div>
<p>Unknown member </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_session_timeout">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT<a class="headerlink" href="#rd_kafka_resp_err_invalid_session_timeout" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</span> <span class="o">=</span> <span class="mi">26</span>
</code></pre></div>
<p>Invalid session timeout </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_rebalance_in_progress">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_rebalance_in_progress" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">27</span>
</code></pre></div>
<p>Group rebalance in progress </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_commit_offset_size">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE<a class="headerlink" href="#rd_kafka_resp_err_invalid_commit_offset_size" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</span> <span class="o">=</span> <span class="mi">28</span>
</code></pre></div>
<p>Commit offset data size is not valid </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_authorization_failed">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_topic_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">29</span>
</code></pre></div>
<p>Topic authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_group_authorization_failed">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_group_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">30</span>
</code></pre></div>
<p>Group authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_cluster_authorization_failed">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_cluster_authorization_failed" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">31</span>
</code></pre></div>
<p>Cluster authorization failed </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_timestamp">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP<a class="headerlink" href="#rd_kafka_resp_err_invalid_timestamp" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</span> <span class="o">=</span> <span class="mi">32</span>
</code></pre></div>
<p>Invalid timestamp </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_sasl_mechanism">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM<a class="headerlink" href="#rd_kafka_resp_err_unsupported_sasl_mechanism" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</span> <span class="o">=</span> <span class="mi">33</span>
</code></pre></div>
<p>Unsupported SASL mechanism </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_illegal_sasl_state">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE<a class="headerlink" href="#rd_kafka_resp_err_illegal_sasl_state" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</span> <span class="o">=</span> <span class="mi">34</span>
</code></pre></div>
<p>Illegal SASL state </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_version">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION<a class="headerlink" href="#rd_kafka_resp_err_unsupported_version" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</span> <span class="o">=</span> <span class="mi">35</span>
</code></pre></div>
<p>Unuspported version </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_topic_already_exists">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS<a class="headerlink" href="#rd_kafka_resp_err_topic_already_exists" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</span> <span class="o">=</span> <span class="mi">36</span>
</code></pre></div>
<p>Topic already exists </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_partitions">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS<a class="headerlink" href="#rd_kafka_resp_err_invalid_partitions" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</span> <span class="o">=</span> <span class="mi">37</span>
</code></pre></div>
<p>Invalid number of partitions </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_replication_factor">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR<a class="headerlink" href="#rd_kafka_resp_err_invalid_replication_factor" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</span> <span class="o">=</span> <span class="mi">38</span>
</code></pre></div>
<p>Invalid replication factor </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_replica_assignment">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT<a class="headerlink" href="#rd_kafka_resp_err_invalid_replica_assignment" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</span> <span class="o">=</span> <span class="mi">39</span>
</code></pre></div>
<p>Invalid replica assignment </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_config">RD_KAFKA_RESP_ERR_INVALID_CONFIG<a class="headerlink" href="#rd_kafka_resp_err_invalid_config" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_CONFIG</span> <span class="o">=</span> <span class="mi">40</span>
</code></pre></div>
<p>Invalid config </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_not_controller">RD_KAFKA_RESP_ERR_NOT_CONTROLLER<a class="headerlink" href="#rd_kafka_resp_err_not_controller" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_CONTROLLER</span> <span class="o">=</span> <span class="mi">41</span>
</code></pre></div>
<p>Not controller for cluster </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_invalid_request">RD_KAFKA_RESP_ERR_INVALID_REQUEST<a class="headerlink" href="#rd_kafka_resp_err_invalid_request" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_REQUEST</span> <span class="o">=</span> <span class="mi">42</span>
</code></pre></div>
<p>Invalid request </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_for_message_format">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT<a class="headerlink" href="#rd_kafka_resp_err_unsupported_for_message_format" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</span> <span class="o">=</span> <span class="mi">43</span>
</code></pre></div>
<p>Message format on broker does not support request </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_policy_violation">RD_KAFKA_RESP_ERR_POLICY_VIOLATION<a class="headerlink" href="#rd_kafka_resp_err_policy_violation" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_POLICY_VIOLATION</span> <span class="o">=</span> <span class="mi">44</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_out_of_order_sequence_number">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER<a class="headerlink" href="#rd_kafka_resp_err_out_of_order_sequence_number" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</span> <span class="o">=</span> <span class="mi">45</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_duplicate_sequence_number">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER<a class="headerlink" href="#rd_kafka_resp_err_duplicate_sequence_number" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</span> <span class="o">=</span> <span class="mi">46</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_producer_epoch">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_invalid_producer_epoch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</span> <span class="o">=</span> <span class="mi">47</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_txn_state">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE<a class="headerlink" href="#rd_kafka_resp_err_invalid_txn_state" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</span> <span class="o">=</span> <span class="mi">48</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_producer_id_mapping">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING<a class="headerlink" href="#rd_kafka_resp_err_invalid_producer_id_mapping" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</span> <span class="o">=</span> <span class="mi">49</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_transaction_timeout">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT<a class="headerlink" href="#rd_kafka_resp_err_invalid_transaction_timeout" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</span> <span class="o">=</span> <span class="mi">50</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_concurrent_transactions">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS<a class="headerlink" href="#rd_kafka_resp_err_concurrent_transactions" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_transaction_coordinator_fenced">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED<a class="headerlink" href="#rd_kafka_resp_err_transaction_coordinator_fenced" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</span> <span class="o">=</span> <span class="mi">52</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_transactional_id_authorization_failed">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_transactional_id_authorization_failed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">53</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_security_disabled">RD_KAFKA_RESP_ERR_SECURITY_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_security_disabled" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_SECURITY_DISABLED</span> <span class="o">=</span> <span class="mi">54</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_operation_not_attempted">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED<a class="headerlink" href="#rd_kafka_resp_err_operation_not_attempted" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</span> <span class="o">=</span> <span class="mi">55</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_kafka_storage_error">RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR<a class="headerlink" href="#rd_kafka_resp_err_kafka_storage_error" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR</span> <span class="o">=</span> <span class="mi">56</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_log_dir_not_found">RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_log_dir_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND</span> <span class="o">=</span> <span class="mi">57</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_sasl_authentication_failed">RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_sasl_authentication_failed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED</span> <span class="o">=</span> <span class="mi">58</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_unknown_producer_id">RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID<a class="headerlink" href="#rd_kafka_resp_err_unknown_producer_id" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID</span> <span class="o">=</span> <span class="mi">59</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_reassignment_in_progress">RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_reassignment_in_progress" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_auth_disabled">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_auth_disabled" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED</span> <span class="o">=</span> <span class="mi">61</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_not_found">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND</span> <span class="o">=</span> <span class="mi">62</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_owner_mismatch">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_owner_mismatch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH</span> <span class="o">=</span> <span class="mi">63</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_request_not_allowed">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_request_not_allowed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED</span> <span class="o">=</span> <span class="mi">64</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_authorization_failed">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_authorization_failed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED</span> <span class="o">=</span> <span class="mi">65</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_delegation_token_expired">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED<a class="headerlink" href="#rd_kafka_resp_err_delegation_token_expired" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED</span> <span class="o">=</span> <span class="mi">66</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_principal_type">RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE<a class="headerlink" href="#rd_kafka_resp_err_invalid_principal_type" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE</span> <span class="o">=</span> <span class="mi">67</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_non_empty_group">RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP<a class="headerlink" href="#rd_kafka_resp_err_non_empty_group" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP</span> <span class="o">=</span> <span class="mi">68</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_group_id_not_found">RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_group_id_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND</span> <span class="o">=</span> <span class="mi">69</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_fetch_session_id_not_found">RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_fetch_session_id_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND</span> <span class="o">=</span> <span class="mi">70</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_fetch_session_epoch">RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_invalid_fetch_session_epoch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH</span> <span class="o">=</span> <span class="mi">71</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_listener_not_found">RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_listener_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND</span> <span class="o">=</span> <span class="mi">72</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_topic_deletion_disabled">RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED<a class="headerlink" href="#rd_kafka_resp_err_topic_deletion_disabled" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED</span> <span class="o">=</span> <span class="mi">73</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_vtype_end">RD_KAFKA_VTYPE_END<a class="headerlink" href="#rd_kafka_vtype_end" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_END</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>va-arg sentinel </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li>
<p><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165 </a></p>
</li>
<li>
<p><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></p>
</li>
</ul>
</div>
<h3 id="rd_kafka_vtype_topic">RD_KAFKA_VTYPE_TOPIC<a class="headerlink" href="#rd_kafka_vtype_topic" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_TOPIC</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
<p>(const char *) Topic name </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_rkt">RD_KAFKA_VTYPE_RKT<a class="headerlink" href="#rd_kafka_vtype_rkt" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_RKT</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p>(rd_kafka_topic_t *) Topic handle </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_partition">RD_KAFKA_VTYPE_PARTITION<a class="headerlink" href="#rd_kafka_vtype_partition" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_PARTITION</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
<p>(int32_t) Partition </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_value">RD_KAFKA_VTYPE_VALUE<a class="headerlink" href="#rd_kafka_vtype_value" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_VALUE</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
<p>(void *, size_t) Message value (payload) </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_key">RD_KAFKA_VTYPE_KEY<a class="headerlink" href="#rd_kafka_vtype_key" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_KEY</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
<p>(void *, size_t) Message key </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_opaque">RD_KAFKA_VTYPE_OPAQUE<a class="headerlink" href="#rd_kafka_vtype_opaque" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_OPAQUE</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
<p>(void *) Application opaque </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_msgflags">RD_KAFKA_VTYPE_MSGFLAGS<a class="headerlink" href="#rd_kafka_vtype_msgflags" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_MSGFLAGS</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
<p>(int) RD_KAFKA_MSG_F_.. flags </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_timestamp">RD_KAFKA_VTYPE_TIMESTAMP<a class="headerlink" href="#rd_kafka_vtype_timestamp" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_TIMESTAMP</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
<p>(int64_t) Milliseconds since epoch UTC </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b </a></li>
</ul>
</div>
<h3 id="rd_kafka_vtype_header">RD_KAFKA_VTYPE_HEADER<a class="headerlink" href="#rd_kafka_vtype_header" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_HEADER</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_vtype_t</p>
<h3 id="rd_kafka_vtype_headers">RD_KAFKA_VTYPE_HEADERS<a class="headerlink" href="#rd_kafka_vtype_headers" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VTYPE_HEADERS</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div>
enum rd_kafka_vtype_t</p>
<h3 id="rd_kafka_msg_status_not_persisted">RD_KAFKA_MSG_STATUS_NOT_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_not_persisted" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_NOT_PERSISTED</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_msg_status_t</p>
<h3 id="rd_kafka_msg_status_possibly_persisted">RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_possibly_persisted" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_msg_status_t</p>
<h3 id="rd_kafka_msg_status_persisted">RD_KAFKA_MSG_STATUS_PERSISTED<a class="headerlink" href="#rd_kafka_msg_status_persisted" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_MSG_STATUS_PERSISTED</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_msg_status_t</p>
<h3 id="rd_kafka_conf_unknown">RD_KAFKA_CONF_UNKNOWN<a class="headerlink" href="#rd_kafka_conf_unknown" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>Unknown configuration name. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_conf_invalid">RD_KAFKA_CONF_INVALID<a class="headerlink" href="#rd_kafka_conf_invalid" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>Invalid configuration value. </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_conf_ok">RD_KAFKA_CONF_OK<a class="headerlink" href="#rd_kafka_conf_ok" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONF_OK</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>Configuration okay </p>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 </a></li>
</ul>
</div>
<h3 id="rd_kafka_admin_op_any">RD_KAFKA_ADMIN_OP_ANY<a class="headerlink" href="#rd_kafka_admin_op_any" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ANY</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_createtopics">RD_KAFKA_ADMIN_OP_CREATETOPICS<a class="headerlink" href="#rd_kafka_admin_op_createtopics" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_CREATETOPICS</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_deletetopics">RD_KAFKA_ADMIN_OP_DELETETOPICS<a class="headerlink" href="#rd_kafka_admin_op_deletetopics" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETETOPICS</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_createpartitions">RD_KAFKA_ADMIN_OP_CREATEPARTITIONS<a class="headerlink" href="#rd_kafka_admin_op_createpartitions" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_CREATEPARTITIONS</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_alterconfigs">RD_KAFKA_ADMIN_OP_ALTERCONFIGS<a class="headerlink" href="#rd_kafka_admin_op_alterconfigs" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_ALTERCONFIGS</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_describeconfigs">RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS<a class="headerlink" href="#rd_kafka_admin_op_describeconfigs" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_config_source_unknown_config">RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG<a class="headerlink" href="#rd_kafka_config_source_unknown_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source_dynamic_topic_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_topic_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source_dynamic_broker_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_broker_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source_dynamic_default_broker_config">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_dynamic_default_broker_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source_static_broker_config">RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG<a class="headerlink" href="#rd_kafka_config_source_static_broker_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source_default_config">RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG<a class="headerlink" href="#rd_kafka_config_source_default_config" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_config_source__cnt">RD_KAFKA_CONFIG_SOURCE__CNT<a class="headerlink" href="#rd_kafka_config_source__cnt" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CONFIG_SOURCE__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_ConfigSource_t</p>
<h3 id="rd_kafka_resource_unknown">RD_KAFKA_RESOURCE_UNKNOWN<a class="headerlink" href="#rd_kafka_resource_unknown" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resource_any">RD_KAFKA_RESOURCE_ANY<a class="headerlink" href="#rd_kafka_resource_any" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_ANY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resource_topic">RD_KAFKA_RESOURCE_TOPIC<a class="headerlink" href="#rd_kafka_resource_topic" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_TOPIC</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resource_group">RD_KAFKA_RESOURCE_GROUP<a class="headerlink" href="#rd_kafka_resource_group" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_GROUP</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resource_broker">RD_KAFKA_RESOURCE_BROKER<a class="headerlink" href="#rd_kafka_resource_broker" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE_BROKER</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resource__cnt">RD_KAFKA_RESOURCE__CNT<a class="headerlink" href="#rd_kafka_resource__cnt" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESOURCE__CNT</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>
enum rd_kafka_ResourceType_t</p>
<h3 id="rd_kafka_resp_err_fenced_leader_epoch">RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_fenced_leader_epoch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH</span> <span class="o">=</span> <span class="mi">74</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_unknown_leader_epoch">RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_unknown_leader_epoch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH</span> <span class="o">=</span> <span class="mi">75</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_stale_broker_epoch">RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH<a class="headerlink" href="#rd_kafka_resp_err_stale_broker_epoch" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH</span> <span class="o">=</span> <span class="mi">77</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_offset_not_available">RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_offset_not_available" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">78</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_member_id_required">RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED<a class="headerlink" href="#rd_kafka_resp_err_member_id_required" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED</span> <span class="o">=</span> <span class="mi">79</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_preferred_leader_not_available">RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_preferred_leader_not_available" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">80</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_group_max_size_reached">RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED<a class="headerlink" href="#rd_kafka_resp_err_group_max_size_reached" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED</span> <span class="o">=</span> <span class="mi">81</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_event_oauthbearer_token_refresh">RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH<a class="headerlink" href="#rd_kafka_event_oauthbearer_token_refresh" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH</span> <span class="o">=</span> <span class="mi">256</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_cert_public_key">RD_KAFKA_CERT_PUBLIC_KEY<a class="headerlink" href="#rd_kafka_cert_public_key" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_PUBLIC_KEY</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_cert_type_t</p>
<h3 id="rd_kafka_cert_private_key">RD_KAFKA_CERT_PRIVATE_KEY<a class="headerlink" href="#rd_kafka_cert_private_key" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_PRIVATE_KEY</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_cert_type_t</p>
<h3 id="rd_kafka_cert_ca">RD_KAFKA_CERT_CA<a class="headerlink" href="#rd_kafka_cert_ca" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_CA</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_cert_type_t</p>
<h3 id="rd_kafka_cert__cnt">RD_KAFKA_CERT__CNT<a class="headerlink" href="#rd_kafka_cert__cnt" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_cert_type_t</p>
<h3 id="rd_kafka_cert_enc_pkcs12">RD_KAFKA_CERT_ENC_PKCS12<a class="headerlink" href="#rd_kafka_cert_enc_pkcs12" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_PKCS12</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_cert_enc_t</p>
<h3 id="rd_kafka_cert_enc_der">RD_KAFKA_CERT_ENC_DER<a class="headerlink" href="#rd_kafka_cert_enc_der" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_DER</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_cert_enc_t</p>
<h3 id="rd_kafka_cert_enc_pem">RD_KAFKA_CERT_ENC_PEM<a class="headerlink" href="#rd_kafka_cert_enc_pem" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC_PEM</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_cert_enc_t</p>
<h3 id="rd_kafka_cert_enc__cnt">RD_KAFKA_CERT_ENC__CNT<a class="headerlink" href="#rd_kafka_cert_enc__cnt" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CERT_ENC__CNT</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>
enum rd_kafka_cert_enc_t</p>
<h3 id="rd_kafka_thread_main">RD_KAFKA_THREAD_MAIN<a class="headerlink" href="#rd_kafka_thread_main" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_MAIN</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
enum rd_kafka_thread_type_t</p>
<h3 id="rd_kafka_thread_background">RD_KAFKA_THREAD_BACKGROUND<a class="headerlink" href="#rd_kafka_thread_background" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_BACKGROUND</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>
enum rd_kafka_thread_type_t</p>
<h3 id="rd_kafka_thread_broker">RD_KAFKA_THREAD_BROKER<a class="headerlink" href="#rd_kafka_thread_broker" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_THREAD_BROKER</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
enum rd_kafka_thread_type_t</p>
<h3 id="rd_kafka_resp_err__unknown_broker">RD_KAFKA_RESP_ERR__UNKNOWN_BROKER<a class="headerlink" href="#rd_kafka_resp_err__unknown_broker" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__UNKNOWN_BROKER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">146</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_coordinator_load_in_progress">RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_coordinator_load_in_progress" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">14</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_coordinator_not_available">RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_coordinator_not_available" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_not_coordinator">RD_KAFKA_RESP_ERR_NOT_COORDINATOR<a class="headerlink" href="#rd_kafka_resp_err_not_coordinator" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NOT_COORDINATOR</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__not_configured">RD_KAFKA_RESP_ERR__NOT_CONFIGURED<a class="headerlink" href="#rd_kafka_resp_err__not_configured" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOT_CONFIGURED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">145</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__fenced">RD_KAFKA_RESP_ERR__FENCED<a class="headerlink" href="#rd_kafka_resp_err__fenced" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__FENCED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">144</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__application">RD_KAFKA_RESP_ERR__APPLICATION<a class="headerlink" href="#rd_kafka_resp_err__application" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__APPLICATION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">143</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_fenced_instance_id">RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID<a class="headerlink" href="#rd_kafka_resp_err_fenced_instance_id" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_eligible_leaders_not_available">RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE<a class="headerlink" href="#rd_kafka_resp_err_eligible_leaders_not_available" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_election_not_needed">RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED<a class="headerlink" href="#rd_kafka_resp_err_election_not_needed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED</span> <span class="o">=</span> <span class="mi">84</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_no_reassignment_in_progress">RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS<a class="headerlink" href="#rd_kafka_resp_err_no_reassignment_in_progress" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">85</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_group_subscribed_to_topic">RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC<a class="headerlink" href="#rd_kafka_resp_err_group_subscribed_to_topic" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC</span> <span class="o">=</span> <span class="mi">86</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_record">RD_KAFKA_RESP_ERR_INVALID_RECORD<a class="headerlink" href="#rd_kafka_resp_err_invalid_record" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_RECORD</span> <span class="o">=</span> <span class="mi">87</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_unstable_offset_commit">RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT<a class="headerlink" href="#rd_kafka_resp_err_unstable_offset_commit" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT</span> <span class="o">=</span> <span class="mi">88</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_event_deleterecords_result">RD_KAFKA_EVENT_DELETERECORDS_RESULT<a class="headerlink" href="#rd_kafka_event_deleterecords_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETERECORDS_RESULT</span> <span class="o">=</span> <span class="mi">105</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_deletegroups_result">RD_KAFKA_EVENT_DELETEGROUPS_RESULT<a class="headerlink" href="#rd_kafka_event_deletegroups_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETEGROUPS_RESULT</span> <span class="o">=</span> <span class="mi">106</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_event_deleteconsumergroupoffsets_result">RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT<a class="headerlink" href="#rd_kafka_event_deleteconsumergroupoffsets_result" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT</span> <span class="o">=</span> <span class="mi">107</span>
</code></pre></div>
define</p>
<h3 id="rd_kafka_resp_err__assignment_lost">RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST<a class="headerlink" href="#rd_kafka_resp_err__assignment_lost" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">142</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err__noop">RD_KAFKA_RESP_ERR__NOOP<a class="headerlink" href="#rd_kafka_resp_err__noop" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__NOOP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">141</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_throttling_quota_exceeded">RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED<a class="headerlink" href="#rd_kafka_resp_err_throttling_quota_exceeded" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_producer_fenced">RD_KAFKA_RESP_ERR_PRODUCER_FENCED<a class="headerlink" href="#rd_kafka_resp_err_producer_fenced" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PRODUCER_FENCED</span> <span class="o">=</span> <span class="mi">90</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_resource_not_found">RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND<a class="headerlink" href="#rd_kafka_resp_err_resource_not_found" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND</span> <span class="o">=</span> <span class="mi">91</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_duplicate_resource">RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE<a class="headerlink" href="#rd_kafka_resp_err_duplicate_resource" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE</span> <span class="o">=</span> <span class="mi">92</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_unacceptable_credential">RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL<a class="headerlink" href="#rd_kafka_resp_err_unacceptable_credential" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL</span> <span class="o">=</span> <span class="mi">93</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_inconsistent_voter_set">RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET<a class="headerlink" href="#rd_kafka_resp_err_inconsistent_voter_set" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET</span> <span class="o">=</span> <span class="mi">94</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_invalid_update_version">RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION<a class="headerlink" href="#rd_kafka_resp_err_invalid_update_version" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION</span> <span class="o">=</span> <span class="mi">95</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_feature_update_failed">RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED<a class="headerlink" href="#rd_kafka_resp_err_feature_update_failed" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED</span> <span class="o">=</span> <span class="mi">96</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_principal_deserialization_failure">RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE<a class="headerlink" href="#rd_kafka_resp_err_principal_deserialization_failure" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE</span> <span class="o">=</span> <span class="mi">97</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op_deleterecords">RD_KAFKA_ADMIN_OP_DELETERECORDS<a class="headerlink" href="#rd_kafka_admin_op_deleterecords" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETERECORDS</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_deletegroups">RD_KAFKA_ADMIN_OP_DELETEGROUPS<a class="headerlink" href="#rd_kafka_admin_op_deletegroups" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETEGROUPS</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_admin_op_deleteconsumergroupoffsets">RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS<a class="headerlink" href="#rd_kafka_admin_op_deleteconsumergroupoffsets" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_resp_err__auto_offset_reset">RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET<a class="headerlink" href="#rd_kafka_resp_err__auto_offset_reset" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET</span> <span class="o">=</span> <span class="o">-</span><span class="mi">140</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_supported_methods">RD_KAFKA_SUPPORTED_METHODS<a class="headerlink" href="#rd_kafka_supported_methods" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_SUPPORTED_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rd_kafka_version&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_version_str&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_debug_contexts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_err_descs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_err2str&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_err2name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_last_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_errno2err&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_errno&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_fatal_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_test_fatal_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_add_range&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_del&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_del_by_idx&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_copy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_set_offset&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_find&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_list_sort&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_headers_copy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_remove&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get_last&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_get_all&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_timestamp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_latency&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_detach_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_set_headers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_header_cnt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_status&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dup_filter&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_events&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_background_event_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_dr_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_dr_msg_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_consume_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_rebalance_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_offset_commit_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_error_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_throttle_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_log_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_stats_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_socket_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_connect_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_closesocket_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_default_topic_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_get&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_dump_free&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_properties_show&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_default_topic_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_partitioner_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_conf_set_msg_order_cmp&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_partition_available&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_consistent&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_consistent_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_murmur2&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_murmur2_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_destroy_flags&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_memberid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_clusterid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_controllerid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_yield&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_pause_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_resume_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_query_watermark_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_get_watermark_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offsets_for_times&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_free&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_main&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_consumer&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_get_background&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_forward&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_log_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_length&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_io_event_enable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_cb_event_enable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_start&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_start_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_stop&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_seek&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_batch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_callback&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_batch_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consume_callback_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offset_store&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_offsets_store&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_subscribe&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_unsubscribe&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_subscription&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_close&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_message&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_queue&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_committed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_position&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produce&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_producev&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produce_batch&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_flush&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_purge&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_metadata&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_metadata_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_list_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_list_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_brokers_add&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_logger&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_set_log_level&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_log_print&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_log_syslog&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_outq_len&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_dump&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_thread_cnt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_wait_destroyed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_unittest&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_poll_set_consumer&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_next&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_message_count&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_error_is_fatal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_log&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_stats&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_topic_partition_list&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_topic_partition&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_CreateTopics_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteTopics_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_CreatePartitions_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_AlterConfigs_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DescribeConfigs_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_poll&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_poll_callback&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_plugin_f_conf_init_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_set_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_dup_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_conf_destroy_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_new_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_destroy_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_send_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_acknowledgement_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_consume_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_commit_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_request_sent_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_dup&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_conf_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_interceptor_add_on_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_send&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_acknowledgement&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_consume&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_commit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_request_sent&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_topic_result_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_request_timeout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_operation_timeout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_validate_only&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_broker&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AdminOptions_set_opaque&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_set_replica_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewTopic_set_config&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateTopics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreateTopics_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopic_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteTopics_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_NewPartitions_set_replica_assignment&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreatePartitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_CreatePartitions_result_topics&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigSource_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_value&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_source&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_read_only&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_default&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_sensitive&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_is_synonym&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigEntry_synonyms&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ResourceType_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_set_config&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_configs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_type&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_ConfigResource_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConfigs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_AlterConfigs_result_resources&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConfigs&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DescribeConfigs_result_resources&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.0.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_oauthbearer_token_refresh_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_ssl_cert_verify_cb&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_ssl_cert&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_config_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_oauthbearer_set_token&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_oauthbearer_set_token_failure&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_thread_start_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_thread_exit_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_thread_start&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_thread_exit&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.2.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_handle&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_cluster_bootstraps&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_push_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_topic_set_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_leader&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_follower&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_partition_set_follower_wmarks&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_rack&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.3.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_code&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_string&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_is_fatal&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_is_retriable&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_txn_requires_abort&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_error_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_fnv1a&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_msg_partitioner_fnv1a_random&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_write&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_read&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_init_transactions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_begin_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_send_offsets_to_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_commit_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_abort_transaction&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_handle_mock_cluster&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_topic_create&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_down&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_up&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_coordinator_set&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_set_apiversion&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_set_rtt&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.4.4&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_errstr&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_message_broker_id&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_produceva&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_debug_contexts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_push_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.5.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.1&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_get_default_topic_conf&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_queue_yield&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_seek_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_incremental_assign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_incremental_unassign&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_rebalance_protocol&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_assignment_lost&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_consumer_group_metadata_new_with_genid&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteRecords_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteGroups_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_event_DeleteConsumerGroupOffsets_result&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_error&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_name&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_group_result_partitions&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteRecords_result_offsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroup_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteGroups_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_new&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_destroy&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_destroy_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_DeleteConsumerGroupOffsets_result_groups&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_clear_request_errors&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_push_request_errors_array&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_f_on_response_received_t&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.1&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_interceptor_add_on_response_received&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.6.1&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_conf_set_engine_callback_data&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_calloc&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mem_malloc&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">],</span> <span class="s1">&#39;rd_kafka_mock_broker_push_request_error_rtts&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.7.0&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;1.8.2&#39;</span><span class="p">]]</span>
</code></pre></div>
<h3 id="rd_kafka_version">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16777471</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">74</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">75</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_1">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16777727</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_1">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_1" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_1">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_1" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_1">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_1" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_1">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_1" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_2">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16843007</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_2">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_2" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_2">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_2" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_2">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_2" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_2">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_2" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_3">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_3" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16908543</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_3">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_3" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_3">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_3" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_3">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_3" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_3">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_3" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_4">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_4" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16908799</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_4">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_4" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_4">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_4" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_4">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_4" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_4">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_4" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_5">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_5" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16909055</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_5">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_5" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_5">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_5" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_5">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_5" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_5">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_5" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_6">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_6" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">16974079</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_6">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_6" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_6">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_6" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">82</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_6">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_6" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_6">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_6" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_7">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_7" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17039615</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_7">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_7" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_7">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_7" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_7">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_7" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_7">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_7" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_8">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_8" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17040127</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_8">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_8" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_8">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_8" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_8">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_8" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_8">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_8" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_9">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_9" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17040639</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_9">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_9" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_9">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_9" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_9">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_9" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_9">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_9" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_10">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_10" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105151</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_10">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_10" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_10">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_10" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">83</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_10">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_10" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_10">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_10" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_11">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_11" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105663</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_11">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_11" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_11">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_11" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_11">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_11" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_11">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_11" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_12">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_12" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17105919</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_12">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_12" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_12">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_12" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">89</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_12">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_12" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_12">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_12" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_13">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_13" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17170687</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_13">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_13" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_13">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_13" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_13">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_13" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_13">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_13" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_14">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_14" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17170943</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_14">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_14" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_14">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_14" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_14">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_14" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_14">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_14" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_15">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_15" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17236223</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_15">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_15" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_15">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_15" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_15">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_15" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_15">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_15" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_16">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_16" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17301759</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_16">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_16" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_16">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_16" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_16">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_16" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_16">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_16" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
<h3 id="rd_kafka_version_17">RD_KAFKA_VERSION<a class="headerlink" href="#rd_kafka_version_17" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_VERSION</span> <span class="o">=</span> <span class="mi">17302271</span>
</code></pre></div>
<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use rd_kafka_version() </dd></dl>

<div class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a href="https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e"> https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e </a></li>
</ul>
</div>
<h3 id="rd_kafka_resp_err_unsupported_compression_type_17">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE<a class="headerlink" href="#rd_kafka_resp_err_unsupported_compression_type_17" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="mi">76</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_resp_err_end_all_17">RD_KAFKA_RESP_ERR_END_ALL<a class="headerlink" href="#rd_kafka_resp_err_end_all_17" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_RESP_ERR_END_ALL</span> <span class="o">=</span> <span class="mi">98</span>
</code></pre></div>
enum rd_kafka_resp_err_t</p>
<h3 id="rd_kafka_admin_op__cnt_17">RD_KAFKA_ADMIN_OP__CNT<a class="headerlink" href="#rd_kafka_admin_op__cnt_17" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_ADMIN_OP__CNT</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>
enum rd_kafka_admin_op_t</p>
<h3 id="rd_kafka_cdef_17">RD_KAFKA_CDEF<a class="headerlink" href="#rd_kafka_cdef_17" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><code><span class="k">public</span> <span class="nx">RD_KAFKA_CDEF</span> <span class="o">=</span> <span class="s1">&#39;typedef long int ssize_t;</span>
<span class="s1">typedef struct _IO_FILE FILE;</span>
<span class="s1">typedef long int mode_t;</span>
<span class="s1">typedef signed int int16_t;</span>
<span class="s1">typedef signed int int32_t;</span>
<span class="s1">typedef signed long int int64_t;</span>
<span class="s1">int rd_kafka_version(void);</span>
<span class="s1">const char *rd_kafka_version_str(void);</span>
<span class="s1">typedef enum rd_kafka_type_t {</span>
<span class="s1">  RD_KAFKA_PRODUCER,</span>
<span class="s1">  RD_KAFKA_CONSUMER,</span>
<span class="s1">} rd_kafka_type_t;</span>
<span class="s1">typedef enum rd_kafka_timestamp_type_t {</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_NOT_AVAILABLE,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_CREATE_TIME,</span>
<span class="s1">  RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME,</span>
<span class="s1">} rd_kafka_timestamp_type_t;</span>
<span class="s1">const char *rd_kafka_get_debug_contexts(void);</span>
<span class="s1">typedef struct rd_kafka_s rd_kafka_t;</span>
<span class="s1">typedef struct rd_kafka_topic_s rd_kafka_topic_t;</span>
<span class="s1">typedef struct rd_kafka_conf_s rd_kafka_conf_t;</span>
<span class="s1">typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;</span>
<span class="s1">typedef struct rd_kafka_queue_s rd_kafka_queue_t;</span>
<span class="s1">typedef struct rd_kafka_op_s rd_kafka_event_t;</span>
<span class="s1">typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t;</span>
<span class="s1">typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t;</span>
<span class="s1">typedef struct rd_kafka_error_s {</span>
<span class="s1">  unsigned int code;</span>
<span class="s1">  char *errstr;</span>
<span class="s1">  unsigned char fatal;</span>
<span class="s1">  unsigned char retriable;</span>
<span class="s1">  unsigned char txn_requires_abort;</span>
<span class="s1">} rd_kafka_error_t;</span>
<span class="s1">typedef struct rd_kafka_headers_s rd_kafka_headers_t;</span>
<span class="s1">typedef struct rd_kafka_group_result_s rd_kafka_group_result_t;</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BEGIN = (- 200),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_MSG = (- 199),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__DESTROY = (- 197),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FAIL = (- 196),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TRANSPORT = (- 195),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RESOLVE = (- 193),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FS = (- 189),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__SSL = (- 181),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__CONFLICT = (- 173),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__STATE = (- 172),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__OUTDATED = (- 167),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INTR = (- 163),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PARTIAL = (- 158),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__READ_ONLY = (- 157),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOENT = (- 156),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__RETRY = (- 153),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FATAL = (- 150),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__FENCED = (- 144),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__APPLICATION = (- 143),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__NOOP = (- 141),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140),</span>
<span class="s1">  RD_KAFKA_RESP_ERR__END = (- 100),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN = (- 1),</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_ERROR = 0,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG = 2,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,</span>
<span class="s1">  RD_KAFKA_RESP_ERR_END_ALL,</span>
<span class="s1">} rd_kafka_resp_err_t;</span>
<span class="s1">struct rd_kafka_err_desc {</span>
<span class="s1">  rd_kafka_resp_err_t code;</span>
<span class="s1">  char *name;</span>
<span class="s1">  char *desc;</span>
<span class="s1">};</span>
<span class="s1">void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp);</span>
<span class="s1">const char *rd_kafka_err2str(rd_kafka_resp_err_t err);</span>
<span class="s1">const char *rd_kafka_err2name(rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_last_error(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_errno2err(int errnox);</span>
<span class="s1">int rd_kafka_errno(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_name(const rd_kafka_error_t *error);</span>
<span class="s1">const char *rd_kafka_error_string(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_fatal(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_is_retriable(const rd_kafka_error_t *error);</span>
<span class="s1">int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error);</span>
<span class="s1">void rd_kafka_error_destroy(rd_kafka_error_t *error);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_s {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *metadata;</span>
<span class="s1">  size_t metadata_size;</span>
<span class="s1">  void *opaque;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_topic_partition_t;</span>
<span class="s1">void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar);</span>
<span class="s1">typedef struct rd_kafka_topic_partition_list_s {</span>
<span class="s1">  int cnt;</span>
<span class="s1">  int size;</span>
<span class="s1">  rd_kafka_topic_partition_t *elems;</span>
<span class="s1">} rd_kafka_topic_partition_list_t;</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size);</span>
<span class="s1">void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop);</span>
<span class="s1">int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition);</span>
<span class="s1">void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque);</span>
<span class="s1">typedef enum rd_kafka_vtype_t {</span>
<span class="s1">  RD_KAFKA_VTYPE_END,</span>
<span class="s1">  RD_KAFKA_VTYPE_TOPIC,</span>
<span class="s1">  RD_KAFKA_VTYPE_RKT,</span>
<span class="s1">  RD_KAFKA_VTYPE_PARTITION,</span>
<span class="s1">  RD_KAFKA_VTYPE_VALUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_KEY,</span>
<span class="s1">  RD_KAFKA_VTYPE_OPAQUE,</span>
<span class="s1">  RD_KAFKA_VTYPE_MSGFLAGS,</span>
<span class="s1">  RD_KAFKA_VTYPE_TIMESTAMP,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADER,</span>
<span class="s1">  RD_KAFKA_VTYPE_HEADERS,</span>
<span class="s1">} rd_kafka_vtype_t;</span>
<span class="s1">typedef struct rd_kafka_vu_s {</span>
<span class="s1">  rd_kafka_vtype_t vtype;</span>
<span class="s1">  union {</span>
<span class="s1">    char *cstr;</span>
<span class="s1">    rd_kafka_topic_t *rkt;</span>
<span class="s1">    int i;</span>
<span class="s1">    int32_t i32;</span>
<span class="s1">    int64_t i64;</span>
<span class="s1">    struct {</span>
<span class="s1">      void *ptr;</span>
<span class="s1">      size_t size;</span>
<span class="s1">    } mem;</span>
<span class="s1">    struct {</span>
<span class="s1">      char *name;</span>
<span class="s1">      void *val;</span>
<span class="s1">      ssize_t size;</span>
<span class="s1">    } header;</span>
<span class="s1">    rd_kafka_headers_t *headers;</span>
<span class="s1">    void *ptr;</span>
<span class="s1">    char _pad[64];</span>
<span class="s1">  } u;</span>
<span class="s1">} rd_kafka_vu_t;</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count);</span>
<span class="s1">void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs);</span>
<span class="s1">rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep);</span>
<span class="s1">typedef struct rd_kafka_message_s {</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  rd_kafka_topic_t *rkt;</span>
<span class="s1">  int32_t partition;</span>
<span class="s1">  void *payload;</span>
<span class="s1">  size_t len;</span>
<span class="s1">  void *key;</span>
<span class="s1">  size_t key_len;</span>
<span class="s1">  int64_t offset;</span>
<span class="s1">  void *_private;</span>
<span class="s1">} rd_kafka_message_t;</span>
<span class="s1">void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage);</span>
<span class="s1">const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype);</span>
<span class="s1">int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp);</span>
<span class="s1">void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs);</span>
<span class="s1">size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,</span>
<span class="s1">  RD_KAFKA_MSG_STATUS_PERSISTED = 2,</span>
<span class="s1">} rd_kafka_msg_status_t;</span>
<span class="s1">rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage);</span>
<span class="s1">typedef enum {</span>
<span class="s1">  RD_KAFKA_CONF_UNKNOWN = (- 2),</span>
<span class="s1">  RD_KAFKA_CONF_INVALID = (- 1),</span>
<span class="s1">  RD_KAFKA_CONF_OK = 0,</span>
<span class="s1">} rd_kafka_conf_res_t;</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_new(void);</span>
<span class="s1">void rd_kafka_conf_destroy(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter);</span>
<span class="s1">const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events);</span>
<span class="s1">void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque));</span>
<span class="s1">void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque));</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque));</span>
<span class="s1">typedef enum rd_kafka_cert_type_t {</span>
<span class="s1">  RD_KAFKA_CERT_PUBLIC_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_PRIVATE_KEY,</span>
<span class="s1">  RD_KAFKA_CERT_CA,</span>
<span class="s1">  RD_KAFKA_CERT__CNT,</span>
<span class="s1">} rd_kafka_cert_type_t;</span>
<span class="s1">typedef enum rd_kafka_cert_enc_t {</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PKCS12,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_DER,</span>
<span class="s1">  RD_KAFKA_CERT_ENC_PEM,</span>
<span class="s1">  RD_KAFKA_CERT_ENC__CNT,</span>
<span class="s1">} rd_kafka_cert_enc_t;</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data);</span>
<span class="s1">void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque);</span>
<span class="s1">void *rd_kafka_opaque(const rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size);</span>
<span class="s1">const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp);</span>
<span class="s1">const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp);</span>
<span class="s1">void rd_kafka_conf_dump_free(const char **arr, size_t cnt);</span>
<span class="s1">void rd_kafka_conf_properties_show(FILE *fp);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf);</span>
<span class="s1">rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf);</span>
<span class="s1">rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque);</span>
<span class="s1">void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque));</span>
<span class="s1">void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b));</span>
<span class="s1">int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque);</span>
<span class="s1">rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_destroy(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags);</span>
<span class="s1">const char *rd_kafka_name(const rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_memberid(const rd_kafka_t *rk);</span>
<span class="s1">char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf);</span>
<span class="s1">void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt);</span>
<span class="s1">const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt);</span>
<span class="s1">void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt);</span>
<span class="s1">int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">void rd_kafka_yield(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms);</span>
<span class="s1">void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size);</span>
<span class="s1">void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size);</span>
<span class="s1">void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition);</span>
<span class="s1">rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu);</span>
<span class="s1">size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu);</span>
<span class="s1">void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size);</span>
<span class="s1">void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque);</span>
<span class="s1">void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu);</span>
<span class="s1">int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size);</span>
<span class="s1">int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics);</span>
<span class="s1">rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions);</span>
<span class="s1">int rd_kafka_assignment_lost(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id);</span>
<span class="s1">rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id);</span>
<span class="s1">void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size);</span>
<span class="s1">int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt);</span>
<span class="s1">int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags);</span>
<span class="s1">typedef struct rd_kafka_metadata_broker {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  char *host;</span>
<span class="s1">  int port;</span>
<span class="s1">} rd_kafka_metadata_broker_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_partition {</span>
<span class="s1">  int32_t id;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  int32_t leader;</span>
<span class="s1">  int replica_cnt;</span>
<span class="s1">  int32_t *replicas;</span>
<span class="s1">  int isr_cnt;</span>
<span class="s1">  int32_t *isrs;</span>
<span class="s1">} rd_kafka_metadata_partition_t;</span>
<span class="s1">typedef struct rd_kafka_metadata_topic {</span>
<span class="s1">  char *topic;</span>
<span class="s1">  int partition_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_partition *partitions;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">} rd_kafka_metadata_topic_t;</span>
<span class="s1">typedef struct rd_kafka_metadata {</span>
<span class="s1">  int broker_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_broker *brokers;</span>
<span class="s1">  int topic_cnt;</span>
<span class="s1">  struct rd_kafka_metadata_topic *topics;</span>
<span class="s1">  int32_t orig_broker_id;</span>
<span class="s1">  char *orig_broker_name;</span>
<span class="s1">} rd_kafka_metadata_t;</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms);</span>
<span class="s1">void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata);</span>
<span class="s1">struct rd_kafka_group_member_info {</span>
<span class="s1">  char *member_id;</span>
<span class="s1">  char *client_id;</span>
<span class="s1">  char *client_host;</span>
<span class="s1">  void *member_metadata;</span>
<span class="s1">  int member_metadata_size;</span>
<span class="s1">  void *member_assignment;</span>
<span class="s1">  int member_assignment_size;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_info {</span>
<span class="s1">  struct rd_kafka_metadata_broker broker;</span>
<span class="s1">  char *group;</span>
<span class="s1">  rd_kafka_resp_err_t err;</span>
<span class="s1">  char *state;</span>
<span class="s1">  char *protocol_type;</span>
<span class="s1">  char *protocol;</span>
<span class="s1">  struct rd_kafka_group_member_info *members;</span>
<span class="s1">  int member_cnt;</span>
<span class="s1">};</span>
<span class="s1">struct rd_kafka_group_list {</span>
<span class="s1">  struct rd_kafka_group_info *groups;</span>
<span class="s1">  int group_cnt;</span>
<span class="s1">};</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms);</span>
<span class="s1">void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist);</span>
<span class="s1">int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist);</span>
<span class="s1">void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf));</span>
<span class="s1">void rd_kafka_set_log_level(rd_kafka_t *rk, int level);</span>
<span class="s1">void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf);</span>
<span class="s1">int rd_kafka_outq_len(rd_kafka_t *rk);</span>
<span class="s1">void rd_kafka_dump(FILE *fp, rd_kafka_t *rk);</span>
<span class="s1">int rd_kafka_thread_cnt(void);</span>
<span class="s1">typedef enum rd_kafka_thread_type_t {</span>
<span class="s1">  RD_KAFKA_THREAD_MAIN,</span>
<span class="s1">  RD_KAFKA_THREAD_BACKGROUND,</span>
<span class="s1">  RD_KAFKA_THREAD_BROKER,</span>
<span class="s1">} rd_kafka_thread_type_t;</span>
<span class="s1">int rd_kafka_wait_destroyed(int timeout_ms);</span>
<span class="s1">int rd_kafka_unittest(void);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk);</span>
<span class="s1">typedef int rd_kafka_event_type_t;</span>
<span class="s1">rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_name(const rd_kafka_event_t *rkev);</span>
<span class="s1">void rd_kafka_event_destroy(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev);</span>
<span class="s1">size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size);</span>
<span class="s1">size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev);</span>
<span class="s1">const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev);</span>
<span class="s1">void *rd_kafka_event_opaque(rd_kafka_event_t *rkev);</span>
<span class="s1">int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level);</span>
<span class="s1">int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize);</span>
<span class="s1">const char *rd_kafka_event_stats(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev);</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t;</span>
<span class="s1">typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t;</span>
<span class="s1">const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev);</span>
<span class="s1">const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev);</span>
<span class="s1">rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres);</span>
<span class="s1">const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres);</span>
<span class="s1">typedef enum rd_kafka_admin_op_t {</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ANY = 0,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETETOPICS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_CREATEPARTITIONS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_ALTERCONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETERECORDS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETEGROUPS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS,</span>
<span class="s1">  RD_KAFKA_ADMIN_OP__CNT,</span>
<span class="s1">} rd_kafka_admin_op_t;</span>
<span class="s1">typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t;</span>
<span class="s1">rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api);</span>
<span class="s1">void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque);</span>
<span class="s1">typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t;</span>
<span class="s1">rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic);</span>
<span class="s1">void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value);</span>
<span class="s1">void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t;</span>
<span class="s1">rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic);</span>
<span class="s1">void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt);</span>
<span class="s1">void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t;</span>
<span class="s1">rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts);</span>
<span class="s1">void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size);</span>
<span class="s1">void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ConfigSource_t {</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,</span>
<span class="s1">  RD_KAFKA_CONFIG_SOURCE__CNT,</span>
<span class="s1">} rd_kafka_ConfigSource_t;</span>
<span class="s1">const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource);</span>
<span class="s1">typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t;</span>
<span class="s1">const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp);</span>
<span class="s1">typedef enum rd_kafka_ResourceType_t {</span>
<span class="s1">  RD_KAFKA_RESOURCE_UNKNOWN = 0,</span>
<span class="s1">  RD_KAFKA_RESOURCE_ANY = 1,</span>
<span class="s1">  RD_KAFKA_RESOURCE_TOPIC = 2,</span>
<span class="s1">  RD_KAFKA_RESOURCE_GROUP = 3,</span>
<span class="s1">  RD_KAFKA_RESOURCE_BROKER = 4,</span>
<span class="s1">  RD_KAFKA_RESOURCE__CNT,</span>
<span class="s1">} rd_kafka_ResourceType_t;</span>
<span class="s1">const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype);</span>
<span class="s1">typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t;</span>
<span class="s1">rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value);</span>
<span class="s1">const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp);</span>
<span class="s1">rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config);</span>
<span class="s1">void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t;</span>
<span class="s1">rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records);</span>
<span class="s1">void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt);</span>
<span class="s1">void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result);</span>
<span class="s1">typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t;</span>
<span class="s1">rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group);</span>
<span class="s1">void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt);</span>
<span class="s1">void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp);</span>
<span class="s1">typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t;</span>
<span class="s1">rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt);</span>
<span class="s1">void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu);</span>
<span class="s1">const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms);</span>
<span class="s1">typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t;</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt);</span>
<span class="s1">void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk);</span>
<span class="s1">const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster);</span>
<span class="s1">void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey);</span>
<span class="s1">void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...);</span>
<span class="s1">void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id);</span>
<span class="s1">rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion);</span>
<span class="s1">&#39;</span>
</code></pre></div>
rdkafka.h, rdkafka_mock.h</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../RdKafka/" class="md-footer__link md-footer__link--prev" aria-label="Previous: RdKafka" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              RdKafka
            </div>
          </div>
        </a>
      
      
        
        <a href="../functions/" class="md-footer__link md-footer__link--next" aria-label="Next: Functions" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Functions
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; idealo internet GmbH.
          </div>
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.8397ff9e.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.1e84347e.min.js"></script>
      
    
  </body>
</html>