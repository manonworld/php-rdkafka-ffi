{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHP Kafka Client \u00b6 This is a Kafka client library for PHP ^7.4 with a slim librdkafka binding via FFI . It supports the same interfaces as the PHP RdKafka extension ^4.0 and ^5.0. Supported Features \u00b6 Consumer (low and high level) Producer (with support for transactional producing) Admin Client Mock Cluster to simplify integration tests (even with error situations) Support for error handling and logging via callbacks Runtime Requirements \u00b6 PHP ^7.4 or ^8.0 with extensions FFI enabled librdkafka ^1.0.0 Conflicts: RdKafka extension Suggested: zend opcache extension for preloading pcntl extension for faster shutdown in request/response context Note: Support for macOS and Windows is currently experimental. Installation \u00b6 composer require idealo/php-rdkafka-ffi Note: Expect breaking changes along all 0.* pre-releases. This changes may depend on upcoming major releases of the RdKafka extension or improved interfaces for the experimental features like transactional producer, mock cluster and admin client. Documentation \u00b6 https://idealo.github.io/php-rdkafka-ffi/ Contributing \u00b6 We welcome all kinds of contributions. See the Contribution guide for more details. License \u00b6 See License for details.","title":"Getting started"},{"location":"#php-kafka-client","text":"This is a Kafka client library for PHP ^7.4 with a slim librdkafka binding via FFI . It supports the same interfaces as the PHP RdKafka extension ^4.0 and ^5.0.","title":" PHP Kafka Client"},{"location":"#supported-features","text":"Consumer (low and high level) Producer (with support for transactional producing) Admin Client Mock Cluster to simplify integration tests (even with error situations) Support for error handling and logging via callbacks","title":"Supported Features"},{"location":"#runtime-requirements","text":"PHP ^7.4 or ^8.0 with extensions FFI enabled librdkafka ^1.0.0 Conflicts: RdKafka extension Suggested: zend opcache extension for preloading pcntl extension for faster shutdown in request/response context Note: Support for macOS and Windows is currently experimental.","title":"Runtime Requirements"},{"location":"#installation","text":"composer require idealo/php-rdkafka-ffi Note: Expect breaking changes along all 0.* pre-releases. This changes may depend on upcoming major releases of the RdKafka extension or improved interfaces for the experimental features like transactional producer, mock cluster and admin client.","title":"Installation"},{"location":"#documentation","text":"https://idealo.github.io/php-rdkafka-ffi/","title":"Documentation"},{"location":"#contributing","text":"We welcome all kinds of contributions. See the Contribution guide for more details.","title":"Contributing"},{"location":"#license","text":"See License for details.","title":"License"},{"location":"benchmarks/","text":"Benchmarks \u00b6 These benchmarks were run with version 0.4.0. Note Please note that these benchmarks depend on asynchronous responses/requests to a Kafka broker. Suites \u00b6 All suites use librdkafka v1.8.2. Tag PHP PHP Config phpbench Config php74_ffi 7.4.25 opcache ffi.json php74_ffi_preload 7.4.25 opcache preload ffi_preload.json php74_ext 7.4.25 RdKafka Extension v4.1.2 opcache ext.json php80_ffi 8.0.12 opcache ffi.json php80_ffi_preload 8.0.12 opcache preload ffi_preload.json php80_ffi_preload_jit 8.0.12 opcache preload jit ffi_preload_jit.json php80_ext 8.0.12 RdKafka Extension v5.0.0 opcache ext.json Runtime Average FFI <> Extension \u00b6 Raw reports & env data \u00b6 See https://github.com/idealo/php-rdkafka-ffi/tree/main/benchmarks/reports Setup \u00b6 Hetzner CCX21 Cloud Server (dedicated 4 vCPU, 16 GB Ram, NVMe SSD) Ubuntu 20.04 docker ce 20.10.9 docker-compose with images for php 7.4 / 8.0 and librdkafka 1.8.2 installed see https://github.com/idealo/php-rdkafka-ffi/blob/main/docker-compose.yml see https://github.com/idealo/php-rdkafka-ffi/tree/main/resources/docker Run benchmarks \u00b6 See running benchmarks in try out . There are ansible playbooks in resources to setup and run benchmarks.","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"These benchmarks were run with version 0.4.0. Note Please note that these benchmarks depend on asynchronous responses/requests to a Kafka broker.","title":"Benchmarks"},{"location":"benchmarks/#suites","text":"All suites use librdkafka v1.8.2. Tag PHP PHP Config phpbench Config php74_ffi 7.4.25 opcache ffi.json php74_ffi_preload 7.4.25 opcache preload ffi_preload.json php74_ext 7.4.25 RdKafka Extension v4.1.2 opcache ext.json php80_ffi 8.0.12 opcache ffi.json php80_ffi_preload 8.0.12 opcache preload ffi_preload.json php80_ffi_preload_jit 8.0.12 opcache preload jit ffi_preload_jit.json php80_ext 8.0.12 RdKafka Extension v5.0.0 opcache ext.json","title":"Suites"},{"location":"benchmarks/#runtime-average-ffi-extension","text":"","title":"Runtime Average FFI &lt;&gt; Extension"},{"location":"benchmarks/#raw-reports-env-data","text":"See https://github.com/idealo/php-rdkafka-ffi/tree/main/benchmarks/reports","title":"Raw reports &amp; env data"},{"location":"benchmarks/#setup","text":"Hetzner CCX21 Cloud Server (dedicated 4 vCPU, 16 GB Ram, NVMe SSD) Ubuntu 20.04 docker ce 20.10.9 docker-compose with images for php 7.4 / 8.0 and librdkafka 1.8.2 installed see https://github.com/idealo/php-rdkafka-ffi/blob/main/docker-compose.yml see https://github.com/idealo/php-rdkafka-ffi/tree/main/resources/docker","title":"Setup"},{"location":"benchmarks/#run-benchmarks","text":"See running benchmarks in try out . There are ansible playbooks in resources to setup and run benchmarks.","title":"Run benchmarks"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project are documented in this file using the Keep a CHANGELOG principles. This project adheres to Semantic Versioning . Unreleased \u00b6 0.4.0 \u00b6 This pre-release improves compatible with the PHP RdKafka extension ^4.0 and ^5.0. Added \u00b6 Add pausePartitions/resumePartitions to Producer/ KafkaConsumer Add deleteRecords, deleteConsumerGroupOffsets and deleteGroups to Admin Client Add support for librdkafka v1.6.0, v1.6.1, v1.7.0, v1.8.0, v1.8.2 Changed \u00b6 Rename Message::_private to ::opaque Mark consumeCallback in ConsumerTopic as deprecated (it is deprecated in librdkafka since v1.4.0) Fixed \u00b6 Fix headers param in ProducerTopic::producev does not accept null 0.3.0 - 2020-12-16 \u00b6 Added \u00b6 Add support for rd_kafka_err2name Add opaque reference handling in Configs & Callbacks, produce & Message 0.2.0 - 2020-12-09 \u00b6 This pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.3. It is compatible with the PHP RdKafka extension ^4.0. Note: Transactional Producer is no longer marked as experimental. Fixed \u00b6 Fix empty TopicPartition metadata handling Added \u00b6 Add TopicPartition::getMetadataSize() Add support for librdkafka v1.5.3 Changed \u00b6 Rename KafkaError to KafkaErrorException and change its interface for rdkafka extension compatibility with v4.1.* Suggests pcntl extension (instead of requires) 0.1.0 - 2020-12-06 \u00b6 This first pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.2. It is compatible with the PHP RdKafka extension 4.0.*. Note: features marked as experimental are stable, but the interface may change in future releases. Special thanks to @siad007 and @carusogabriel for early fixes and tweaks. Added \u00b6 Add Consumer (low and high level) Add Producer (with support for experimental transactional producing) Add Admin Client (experimental) Add Mock Cluster to simplify integration tests (experimental) Add FFI binding for librdkafka 1.0.0 - 1.5.2 Add examples and basic documentation Add benchmarks","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project are documented in this file using the Keep a CHANGELOG principles. This project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#040","text":"This pre-release improves compatible with the PHP RdKafka extension ^4.0 and ^5.0.","title":"0.4.0"},{"location":"changelog/#added","text":"Add pausePartitions/resumePartitions to Producer/ KafkaConsumer Add deleteRecords, deleteConsumerGroupOffsets and deleteGroups to Admin Client Add support for librdkafka v1.6.0, v1.6.1, v1.7.0, v1.8.0, v1.8.2","title":"Added"},{"location":"changelog/#changed","text":"Rename Message::_private to ::opaque Mark consumeCallback in ConsumerTopic as deprecated (it is deprecated in librdkafka since v1.4.0)","title":"Changed"},{"location":"changelog/#fixed","text":"Fix headers param in ProducerTopic::producev does not accept null","title":"Fixed"},{"location":"changelog/#030-2020-12-16","text":"","title":"0.3.0 - 2020-12-16"},{"location":"changelog/#added_1","text":"Add support for rd_kafka_err2name Add opaque reference handling in Configs & Callbacks, produce & Message","title":"Added"},{"location":"changelog/#020-2020-12-09","text":"This pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.3. It is compatible with the PHP RdKafka extension ^4.0. Note: Transactional Producer is no longer marked as experimental.","title":"0.2.0 - 2020-12-09"},{"location":"changelog/#fixed_1","text":"Fix empty TopicPartition metadata handling","title":"Fixed"},{"location":"changelog/#added_2","text":"Add TopicPartition::getMetadataSize() Add support for librdkafka v1.5.3","title":"Added"},{"location":"changelog/#changed_1","text":"Rename KafkaError to KafkaErrorException and change its interface for rdkafka extension compatibility with v4.1.* Suggests pcntl extension (instead of requires)","title":"Changed"},{"location":"changelog/#010-2020-12-06","text":"This first pre-release supports PHP ^7.4 and ^8.0 and librdkafka v1.0.0 - v1.5.2. It is compatible with the PHP RdKafka extension 4.0.*. Note: features marked as experimental are stable, but the interface may change in future releases. Special thanks to @siad007 and @carusogabriel for early fixes and tweaks.","title":"0.1.0 - 2020-12-06"},{"location":"changelog/#added_3","text":"Add Consumer (low and high level) Add Producer (with support for experimental transactional producing) Add Admin Client (experimental) Add Mock Cluster to simplify integration tests (experimental) Add FFI binding for librdkafka 1.0.0 - 1.5.2 Add examples and basic documentation Add benchmarks","title":"Added"},{"location":"contributing/","text":"Contributing \u00b6 We welcome any contributions whether it\u2019s, Submitting feedback Fixing bugs Or implementing a new feature. Please read this guide before making any contributions. Submit Feedback \u00b6 The feedback should be submitted by creating an issue at GitHub issues . Fix Bugs \u00b6 You may look through the GitHub issues for bugs. Implement Features \u00b6 You may look through the GitHub issues for feature requests. Pull Requests (PR) \u00b6 Fork the repository and create a new branch from the master branch. For bug fixes, add new tests and for new features please add changes to the documentation. Do a PR from your new branch to our main branch of the original idealo/php-rdkafka-ffi repo. Code Style \u00b6 Make sure any new code you introduce has proper code styling according to PRS-12 . You should run composer cs-fix before a PR. Documentation \u00b6 Make sure any new code you introduce has proper phpdoc. You may add extra usage documentation under /docs/usage See work on the documentation locally. Testing \u00b6 Make sure to write tests for any new feature and/or bug fixes. We use phpunit for our testing. See run tests locally. Main Contributor List \u00b6 We maintain a list of main contributors to appreciate all the contributions.","title":"Contributing"},{"location":"contributing/#contributing","text":"We welcome any contributions whether it\u2019s, Submitting feedback Fixing bugs Or implementing a new feature. Please read this guide before making any contributions.","title":"Contributing"},{"location":"contributing/#submit-feedback","text":"The feedback should be submitted by creating an issue at GitHub issues .","title":"Submit Feedback"},{"location":"contributing/#fix-bugs","text":"You may look through the GitHub issues for bugs.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"You may look through the GitHub issues for feature requests.","title":"Implement Features"},{"location":"contributing/#pull-requests-pr","text":"Fork the repository and create a new branch from the master branch. For bug fixes, add new tests and for new features please add changes to the documentation. Do a PR from your new branch to our main branch of the original idealo/php-rdkafka-ffi repo.","title":"Pull Requests (PR)"},{"location":"contributing/#code-style","text":"Make sure any new code you introduce has proper code styling according to PRS-12 . You should run composer cs-fix before a PR.","title":"Code Style"},{"location":"contributing/#documentation","text":"Make sure any new code you introduce has proper phpdoc. You may add extra usage documentation under /docs/usage See work on the documentation locally.","title":"Documentation"},{"location":"contributing/#testing","text":"Make sure to write tests for any new feature and/or bug fixes. We use phpunit for our testing. See run tests locally.","title":"Testing"},{"location":"contributing/#main-contributor-list","text":"We maintain a list of main contributors to appreciate all the contributions.","title":"Main Contributor List"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License. \u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS Copyright 2019 idealo internet GmbH Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"try-out/","text":"Try out \u00b6 Checkout this repo and have some fun playing around with: FFI extension librdkafka ^1.0 ( docs ) PHP ^7.4 and PHP ^8.0 Confluent Kafka / Zookeeper docker images phpbench lib for benchmarking Directory overview \u00b6 /benchmarks - phpbench based benchmark tests /docs - docs dir (markdown) /examples - example scripts /resources /benchmarks ansible playbooks setup and run benchmarks /docker /php74-librdkafka-ffi - dockerfile for PHP 7.4 image with librdkafka and ffi & rdkafka ext (based on php:7.4-cli ) /php80-librdkafka-ffi - dockerfile for PHP 8.0 image with librdkafka and ffi & rdkafka ext (based on php:8.0-rc-cli ) /docs - scripts to build documentation site from /docs /ffigen - rebuild stuff low level library bindings /phpunit - bootstrap and config for phpunit tests /test-extension - base dir for rdkafka ext compatibility tests /src - source dir /tests - tests dir Build images \u00b6 Build all images docker-compose build --no-cache --pull Alternative: build the image individually docker-compose build --no-cache --pull php74 php80 Alternative: build the image individually and set optional build args (LIBRDKAFKA_VERSION default = v1.5.3, RDKAFKA_EXT_VERSION default = 4.1.x for php74 / 5.x for php80) docker-compose build --no-cache --pull --build-arg LIBRDKAFKA_VERSION=\"v1.5.3\" --build-arg RDKAFKA_EXT_VERSION=\"4.1.1\" php74 Test - should show latest 7.4 version docker-compose run php74 php -v Test - should show FFI in modules list docker-compose run php74 php -m Test ffi librdkafka binding - should show current version of librdkafka: docker-compose run php74 php examples/version.php Test - should show rdkafka in modules list docker-compose run php74 php -dextension=rdkafka.so -m Startup \u00b6 Startup php & kafka docker-compose up -d Updating dependencies docker-compose run --rm --no-deps php74 composer update Having fun with examples \u00b6 Examples use topic playground . Init playground topic docker-compose run --rm php74 composer examples-init Updating Dependencies docker-compose run --rm --no-deps php74 composer update Create topic playground \u2026 docker-compose run --rm php74 php examples/create-topic.php -tplayground -p3 -r1 Producing \u2026 docker-compose run --rm php74 php examples/producer.php Consuming (with low level consumer) \u2026 docker-compose run --rm php74 php examples/consumer.php Consuming (with high level consumer) \u2026 docker-compose run --rm -T php74 php examples/consumer-highlevel.php Broker metadata \u2026 docker-compose run --rm php74 php examples/metadata.php Describe config values for a topic \u2026 docker-compose run --rm php74 php examples/describe-config.php docker-compose run --rm php74 php examples/describe-config.php -t2 -vtest Describe config values for a broker \u2026 docker-compose run --rm php74 php examples/describe-config.php -t4 -v111 Test preload (shows current librdkafka version & opcache status) docker-compose run --rm php80 php \\ -dffi.enable=preload \\ -dzend_extension=opcache \\ -dopcache.enable=true \\ -dopcache.enable_cli=true \\ -dopcache.preload_user=phpdev \\ -dopcache.preload=/app/examples/preload.php \\ examples/test-preload.php Test preload with jit (shows current librdkafka version & opcache status) docker-compose run --rm php80 php \\ -dffi.enable=preload \\ -dzend_extension=opcache \\ -dopcache.enable=true \\ -dopcache.enable_cli=true \\ -dopcache.preload_user=phpdev \\ -dopcache.preload=/app/examples/preload.php \\ -dopcache.jit_buffer_size=100M \\ -dopcache.jit=function \\ examples/test-preload.php Experimental ! Test mock cluster (producing and consuming) - requires librdkafka ^1.3.0 docker-compose run --rm php74 php examples/mock-cluster.php Experimental ! Read consumer offset lags docker-compose run --rm php74 php examples/offset-lags.php Delete topic playground \u2026 docker-compose run --rm php74 php examples/delete-topic.php -tplayground Run tests \u00b6 Tests use topics test* . Updating Dependencies docker-compose run --rm --no-deps php74 composer update Run tests docker-compose run --rm php74 composer test-init docker-compose run --rm php74 composer test Run tests with coverage docker-compose run --rm php74 composer test-coverage Run tests against RdKafka extension / PHP 7.4 \u00b6 Updating Dependencies docker-compose run --rm --no-deps php74 composer update -d /app/resources/test-extension --ignore-platform-reqs Run tests docker-compose run --rm php74 composer test-extension-init docker-compose run --rm php74 composer test-extension Run tests against RdKafka extension / PHP 8.0 \u00b6 Updating Dependencies docker-compose run --rm --no-deps php80 composer update -d /app/resources/test-extension --ignore-platform-reqs Run tests docker-compose run --rm php80 composer test-extension-init docker-compose run --rm php80 composer test-extension Run benchmarks \u00b6 Benchmarks use topic benchmarks . Run Benchmarks docker-compose down -v; \\ docker-compose up -d kafka; \\ docker-compose exec kafka cub kafka-ready -z zookeeper:2181 1 20; \\ docker-compose run --rm php74 composer benchmarks-init; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php74_ffi --group=ffi; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php74_ffi_preload --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php80_ffi --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php80_ffi_preload --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_jit.json --report=default --store --tag=php80_ffi_preload_jit --group=ffi; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php74_ext --group=ext; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php80_ext --group=ext Show comparison for runtime average docker-compose run --rm php74 vendor/bin/phpbench report \\ --ref=php74_ffi \\ --ref=php74_ffi_preload \\ --ref=php80_ffi \\ --ref=php80_ffi_preload \\ --ref=php80_ffi_preload_jit \\ --ref=php74_ext \\ --ref=php80_ext \\ --report=summary \\ --config=benchmarks\\report.json Run Api::init benchmark (fix vs auto detected version) docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --group=Api Work on the documentation \u00b6 Documentation is based on markdown and the static site is build with mkdocs material . The API documentation is generated by dog as markdown. Serve documentation on http://localhost:8000/ docker-compose run --rm php74 composer prepare-docs docker-compose up mkdocs Build static site in folder site docker-compose run --rm php74 composer prepare-docs docker-compose run --rm mkdocs build","title":"Try out"},{"location":"try-out/#try-out","text":"Checkout this repo and have some fun playing around with: FFI extension librdkafka ^1.0 ( docs ) PHP ^7.4 and PHP ^8.0 Confluent Kafka / Zookeeper docker images phpbench lib for benchmarking","title":"Try out"},{"location":"try-out/#directory-overview","text":"/benchmarks - phpbench based benchmark tests /docs - docs dir (markdown) /examples - example scripts /resources /benchmarks ansible playbooks setup and run benchmarks /docker /php74-librdkafka-ffi - dockerfile for PHP 7.4 image with librdkafka and ffi & rdkafka ext (based on php:7.4-cli ) /php80-librdkafka-ffi - dockerfile for PHP 8.0 image with librdkafka and ffi & rdkafka ext (based on php:8.0-rc-cli ) /docs - scripts to build documentation site from /docs /ffigen - rebuild stuff low level library bindings /phpunit - bootstrap and config for phpunit tests /test-extension - base dir for rdkafka ext compatibility tests /src - source dir /tests - tests dir","title":"Directory overview"},{"location":"try-out/#build-images","text":"Build all images docker-compose build --no-cache --pull Alternative: build the image individually docker-compose build --no-cache --pull php74 php80 Alternative: build the image individually and set optional build args (LIBRDKAFKA_VERSION default = v1.5.3, RDKAFKA_EXT_VERSION default = 4.1.x for php74 / 5.x for php80) docker-compose build --no-cache --pull --build-arg LIBRDKAFKA_VERSION=\"v1.5.3\" --build-arg RDKAFKA_EXT_VERSION=\"4.1.1\" php74 Test - should show latest 7.4 version docker-compose run php74 php -v Test - should show FFI in modules list docker-compose run php74 php -m Test ffi librdkafka binding - should show current version of librdkafka: docker-compose run php74 php examples/version.php Test - should show rdkafka in modules list docker-compose run php74 php -dextension=rdkafka.so -m","title":"Build images"},{"location":"try-out/#startup","text":"Startup php & kafka docker-compose up -d Updating dependencies docker-compose run --rm --no-deps php74 composer update","title":"Startup"},{"location":"try-out/#having-fun-with-examples","text":"Examples use topic playground . Init playground topic docker-compose run --rm php74 composer examples-init Updating Dependencies docker-compose run --rm --no-deps php74 composer update Create topic playground \u2026 docker-compose run --rm php74 php examples/create-topic.php -tplayground -p3 -r1 Producing \u2026 docker-compose run --rm php74 php examples/producer.php Consuming (with low level consumer) \u2026 docker-compose run --rm php74 php examples/consumer.php Consuming (with high level consumer) \u2026 docker-compose run --rm -T php74 php examples/consumer-highlevel.php Broker metadata \u2026 docker-compose run --rm php74 php examples/metadata.php Describe config values for a topic \u2026 docker-compose run --rm php74 php examples/describe-config.php docker-compose run --rm php74 php examples/describe-config.php -t2 -vtest Describe config values for a broker \u2026 docker-compose run --rm php74 php examples/describe-config.php -t4 -v111 Test preload (shows current librdkafka version & opcache status) docker-compose run --rm php80 php \\ -dffi.enable=preload \\ -dzend_extension=opcache \\ -dopcache.enable=true \\ -dopcache.enable_cli=true \\ -dopcache.preload_user=phpdev \\ -dopcache.preload=/app/examples/preload.php \\ examples/test-preload.php Test preload with jit (shows current librdkafka version & opcache status) docker-compose run --rm php80 php \\ -dffi.enable=preload \\ -dzend_extension=opcache \\ -dopcache.enable=true \\ -dopcache.enable_cli=true \\ -dopcache.preload_user=phpdev \\ -dopcache.preload=/app/examples/preload.php \\ -dopcache.jit_buffer_size=100M \\ -dopcache.jit=function \\ examples/test-preload.php Experimental ! Test mock cluster (producing and consuming) - requires librdkafka ^1.3.0 docker-compose run --rm php74 php examples/mock-cluster.php Experimental ! Read consumer offset lags docker-compose run --rm php74 php examples/offset-lags.php Delete topic playground \u2026 docker-compose run --rm php74 php examples/delete-topic.php -tplayground","title":"Having fun with examples"},{"location":"try-out/#run-tests","text":"Tests use topics test* . Updating Dependencies docker-compose run --rm --no-deps php74 composer update Run tests docker-compose run --rm php74 composer test-init docker-compose run --rm php74 composer test Run tests with coverage docker-compose run --rm php74 composer test-coverage","title":"Run tests"},{"location":"try-out/#run-tests-against-rdkafka-extension-php-74","text":"Updating Dependencies docker-compose run --rm --no-deps php74 composer update -d /app/resources/test-extension --ignore-platform-reqs Run tests docker-compose run --rm php74 composer test-extension-init docker-compose run --rm php74 composer test-extension","title":"Run tests against RdKafka extension / PHP 7.4"},{"location":"try-out/#run-tests-against-rdkafka-extension-php-80","text":"Updating Dependencies docker-compose run --rm --no-deps php80 composer update -d /app/resources/test-extension --ignore-platform-reqs Run tests docker-compose run --rm php80 composer test-extension-init docker-compose run --rm php80 composer test-extension","title":"Run tests against RdKafka extension / PHP 8.0"},{"location":"try-out/#run-benchmarks","text":"Benchmarks use topic benchmarks . Run Benchmarks docker-compose down -v; \\ docker-compose up -d kafka; \\ docker-compose exec kafka cub kafka-ready -z zookeeper:2181 1 20; \\ docker-compose run --rm php74 composer benchmarks-init; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php74_ffi --group=ffi; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php74_ffi_preload --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --store --tag=php80_ffi --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_preload.json --report=default --store --tag=php80_ffi_preload --group=ffi; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi_jit.json --report=default --store --tag=php80_ffi_preload_jit --group=ffi; \\ docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php74_ext --group=ext; \\ docker-compose run --rm php80 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ext.json --report=default --store --tag=php80_ext --group=ext Show comparison for runtime average docker-compose run --rm php74 vendor/bin/phpbench report \\ --ref=php74_ffi \\ --ref=php74_ffi_preload \\ --ref=php80_ffi \\ --ref=php80_ffi_preload \\ --ref=php80_ffi_preload_jit \\ --ref=php74_ext \\ --ref=php80_ext \\ --report=summary \\ --config=benchmarks\\report.json Run Api::init benchmark (fix vs auto detected version) docker-compose run --rm php74 vendor/bin/phpbench run benchmarks --config=/app/benchmarks/ffi.json --report=default --group=Api","title":"Run benchmarks"},{"location":"try-out/#work-on-the-documentation","text":"Documentation is based on markdown and the static site is build with mkdocs material . The API documentation is generated by dog as markdown. Serve documentation on http://localhost:8000/ docker-compose run --rm php74 composer prepare-docs docker-compose up mkdocs Build static site in folder site docker-compose run --rm php74 composer prepare-docs docker-compose run --rm mkdocs build","title":"Work on the documentation"},{"location":"api/","text":"Overview \u00b6 Traits \u00b6 \\RdKafka\\FFI\\Methods \ud83e\udd0d Classes \u00b6 \\RdKafka \ud83d\udc9b \\RdKafka\\Admin\\AlterConfigsOptions \ud83d\udc9a \\RdKafka\\Admin\\Client \ud83d\udc9b \\RdKafka\\Admin\\ConfigEntry \ud83d\udc9a \\RdKafka\\Admin\\ConfigResource \ud83d\udc9a \\RdKafka\\Admin\\ConfigResourceResult \ud83d\udc9a \\RdKafka\\Admin\\CreatePartitionsOptions \ud83d\udc9a \\RdKafka\\Admin\\CreateTopicsOptions \ud83d\udc9a \\RdKafka\\Admin\\DeleteConsumerGroupOffsets \u2764\ufe0f \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions \u2764\ufe0f \\RdKafka\\Admin\\DeleteGroup \u2764\ufe0f \\RdKafka\\Admin\\DeleteGroupsOptions \u2764\ufe0f \\RdKafka\\Admin\\DeleteRecords \ud83d\udc9b \\RdKafka\\Admin\\DeleteRecordsOptions \ud83d\udc9a \\RdKafka\\Admin\\DeleteTopic \ud83e\udde1 \\RdKafka\\Admin\\DeleteTopicsOptions \ud83d\udc9a \\RdKafka\\Admin\\DescribeConfigsOptions \ud83d\udc9a \\RdKafka\\Admin\\GroupResult \u2764\ufe0f \\RdKafka\\Admin\\NewPartitions \ud83d\udc9a \\RdKafka\\Admin\\NewTopic \ud83d\udc9b \\RdKafka\\Admin\\Options \ud83d\udc9a \\RdKafka\\Admin\\TopicResult \ud83d\udc9a \\RdKafka\\Conf \ud83d\udc9a \\RdKafka\\Consumer \ud83d\udc9a \\RdKafka\\ConsumerTopic \ud83d\udc9b \\RdKafka\\Event \ud83d\udc9a \\RdKafka\\Exception \ud83d\udc9a \\RdKafka\\FFI\\CallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\ConsumeCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\DrMsgCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\ErrorCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\Library \ud83d\udc9b \\RdKafka\\FFI\\LogCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\NativePartitionerCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\OffsetCommitCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\OpaqueMap \ud83d\udc9a \\RdKafka\\FFI\\PartitionerCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\RebalanceCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\StatsCallbackProxy \ud83d\udc9a \\RdKafka\\KafkaConsumer \ud83d\udc9b \\RdKafka\\KafkaConsumerTopic \ud83d\udc9a \\RdKafka\\KafkaErrorException \ud83d\udc9a \\RdKafka\\Message \ud83d\udc9b \\RdKafka\\Metadata \ud83d\udc9a \\RdKafka\\Metadata\\Broker \ud83d\udc9a \\RdKafka\\Metadata\\Collection \ud83d\udc9a \\RdKafka\\Metadata\\Partition \ud83d\udc9a \\RdKafka\\Metadata\\Topic \ud83d\udc9a \\RdKafka\\Producer \ud83d\udc9b \\RdKafka\\ProducerTopic \ud83d\udc9b \\RdKafka\\Queue \ud83d\udc9b \\RdKafka\\Test\\ApiKey \u2764\ufe0f \\RdKafka\\Test\\MockCluster \ud83e\udde1 \\RdKafka\\Topic \ud83d\udc9b \\RdKafka\\TopicConf \ud83d\udc9b \\RdKafka\\TopicPartition \ud83d\udc9a \\RdKafka\\TopicPartitionList \ud83d\udc9a Functions \u00b6 \\rd_kafka_err2name() \\rd_kafka_err2str() \\rd_kafka_errno() \\rd_kafka_errno2err() \\rd_kafka_offset_tail() \\rd_kafka_thread_cnt() \\rd_kafka_version() Constants \u00b6 \\RD_KAFKA_ADMIN_OP_ALTERCONFIGS \\RD_KAFKA_ADMIN_OP_ANY \\RD_KAFKA_ADMIN_OP_CREATEPARTITIONS \\RD_KAFKA_ADMIN_OP_CREATETOPICS \\RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS \\RD_KAFKA_ADMIN_OP_DELETEGROUPS \\RD_KAFKA_ADMIN_OP_DELETERECORDS \\RD_KAFKA_ADMIN_OP_DELETETOPICS \\RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CERT_CA \\RD_KAFKA_CERT_ENC_DER \\RD_KAFKA_CERT_ENC_PEM \\RD_KAFKA_CERT_ENC_PKCS12 \\RD_KAFKA_CERT_ENC__CNT \\RD_KAFKA_CERT_PRIVATE_KEY \\RD_KAFKA_CERT_PUBLIC_KEY \\RD_KAFKA_CERT__CNT \\RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG \\RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG \\RD_KAFKA_CONFIG_SOURCE__CNT \\RD_KAFKA_CONF_INVALID \\RD_KAFKA_CONF_OK \\RD_KAFKA_CONF_UNKNOWN \\RD_KAFKA_CONSUMER \\RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE \\RD_KAFKA_EVENT_ALTERCONFIGS_RESULT \\RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT \\RD_KAFKA_EVENT_CREATETOPICS_RESULT \\RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT \\RD_KAFKA_EVENT_DELETEGROUPS_RESULT \\RD_KAFKA_EVENT_DELETERECORDS_RESULT \\RD_KAFKA_EVENT_DELETETOPICS_RESULT \\RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT \\RD_KAFKA_EVENT_DR \\RD_KAFKA_EVENT_ERROR \\RD_KAFKA_EVENT_FETCH \\RD_KAFKA_EVENT_LOG \\RD_KAFKA_EVENT_NONE \\RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH \\RD_KAFKA_EVENT_OFFSET_COMMIT \\RD_KAFKA_EVENT_REBALANCE \\RD_KAFKA_EVENT_STATS \\RD_KAFKA_LOG_PRINT \\RD_KAFKA_LOG_SYSLOG \\RD_KAFKA_LOG_SYSLOG_PRINT \\RD_KAFKA_MSG_F_BLOCK \\RD_KAFKA_MSG_F_COPY \\RD_KAFKA_MSG_F_FREE \\RD_KAFKA_MSG_F_PARTITION \\RD_KAFKA_MSG_PARTITIONER_CONSISTENT \\RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM \\RD_KAFKA_MSG_PARTITIONER_FNV1A \\RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM \\RD_KAFKA_MSG_PARTITIONER_MURMUR2 \\RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM \\RD_KAFKA_MSG_PARTITIONER_RANDOM \\RD_KAFKA_MSG_STATUS_NOT_PERSISTED \\RD_KAFKA_MSG_STATUS_PERSISTED \\RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED \\RD_KAFKA_OFFSET_BEGINNING \\RD_KAFKA_OFFSET_END \\RD_KAFKA_OFFSET_INVALID \\RD_KAFKA_OFFSET_STORED \\RD_KAFKA_OFFSET_TAIL_BASE \\RD_KAFKA_PARTITION_UA \\RD_KAFKA_PRODUCER \\RD_KAFKA_PURGE_F_INFLIGHT \\RD_KAFKA_PURGE_F_NON_BLOCKING \\RD_KAFKA_PURGE_F_QUEUE \\RD_KAFKA_RESOURCE_ANY \\RD_KAFKA_RESOURCE_BROKER \\RD_KAFKA_RESOURCE_GROUP \\RD_KAFKA_RESOURCE_TOPIC \\RD_KAFKA_RESOURCE_UNKNOWN \\RD_KAFKA_RESOURCE__CNT \\RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS \\RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS \\RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED \\RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE \\RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER \\RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED \\RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED \\RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID \\RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH \\RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND \\RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND \\RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS \\RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED \\RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC \\RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION \\RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE \\RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL \\RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET \\RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE \\RD_KAFKA_RESP_ERR_INVALID_CONFIG \\RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH \\RD_KAFKA_RESP_ERR_INVALID_GROUP_ID \\RD_KAFKA_RESP_ERR_INVALID_MSG \\RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE \\RD_KAFKA_RESP_ERR_INVALID_PARTITIONS \\RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE \\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH \\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING \\RD_KAFKA_RESP_ERR_INVALID_RECORD \\RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR \\RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT \\RD_KAFKA_RESP_ERR_INVALID_REQUEST \\RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS \\RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT \\RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP \\RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT \\RD_KAFKA_RESP_ERR_INVALID_TXN_STATE \\RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION \\RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR \\RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND \\RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND \\RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED \\RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE \\RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION \\RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP \\RD_KAFKA_RESP_ERR_NOT_CONTROLLER \\RD_KAFKA_RESP_ERR_NOT_COORDINATOR \\RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP \\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS \\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND \\RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION \\RD_KAFKA_RESP_ERR_NO_ERROR \\RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS \\RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE \\RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE \\RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED \\RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER \\RD_KAFKA_RESP_ERR_POLICY_VIOLATION \\RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE \\RD_KAFKA_RESP_ERR_PRODUCER_FENCED \\RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS \\RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS \\RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE \\RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT \\RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND \\RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED \\RD_KAFKA_RESP_ERR_SECURITY_DISABLED \\RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH \\RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH \\RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED \\RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS \\RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED \\RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION \\RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED \\RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL \\RD_KAFKA_RESP_ERR_UNKNOWN \\RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH \\RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID \\RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID \\RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART \\RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT \\RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM \\RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION \\RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN \\RD_KAFKA_RESP_ERR__APPLICATION \\RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST \\RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS \\RD_KAFKA_RESP_ERR__AUTHENTICATION \\RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET \\RD_KAFKA_RESP_ERR__BAD_COMPRESSION \\RD_KAFKA_RESP_ERR__BAD_MSG \\RD_KAFKA_RESP_ERR__BEGIN \\RD_KAFKA_RESP_ERR__CONFLICT \\RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE \\RD_KAFKA_RESP_ERR__DESTROY \\RD_KAFKA_RESP_ERR__END \\RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION \\RD_KAFKA_RESP_ERR__FAIL \\RD_KAFKA_RESP_ERR__FATAL \\RD_KAFKA_RESP_ERR__FENCED \\RD_KAFKA_RESP_ERR__FS \\RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE \\RD_KAFKA_RESP_ERR__INCONSISTENT \\RD_KAFKA_RESP_ERR__INTR \\RD_KAFKA_RESP_ERR__INVALID_ARG \\RD_KAFKA_RESP_ERR__INVALID_TYPE \\RD_KAFKA_RESP_ERR__IN_PROGRESS \\RD_KAFKA_RESP_ERR__ISR_INSUFF \\RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION \\RD_KAFKA_RESP_ERR__KEY_SERIALIZATION \\RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED \\RD_KAFKA_RESP_ERR__MSG_TIMED_OUT \\RD_KAFKA_RESP_ERR__NODE_UPDATE \\RD_KAFKA_RESP_ERR__NOENT \\RD_KAFKA_RESP_ERR__NOOP \\RD_KAFKA_RESP_ERR__NOT_CONFIGURED \\RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED \\RD_KAFKA_RESP_ERR__NO_OFFSET \\RD_KAFKA_RESP_ERR__OUTDATED \\RD_KAFKA_RESP_ERR__PARTIAL \\RD_KAFKA_RESP_ERR__PARTITION_EOF \\RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS \\RD_KAFKA_RESP_ERR__PURGE_INFLIGHT \\RD_KAFKA_RESP_ERR__PURGE_QUEUE \\RD_KAFKA_RESP_ERR__QUEUE_FULL \\RD_KAFKA_RESP_ERR__READ_ONLY \\RD_KAFKA_RESP_ERR__RESOLVE \\RD_KAFKA_RESP_ERR__RETRY \\RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS \\RD_KAFKA_RESP_ERR__SSL \\RD_KAFKA_RESP_ERR__STATE \\RD_KAFKA_RESP_ERR__TIMED_OUT \\RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE \\RD_KAFKA_RESP_ERR__TRANSPORT \\RD_KAFKA_RESP_ERR__UNDERFLOW \\RD_KAFKA_RESP_ERR__UNKNOWN_BROKER \\RD_KAFKA_RESP_ERR__UNKNOWN_GROUP \\RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION \\RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL \\RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC \\RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE \\RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION \\RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION \\RD_KAFKA_RESP_ERR__WAIT_CACHE \\RD_KAFKA_RESP_ERR__WAIT_COORD \\RD_KAFKA_SUPPORTED_METHODS \\RD_KAFKA_THREAD_BACKGROUND \\RD_KAFKA_THREAD_BROKER \\RD_KAFKA_THREAD_MAIN \\RD_KAFKA_TIMESTAMP_CREATE_TIME \\RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME \\RD_KAFKA_TIMESTAMP_NOT_AVAILABLE \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VTYPE_END \\RD_KAFKA_VTYPE_HEADER \\RD_KAFKA_VTYPE_HEADERS \\RD_KAFKA_VTYPE_KEY \\RD_KAFKA_VTYPE_MSGFLAGS \\RD_KAFKA_VTYPE_OPAQUE \\RD_KAFKA_VTYPE_PARTITION \\RD_KAFKA_VTYPE_RKT \\RD_KAFKA_VTYPE_TIMESTAMP \\RD_KAFKA_VTYPE_TOPIC \\RD_KAFKA_VTYPE_VALUE Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 84.57% (1283 / 1517) \u2764\ufe0f Classes: 46.43% (26 / 56) \ud83e\udde1 Methods: 65.32% (194 / 297)","title":"Overview"},{"location":"api/#overview","text":"","title":"Overview"},{"location":"api/#traits","text":"\\RdKafka\\FFI\\Methods \ud83e\udd0d","title":"Traits"},{"location":"api/#classes","text":"\\RdKafka \ud83d\udc9b \\RdKafka\\Admin\\AlterConfigsOptions \ud83d\udc9a \\RdKafka\\Admin\\Client \ud83d\udc9b \\RdKafka\\Admin\\ConfigEntry \ud83d\udc9a \\RdKafka\\Admin\\ConfigResource \ud83d\udc9a \\RdKafka\\Admin\\ConfigResourceResult \ud83d\udc9a \\RdKafka\\Admin\\CreatePartitionsOptions \ud83d\udc9a \\RdKafka\\Admin\\CreateTopicsOptions \ud83d\udc9a \\RdKafka\\Admin\\DeleteConsumerGroupOffsets \u2764\ufe0f \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions \u2764\ufe0f \\RdKafka\\Admin\\DeleteGroup \u2764\ufe0f \\RdKafka\\Admin\\DeleteGroupsOptions \u2764\ufe0f \\RdKafka\\Admin\\DeleteRecords \ud83d\udc9b \\RdKafka\\Admin\\DeleteRecordsOptions \ud83d\udc9a \\RdKafka\\Admin\\DeleteTopic \ud83e\udde1 \\RdKafka\\Admin\\DeleteTopicsOptions \ud83d\udc9a \\RdKafka\\Admin\\DescribeConfigsOptions \ud83d\udc9a \\RdKafka\\Admin\\GroupResult \u2764\ufe0f \\RdKafka\\Admin\\NewPartitions \ud83d\udc9a \\RdKafka\\Admin\\NewTopic \ud83d\udc9b \\RdKafka\\Admin\\Options \ud83d\udc9a \\RdKafka\\Admin\\TopicResult \ud83d\udc9a \\RdKafka\\Conf \ud83d\udc9a \\RdKafka\\Consumer \ud83d\udc9a \\RdKafka\\ConsumerTopic \ud83d\udc9b \\RdKafka\\Event \ud83d\udc9a \\RdKafka\\Exception \ud83d\udc9a \\RdKafka\\FFI\\CallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\ConsumeCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\DrMsgCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\ErrorCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\Library \ud83d\udc9b \\RdKafka\\FFI\\LogCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\NativePartitionerCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\OffsetCommitCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\OpaqueMap \ud83d\udc9a \\RdKafka\\FFI\\PartitionerCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\RebalanceCallbackProxy \ud83d\udc9a \\RdKafka\\FFI\\StatsCallbackProxy \ud83d\udc9a \\RdKafka\\KafkaConsumer \ud83d\udc9b \\RdKafka\\KafkaConsumerTopic \ud83d\udc9a \\RdKafka\\KafkaErrorException \ud83d\udc9a \\RdKafka\\Message \ud83d\udc9b \\RdKafka\\Metadata \ud83d\udc9a \\RdKafka\\Metadata\\Broker \ud83d\udc9a \\RdKafka\\Metadata\\Collection \ud83d\udc9a \\RdKafka\\Metadata\\Partition \ud83d\udc9a \\RdKafka\\Metadata\\Topic \ud83d\udc9a \\RdKafka\\Producer \ud83d\udc9b \\RdKafka\\ProducerTopic \ud83d\udc9b \\RdKafka\\Queue \ud83d\udc9b \\RdKafka\\Test\\ApiKey \u2764\ufe0f \\RdKafka\\Test\\MockCluster \ud83e\udde1 \\RdKafka\\Topic \ud83d\udc9b \\RdKafka\\TopicConf \ud83d\udc9b \\RdKafka\\TopicPartition \ud83d\udc9a \\RdKafka\\TopicPartitionList \ud83d\udc9a","title":"Classes"},{"location":"api/#functions","text":"\\rd_kafka_err2name() \\rd_kafka_err2str() \\rd_kafka_errno() \\rd_kafka_errno2err() \\rd_kafka_offset_tail() \\rd_kafka_thread_cnt() \\rd_kafka_version()","title":"Functions"},{"location":"api/#constants","text":"\\RD_KAFKA_ADMIN_OP_ALTERCONFIGS \\RD_KAFKA_ADMIN_OP_ANY \\RD_KAFKA_ADMIN_OP_CREATEPARTITIONS \\RD_KAFKA_ADMIN_OP_CREATETOPICS \\RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS \\RD_KAFKA_ADMIN_OP_DELETEGROUPS \\RD_KAFKA_ADMIN_OP_DELETERECORDS \\RD_KAFKA_ADMIN_OP_DELETETOPICS \\RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_ADMIN_OP__CNT \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CDEF \\RD_KAFKA_CERT_CA \\RD_KAFKA_CERT_ENC_DER \\RD_KAFKA_CERT_ENC_PEM \\RD_KAFKA_CERT_ENC_PKCS12 \\RD_KAFKA_CERT_ENC__CNT \\RD_KAFKA_CERT_PRIVATE_KEY \\RD_KAFKA_CERT_PUBLIC_KEY \\RD_KAFKA_CERT__CNT \\RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG \\RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG \\RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG \\RD_KAFKA_CONFIG_SOURCE__CNT \\RD_KAFKA_CONF_INVALID \\RD_KAFKA_CONF_OK \\RD_KAFKA_CONF_UNKNOWN \\RD_KAFKA_CONSUMER \\RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE \\RD_KAFKA_EVENT_ALTERCONFIGS_RESULT \\RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT \\RD_KAFKA_EVENT_CREATETOPICS_RESULT \\RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT \\RD_KAFKA_EVENT_DELETEGROUPS_RESULT \\RD_KAFKA_EVENT_DELETERECORDS_RESULT \\RD_KAFKA_EVENT_DELETETOPICS_RESULT \\RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT \\RD_KAFKA_EVENT_DR \\RD_KAFKA_EVENT_ERROR \\RD_KAFKA_EVENT_FETCH \\RD_KAFKA_EVENT_LOG \\RD_KAFKA_EVENT_NONE \\RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH \\RD_KAFKA_EVENT_OFFSET_COMMIT \\RD_KAFKA_EVENT_REBALANCE \\RD_KAFKA_EVENT_STATS \\RD_KAFKA_LOG_PRINT \\RD_KAFKA_LOG_SYSLOG \\RD_KAFKA_LOG_SYSLOG_PRINT \\RD_KAFKA_MSG_F_BLOCK \\RD_KAFKA_MSG_F_COPY \\RD_KAFKA_MSG_F_FREE \\RD_KAFKA_MSG_F_PARTITION \\RD_KAFKA_MSG_PARTITIONER_CONSISTENT \\RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM \\RD_KAFKA_MSG_PARTITIONER_FNV1A \\RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM \\RD_KAFKA_MSG_PARTITIONER_MURMUR2 \\RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM \\RD_KAFKA_MSG_PARTITIONER_RANDOM \\RD_KAFKA_MSG_STATUS_NOT_PERSISTED \\RD_KAFKA_MSG_STATUS_PERSISTED \\RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED \\RD_KAFKA_OFFSET_BEGINNING \\RD_KAFKA_OFFSET_END \\RD_KAFKA_OFFSET_INVALID \\RD_KAFKA_OFFSET_STORED \\RD_KAFKA_OFFSET_TAIL_BASE \\RD_KAFKA_PARTITION_UA \\RD_KAFKA_PRODUCER \\RD_KAFKA_PURGE_F_INFLIGHT \\RD_KAFKA_PURGE_F_NON_BLOCKING \\RD_KAFKA_PURGE_F_QUEUE \\RD_KAFKA_RESOURCE_ANY \\RD_KAFKA_RESOURCE_BROKER \\RD_KAFKA_RESOURCE_GROUP \\RD_KAFKA_RESOURCE_TOPIC \\RD_KAFKA_RESOURCE_UNKNOWN \\RD_KAFKA_RESOURCE__CNT \\RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS \\RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS \\RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH \\RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED \\RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE \\RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER \\RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED \\RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_END_ALL \\RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED \\RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID \\RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH \\RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND \\RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND \\RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS \\RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED \\RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC \\RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION \\RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE \\RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL \\RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET \\RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE \\RD_KAFKA_RESP_ERR_INVALID_CONFIG \\RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH \\RD_KAFKA_RESP_ERR_INVALID_GROUP_ID \\RD_KAFKA_RESP_ERR_INVALID_MSG \\RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE \\RD_KAFKA_RESP_ERR_INVALID_PARTITIONS \\RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE \\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH \\RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING \\RD_KAFKA_RESP_ERR_INVALID_RECORD \\RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR \\RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT \\RD_KAFKA_RESP_ERR_INVALID_REQUEST \\RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS \\RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT \\RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP \\RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT \\RD_KAFKA_RESP_ERR_INVALID_TXN_STATE \\RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION \\RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR \\RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND \\RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND \\RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED \\RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE \\RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION \\RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP \\RD_KAFKA_RESP_ERR_NOT_CONTROLLER \\RD_KAFKA_RESP_ERR_NOT_COORDINATOR \\RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP \\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS \\RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND \\RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION \\RD_KAFKA_RESP_ERR_NO_ERROR \\RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS \\RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE \\RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE \\RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED \\RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER \\RD_KAFKA_RESP_ERR_POLICY_VIOLATION \\RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE \\RD_KAFKA_RESP_ERR_PRODUCER_FENCED \\RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS \\RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS \\RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE \\RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE \\RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT \\RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND \\RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED \\RD_KAFKA_RESP_ERR_SECURITY_DISABLED \\RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH \\RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH \\RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED \\RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS \\RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED \\RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION \\RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED \\RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED \\RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL \\RD_KAFKA_RESP_ERR_UNKNOWN \\RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH \\RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID \\RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID \\RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART \\RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \\RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT \\RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM \\RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION \\RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN \\RD_KAFKA_RESP_ERR__APPLICATION \\RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST \\RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS \\RD_KAFKA_RESP_ERR__AUTHENTICATION \\RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET \\RD_KAFKA_RESP_ERR__BAD_COMPRESSION \\RD_KAFKA_RESP_ERR__BAD_MSG \\RD_KAFKA_RESP_ERR__BEGIN \\RD_KAFKA_RESP_ERR__CONFLICT \\RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE \\RD_KAFKA_RESP_ERR__DESTROY \\RD_KAFKA_RESP_ERR__END \\RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION \\RD_KAFKA_RESP_ERR__FAIL \\RD_KAFKA_RESP_ERR__FATAL \\RD_KAFKA_RESP_ERR__FENCED \\RD_KAFKA_RESP_ERR__FS \\RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE \\RD_KAFKA_RESP_ERR__INCONSISTENT \\RD_KAFKA_RESP_ERR__INTR \\RD_KAFKA_RESP_ERR__INVALID_ARG \\RD_KAFKA_RESP_ERR__INVALID_TYPE \\RD_KAFKA_RESP_ERR__IN_PROGRESS \\RD_KAFKA_RESP_ERR__ISR_INSUFF \\RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION \\RD_KAFKA_RESP_ERR__KEY_SERIALIZATION \\RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED \\RD_KAFKA_RESP_ERR__MSG_TIMED_OUT \\RD_KAFKA_RESP_ERR__NODE_UPDATE \\RD_KAFKA_RESP_ERR__NOENT \\RD_KAFKA_RESP_ERR__NOOP \\RD_KAFKA_RESP_ERR__NOT_CONFIGURED \\RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED \\RD_KAFKA_RESP_ERR__NO_OFFSET \\RD_KAFKA_RESP_ERR__OUTDATED \\RD_KAFKA_RESP_ERR__PARTIAL \\RD_KAFKA_RESP_ERR__PARTITION_EOF \\RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS \\RD_KAFKA_RESP_ERR__PURGE_INFLIGHT \\RD_KAFKA_RESP_ERR__PURGE_QUEUE \\RD_KAFKA_RESP_ERR__QUEUE_FULL \\RD_KAFKA_RESP_ERR__READ_ONLY \\RD_KAFKA_RESP_ERR__RESOLVE \\RD_KAFKA_RESP_ERR__RETRY \\RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS \\RD_KAFKA_RESP_ERR__SSL \\RD_KAFKA_RESP_ERR__STATE \\RD_KAFKA_RESP_ERR__TIMED_OUT \\RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE \\RD_KAFKA_RESP_ERR__TRANSPORT \\RD_KAFKA_RESP_ERR__UNDERFLOW \\RD_KAFKA_RESP_ERR__UNKNOWN_BROKER \\RD_KAFKA_RESP_ERR__UNKNOWN_GROUP \\RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION \\RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL \\RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC \\RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE \\RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION \\RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION \\RD_KAFKA_RESP_ERR__WAIT_CACHE \\RD_KAFKA_RESP_ERR__WAIT_COORD \\RD_KAFKA_SUPPORTED_METHODS \\RD_KAFKA_THREAD_BACKGROUND \\RD_KAFKA_THREAD_BROKER \\RD_KAFKA_THREAD_MAIN \\RD_KAFKA_TIMESTAMP_CREATE_TIME \\RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME \\RD_KAFKA_TIMESTAMP_NOT_AVAILABLE \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VERSION \\RD_KAFKA_VTYPE_END \\RD_KAFKA_VTYPE_HEADER \\RD_KAFKA_VTYPE_HEADERS \\RD_KAFKA_VTYPE_KEY \\RD_KAFKA_VTYPE_MSGFLAGS \\RD_KAFKA_VTYPE_OPAQUE \\RD_KAFKA_VTYPE_PARTITION \\RD_KAFKA_VTYPE_RKT \\RD_KAFKA_VTYPE_TIMESTAMP \\RD_KAFKA_VTYPE_TOPIC \\RD_KAFKA_VTYPE_VALUE","title":"Constants"},{"location":"api/#test-coverage","text":"\ud83d\udc9b Lines: 84.57% (1283 / 1517) \u2764\ufe0f Classes: 46.43% (26 / 56) \ud83e\udde1 Methods: 65.32% (194 / 297)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/","text":"Class RdKafka \u00b6 abstract Class \\RdKafka Methods \u00b6 __construct() \u00b6 public __construct ( int $type , ? \\RdKafka\\Conf $conf = null ) : Parameters type int conf ? \\RdKafka\\Conf __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData getMetadata() \u00b6 public getMetadata ( bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : \\RdKafka\\Metadata Parameters all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int Returns \\RdKafka\\Metadata getOpaque() \u00b6 public getOpaque ( ) : mixed | null Returns mixed|null pausePartitions() \u00b6 public pausePartitions ( \\TopicPartition [] $topicPartitions ) : \\TopicPartition [] Parameters topicPartitions \\TopicPartition[] Returns \\TopicPartition[] queryWatermarkOffsets() \u00b6 public queryWatermarkOffsets ( string $topic , int $partition , int & $low , int & $high , int $timeout_ms ) : void Parameters topic string partition int low int high int timeout_ms int resolveFromCData() \u00b6 public static resolveFromCData ( ? \\FFI\\CData $kafka = null ) : ? self Parameters kafka ?\\FFI\\CData Returns ?self resumePartitions() \u00b6 public resumePartitions ( \\TopicPartition [] $topicPartitions ) : \\TopicPartition [] Parameters topicPartitions \\TopicPartition[] Returns \\TopicPartition[] setLogLevel() \u00b6 public setLogLevel ( int $level ) : void Parameters level int Deprecated Set via Conf parameter log_level instead setLogger() \u00b6 public setLogger ( int $logger ) : void Parameters logger int Deprecated Use Conf::setLogCb instead Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 85.9% (67 / 78) \u2764\ufe0f Methods: 40% (6 / 15) Extended by \u00b6 \\RdKafka\\Consumer \\RdKafka\\KafkaConsumer \\RdKafka\\Producer","title":"RdKafka"},{"location":"api/RdKafka/#class-rdkafka","text":"abstract Class \\RdKafka","title":"Class RdKafka"},{"location":"api/RdKafka/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/#__construct","text":"public __construct ( int $type , ? \\RdKafka\\Conf $conf = null ) : Parameters type int conf ? \\RdKafka\\Conf","title":"__construct()"},{"location":"api/RdKafka/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/#getmetadata","text":"public getMetadata ( bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : \\RdKafka\\Metadata Parameters all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int Returns \\RdKafka\\Metadata","title":"getMetadata()"},{"location":"api/RdKafka/#getopaque","text":"public getOpaque ( ) : mixed | null Returns mixed|null","title":"getOpaque()"},{"location":"api/RdKafka/#pausepartitions","text":"public pausePartitions ( \\TopicPartition [] $topicPartitions ) : \\TopicPartition [] Parameters topicPartitions \\TopicPartition[] Returns \\TopicPartition[]","title":"pausePartitions()"},{"location":"api/RdKafka/#querywatermarkoffsets","text":"public queryWatermarkOffsets ( string $topic , int $partition , int & $low , int & $high , int $timeout_ms ) : void Parameters topic string partition int low int high int timeout_ms int","title":"queryWatermarkOffsets()"},{"location":"api/RdKafka/#resolvefromcdata","text":"public static resolveFromCData ( ? \\FFI\\CData $kafka = null ) : ? self Parameters kafka ?\\FFI\\CData Returns ?self","title":"resolveFromCData()"},{"location":"api/RdKafka/#resumepartitions","text":"public resumePartitions ( \\TopicPartition [] $topicPartitions ) : \\TopicPartition [] Parameters topicPartitions \\TopicPartition[] Returns \\TopicPartition[]","title":"resumePartitions()"},{"location":"api/RdKafka/#setloglevel","text":"public setLogLevel ( int $level ) : void Parameters level int Deprecated Set via Conf parameter log_level instead","title":"setLogLevel()"},{"location":"api/RdKafka/#setlogger","text":"public setLogger ( int $logger ) : void Parameters logger int Deprecated Use Conf::setLogCb instead","title":"setLogger()"},{"location":"api/RdKafka/#test-coverage","text":"\ud83d\udc9b Lines: 85.9% (67 / 78) \u2764\ufe0f Methods: 40% (6 / 15)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/#extended-by","text":"\\RdKafka\\Consumer \\RdKafka\\KafkaConsumer \\RdKafka\\Producer","title":"Extended by"},{"location":"api/constants/","text":"Constants \u00b6 RD_KAFKA_LOG_PRINT \u00b6 public RD_KAFKA_LOG_PRINT = 100 RD_KAFKA_LOG_SYSLOG \u00b6 public RD_KAFKA_LOG_SYSLOG = 101 RD_KAFKA_LOG_SYSLOG_PRINT \u00b6 public RD_KAFKA_LOG_SYSLOG_PRINT = 102 RD_KAFKA_MSG_PARTITIONER_RANDOM \u00b6 public RD_KAFKA_MSG_PARTITIONER_RANDOM = 2 RD_KAFKA_MSG_PARTITIONER_CONSISTENT \u00b6 public RD_KAFKA_MSG_PARTITIONER_CONSISTENT = 3 RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM \u00b6 public RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM = 4 RD_KAFKA_MSG_PARTITIONER_MURMUR2 \u00b6 public RD_KAFKA_MSG_PARTITIONER_MURMUR2 = 5 RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM \u00b6 public RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM = 6 RD_KAFKA_MSG_PARTITIONER_FNV1A \u00b6 public RD_KAFKA_MSG_PARTITIONER_FNV1A = 7 RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM \u00b6 public RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM = 8 RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE \u00b6 public RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE = 8 define RD_KAFKA_PARTITION_UA \u00b6 public RD_KAFKA_PARTITION_UA = - 1 Unassigned partition. The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3002d1858385de283ea004893e352863 RD_KAFKA_OFFSET_BEGINNING \u00b6 public RD_KAFKA_OFFSET_BEGINNING = - 2 Start consuming from beginning of kafka partition queue: oldest msg See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba RD_KAFKA_OFFSET_END \u00b6 public RD_KAFKA_OFFSET_END = - 1 Start consuming from end of kafka partition queue: next msg See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06 RD_KAFKA_OFFSET_STORED \u00b6 public RD_KAFKA_OFFSET_STORED = - 1000 Start consuming from offset retrieved from offset store See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be RD_KAFKA_OFFSET_INVALID \u00b6 public RD_KAFKA_OFFSET_INVALID = - 1001 Invalid offset See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1 RD_KAFKA_OFFSET_TAIL_BASE \u00b6 public RD_KAFKA_OFFSET_TAIL_BASE = - 2000 define RD_KAFKA_MSG_F_FREE \u00b6 public RD_KAFKA_MSG_F_FREE = 1 Producer message flags. Delegate freeing of payload to rdkafka. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7 RD_KAFKA_MSG_F_COPY \u00b6 public RD_KAFKA_MSG_F_COPY = 2 rdkafka will make a copy of the payload. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d RD_KAFKA_MSG_F_BLOCK \u00b6 public RD_KAFKA_MSG_F_BLOCK = 4 Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call rd_kafka_poll() (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the produce() call when the message queue is full. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2 RD_KAFKA_MSG_F_PARTITION \u00b6 public RD_KAFKA_MSG_F_PARTITION = 8 define RD_KAFKA_PURGE_F_QUEUE \u00b6 public RD_KAFKA_PURGE_F_QUEUE = 1 define RD_KAFKA_PURGE_F_INFLIGHT \u00b6 public RD_KAFKA_PURGE_F_INFLIGHT = 2 define RD_KAFKA_PURGE_F_NON_BLOCKING \u00b6 public RD_KAFKA_PURGE_F_NON_BLOCKING = 4 define RD_KAFKA_EVENT_NONE \u00b6 public RD_KAFKA_EVENT_NONE = 0 define RD_KAFKA_EVENT_DR \u00b6 public RD_KAFKA_EVENT_DR = 1 Producer Delivery report batch See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132 RD_KAFKA_EVENT_FETCH \u00b6 public RD_KAFKA_EVENT_FETCH = 2 Fetched message (consumer) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865 RD_KAFKA_EVENT_LOG \u00b6 public RD_KAFKA_EVENT_LOG = 4 Log message See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f RD_KAFKA_EVENT_ERROR \u00b6 public RD_KAFKA_EVENT_ERROR = 8 Error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103 RD_KAFKA_EVENT_REBALANCE \u00b6 public RD_KAFKA_EVENT_REBALANCE = 16 Group rebalance (consumer) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b RD_KAFKA_EVENT_OFFSET_COMMIT \u00b6 public RD_KAFKA_EVENT_OFFSET_COMMIT = 32 Offset commit result See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437 RD_KAFKA_EVENT_STATS \u00b6 public RD_KAFKA_EVENT_STATS = 64 define RD_KAFKA_EVENT_CREATETOPICS_RESULT \u00b6 public RD_KAFKA_EVENT_CREATETOPICS_RESULT = 100 define RD_KAFKA_EVENT_DELETETOPICS_RESULT \u00b6 public RD_KAFKA_EVENT_DELETETOPICS_RESULT = 101 define RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT \u00b6 public RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT = 102 define RD_KAFKA_EVENT_ALTERCONFIGS_RESULT \u00b6 public RD_KAFKA_EVENT_ALTERCONFIGS_RESULT = 103 define RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT \u00b6 public RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT = 104 define RD_KAFKA_PRODUCER \u00b6 public RD_KAFKA_PRODUCER = 0 Producer client See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 RD_KAFKA_CONSUMER \u00b6 public RD_KAFKA_CONSUMER = 1 Consumer client See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831 RD_KAFKA_TIMESTAMP_NOT_AVAILABLE \u00b6 public RD_KAFKA_TIMESTAMP_NOT_AVAILABLE = 0 Timestamp not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 RD_KAFKA_TIMESTAMP_CREATE_TIME \u00b6 public RD_KAFKA_TIMESTAMP_CREATE_TIME = 1 Message creation time See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME \u00b6 public RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME = 2 Log append time See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3 RD_KAFKA_RESP_ERR__BEGIN \u00b6 public RD_KAFKA_RESP_ERR__BEGIN = - 200 Begin internal error codes See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__BAD_MSG \u00b6 public RD_KAFKA_RESP_ERR__BAD_MSG = - 199 Received message is incorrect See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__BAD_COMPRESSION \u00b6 public RD_KAFKA_RESP_ERR__BAD_COMPRESSION = - 198 Bad/unknown compression See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__DESTROY \u00b6 public RD_KAFKA_RESP_ERR__DESTROY = - 197 Broker is going away See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__FAIL \u00b6 public RD_KAFKA_RESP_ERR__FAIL = - 196 Generic failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__TRANSPORT \u00b6 public RD_KAFKA_RESP_ERR__TRANSPORT = - 195 Broker transport failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE \u00b6 public RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = - 194 Critical system resource See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__RESOLVE \u00b6 public RD_KAFKA_RESP_ERR__RESOLVE = - 193 Failed to resolve broker See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__MSG_TIMED_OUT \u00b6 public RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = - 192 Produced message timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__PARTITION_EOF \u00b6 public RD_KAFKA_RESP_ERR__PARTITION_EOF = - 191 Reached the end of the topic+partition queue on the broker. Not really an error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION \u00b6 public RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = - 190 Permanent: Partition does not exist in cluster. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__FS \u00b6 public RD_KAFKA_RESP_ERR__FS = - 189 File or filesystem error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC \u00b6 public RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = - 188 Permanent: Topic does not exist in cluster. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN \u00b6 public RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = - 187 All broker connections are down. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__INVALID_ARG \u00b6 public RD_KAFKA_RESP_ERR__INVALID_ARG = - 186 Invalid argument, or invalid configuration See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__TIMED_OUT \u00b6 public RD_KAFKA_RESP_ERR__TIMED_OUT = - 185 Operation timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__QUEUE_FULL \u00b6 public RD_KAFKA_RESP_ERR__QUEUE_FULL = - 184 Queue is full See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__ISR_INSUFF \u00b6 public RD_KAFKA_RESP_ERR__ISR_INSUFF = - 183 ISR count < required.acks See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__NODE_UPDATE \u00b6 public RD_KAFKA_RESP_ERR__NODE_UPDATE = - 182 Broker node update See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__SSL \u00b6 public RD_KAFKA_RESP_ERR__SSL = - 181 SSL error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__WAIT_COORD \u00b6 public RD_KAFKA_RESP_ERR__WAIT_COORD = - 180 Waiting for coordinator to become available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__UNKNOWN_GROUP \u00b6 public RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = - 179 Unknown client group See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR__IN_PROGRESS = - 178 Operation in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = - 177 Previous operation in progress, wait for it to finish. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION \u00b6 public RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = - 176 This operation would interfere with an existing subscription See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS \u00b6 public RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = - 175 Assigned partitions (rebalance_cb) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS \u00b6 public RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = - 174 Revoked partitions (rebalance_cb) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__CONFLICT \u00b6 public RD_KAFKA_RESP_ERR__CONFLICT = - 173 Conflicting use See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__STATE \u00b6 public RD_KAFKA_RESP_ERR__STATE = - 172 Wrong state See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL \u00b6 public RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = - 171 Unknown protocol See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED \u00b6 public RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = - 170 Not implemented See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__AUTHENTICATION \u00b6 public RD_KAFKA_RESP_ERR__AUTHENTICATION = - 169 Authentication failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__NO_OFFSET \u00b6 public RD_KAFKA_RESP_ERR__NO_OFFSET = - 168 No stored offset See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__OUTDATED \u00b6 public RD_KAFKA_RESP_ERR__OUTDATED = - 167 Outdated See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE \u00b6 public RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = - 166 Timed out in queue See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE \u00b6 public RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = - 165 Feature not supported by broker See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__WAIT_CACHE \u00b6 public RD_KAFKA_RESP_ERR__WAIT_CACHE = - 164 Awaiting cache update See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR__INTR \u00b6 public RD_KAFKA_RESP_ERR__INTR = - 163 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__KEY_SERIALIZATION \u00b6 public RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = - 162 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION \u00b6 public RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = - 161 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION \u00b6 public RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = - 160 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION \u00b6 public RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = - 159 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__PARTIAL \u00b6 public RD_KAFKA_RESP_ERR__PARTIAL = - 158 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__READ_ONLY \u00b6 public RD_KAFKA_RESP_ERR__READ_ONLY = - 157 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__NOENT \u00b6 public RD_KAFKA_RESP_ERR__NOENT = - 156 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__UNDERFLOW \u00b6 public RD_KAFKA_RESP_ERR__UNDERFLOW = - 155 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__INVALID_TYPE \u00b6 public RD_KAFKA_RESP_ERR__INVALID_TYPE = - 154 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__RETRY \u00b6 public RD_KAFKA_RESP_ERR__RETRY = - 153 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__PURGE_QUEUE \u00b6 public RD_KAFKA_RESP_ERR__PURGE_QUEUE = - 152 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__PURGE_INFLIGHT \u00b6 public RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = - 151 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__FATAL \u00b6 public RD_KAFKA_RESP_ERR__FATAL = - 150 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__INCONSISTENT \u00b6 public RD_KAFKA_RESP_ERR__INCONSISTENT = - 149 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE \u00b6 public RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = - 148 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED \u00b6 public RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = - 147 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__END \u00b6 public RD_KAFKA_RESP_ERR__END = - 100 End internal error codes See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNKNOWN \u00b6 public RD_KAFKA_RESP_ERR_UNKNOWN = - 1 Unknown broker error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NO_ERROR \u00b6 public RD_KAFKA_RESP_ERR_NO_ERROR = 0 Success See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE \u00b6 public RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1 Offset out of range See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_MSG \u00b6 public RD_KAFKA_RESP_ERR_INVALID_MSG = 2 Invalid message See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART \u00b6 public RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3 Unknown topic or partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE \u00b6 public RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4 Invalid message size See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5 Leader not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION \u00b6 public RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6 Not leader for partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT \u00b6 public RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7 Request timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8 Broker not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9 Replica not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE \u00b6 public RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10 Message size too large See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11 StaleControllerEpochCode See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE \u00b6 public RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12 Offset metadata string too large See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION \u00b6 public RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13 Broker disconnected before response received See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14 Group coordinator load in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15 Group coordinator not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP \u00b6 public RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16 Not coordinator for group See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION \u00b6 public RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17 Invalid topic See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE \u00b6 public RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18 Message batch larger than configured server segment size See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS \u00b6 public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19 Not enough in-sync replicas See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND \u00b6 public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20 Message(s) written to insufficient number of in-sync replicas See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS \u00b6 public RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21 Invalid required acks value See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION \u00b6 public RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22 Specified group generation id is not valid See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL \u00b6 public RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23 Inconsistent group protocol See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_GROUP_ID \u00b6 public RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24 Invalid group.id See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID \u00b6 public RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25 Unknown member See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT \u00b6 public RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26 Invalid session timeout See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27 Group rebalance in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE \u00b6 public RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28 Commit offset data size is not valid See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29 Topic authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30 Group authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31 Cluster authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP \u00b6 public RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32 Invalid timestamp See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33 Unsupported SASL mechanism See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE \u00b6 public RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34 Illegal SASL state See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35 Unuspported version See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS \u00b6 public RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36 Topic already exists See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_PARTITIONS \u00b6 public RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37 Invalid number of partitions See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR \u00b6 public RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38 Invalid replication factor See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT \u00b6 public RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39 Invalid replica assignment See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_CONFIG \u00b6 public RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40 Invalid config See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_NOT_CONTROLLER \u00b6 public RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41 Not controller for cluster See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_INVALID_REQUEST \u00b6 public RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42 Invalid request See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43 Message format on broker does not support request See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb RD_KAFKA_RESP_ERR_POLICY_VIOLATION \u00b6 public RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER \u00b6 public RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER \u00b6 public RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_TXN_STATE \u00b6 public RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING \u00b6 public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT \u00b6 public RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS \u00b6 public RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED \u00b6 public RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_SECURITY_DISABLED \u00b6 public RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED \u00b6 public RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR \u00b6 public RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID \u00b6 public RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED \u00b6 public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE \u00b6 public RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP \u00b6 public RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED \u00b6 public RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73 enum rd_kafka_resp_err_t RD_KAFKA_VTYPE_END \u00b6 public RD_KAFKA_VTYPE_END = 0 va-arg sentinel See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165 https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_TOPIC \u00b6 public RD_KAFKA_VTYPE_TOPIC = 1 (const char *) Topic name See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_RKT \u00b6 public RD_KAFKA_VTYPE_RKT = 2 (rd_kafka_topic_t *) Topic handle See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_PARTITION \u00b6 public RD_KAFKA_VTYPE_PARTITION = 3 (int32_t) Partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_VALUE \u00b6 public RD_KAFKA_VTYPE_VALUE = 4 (void *, size_t) Message value (payload) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_KEY \u00b6 public RD_KAFKA_VTYPE_KEY = 5 (void *, size_t) Message key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_OPAQUE \u00b6 public RD_KAFKA_VTYPE_OPAQUE = 6 (void *) Application opaque See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_MSGFLAGS \u00b6 public RD_KAFKA_VTYPE_MSGFLAGS = 7 (int) RD_KAFKA_MSG_F_.. flags See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_TIMESTAMP \u00b6 public RD_KAFKA_VTYPE_TIMESTAMP = 8 (int64_t) Milliseconds since epoch UTC See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b RD_KAFKA_VTYPE_HEADER \u00b6 public RD_KAFKA_VTYPE_HEADER = 9 enum rd_kafka_vtype_t RD_KAFKA_VTYPE_HEADERS \u00b6 public RD_KAFKA_VTYPE_HEADERS = 10 enum rd_kafka_vtype_t RD_KAFKA_MSG_STATUS_NOT_PERSISTED \u00b6 public RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0 enum rd_kafka_msg_status_t RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED \u00b6 public RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1 enum rd_kafka_msg_status_t RD_KAFKA_MSG_STATUS_PERSISTED \u00b6 public RD_KAFKA_MSG_STATUS_PERSISTED = 2 enum rd_kafka_msg_status_t RD_KAFKA_CONF_UNKNOWN \u00b6 public RD_KAFKA_CONF_UNKNOWN = - 2 Unknown configuration name. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 RD_KAFKA_CONF_INVALID \u00b6 public RD_KAFKA_CONF_INVALID = - 1 Invalid configuration value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 RD_KAFKA_CONF_OK \u00b6 public RD_KAFKA_CONF_OK = 0 Configuration okay See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4 RD_KAFKA_ADMIN_OP_ANY \u00b6 public RD_KAFKA_ADMIN_OP_ANY = 0 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_CREATETOPICS \u00b6 public RD_KAFKA_ADMIN_OP_CREATETOPICS = 1 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_DELETETOPICS \u00b6 public RD_KAFKA_ADMIN_OP_DELETETOPICS = 2 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_CREATEPARTITIONS \u00b6 public RD_KAFKA_ADMIN_OP_CREATEPARTITIONS = 3 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_ALTERCONFIGS \u00b6 public RD_KAFKA_ADMIN_OP_ALTERCONFIGS = 4 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS \u00b6 public RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS = 5 enum rd_kafka_admin_op_t RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG \u00b6 public RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5 enum rd_kafka_ConfigSource_t RD_KAFKA_CONFIG_SOURCE__CNT \u00b6 public RD_KAFKA_CONFIG_SOURCE__CNT = 6 enum rd_kafka_ConfigSource_t RD_KAFKA_RESOURCE_UNKNOWN \u00b6 public RD_KAFKA_RESOURCE_UNKNOWN = 0 enum rd_kafka_ResourceType_t RD_KAFKA_RESOURCE_ANY \u00b6 public RD_KAFKA_RESOURCE_ANY = 1 enum rd_kafka_ResourceType_t RD_KAFKA_RESOURCE_TOPIC \u00b6 public RD_KAFKA_RESOURCE_TOPIC = 2 enum rd_kafka_ResourceType_t RD_KAFKA_RESOURCE_GROUP \u00b6 public RD_KAFKA_RESOURCE_GROUP = 3 enum rd_kafka_ResourceType_t RD_KAFKA_RESOURCE_BROKER \u00b6 public RD_KAFKA_RESOURCE_BROKER = 4 enum rd_kafka_ResourceType_t RD_KAFKA_RESOURCE__CNT \u00b6 public RD_KAFKA_RESOURCE__CNT = 5 enum rd_kafka_ResourceType_t RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH \u00b6 public RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED \u00b6 public RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED \u00b6 public RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81 enum rd_kafka_resp_err_t RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH \u00b6 public RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH = 256 define RD_KAFKA_CERT_PUBLIC_KEY \u00b6 public RD_KAFKA_CERT_PUBLIC_KEY = 0 enum rd_kafka_cert_type_t RD_KAFKA_CERT_PRIVATE_KEY \u00b6 public RD_KAFKA_CERT_PRIVATE_KEY = 1 enum rd_kafka_cert_type_t RD_KAFKA_CERT_CA \u00b6 public RD_KAFKA_CERT_CA = 2 enum rd_kafka_cert_type_t RD_KAFKA_CERT__CNT \u00b6 public RD_KAFKA_CERT__CNT = 3 enum rd_kafka_cert_type_t RD_KAFKA_CERT_ENC_PKCS12 \u00b6 public RD_KAFKA_CERT_ENC_PKCS12 = 0 enum rd_kafka_cert_enc_t RD_KAFKA_CERT_ENC_DER \u00b6 public RD_KAFKA_CERT_ENC_DER = 1 enum rd_kafka_cert_enc_t RD_KAFKA_CERT_ENC_PEM \u00b6 public RD_KAFKA_CERT_ENC_PEM = 2 enum rd_kafka_cert_enc_t RD_KAFKA_CERT_ENC__CNT \u00b6 public RD_KAFKA_CERT_ENC__CNT = 3 enum rd_kafka_cert_enc_t RD_KAFKA_THREAD_MAIN \u00b6 public RD_KAFKA_THREAD_MAIN = 0 enum rd_kafka_thread_type_t RD_KAFKA_THREAD_BACKGROUND \u00b6 public RD_KAFKA_THREAD_BACKGROUND = 1 enum rd_kafka_thread_type_t RD_KAFKA_THREAD_BROKER \u00b6 public RD_KAFKA_THREAD_BROKER = 2 enum rd_kafka_thread_type_t RD_KAFKA_RESP_ERR__UNKNOWN_BROKER \u00b6 public RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = - 146 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_NOT_COORDINATOR \u00b6 public RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__NOT_CONFIGURED \u00b6 public RD_KAFKA_RESP_ERR__NOT_CONFIGURED = - 145 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__FENCED \u00b6 public RD_KAFKA_RESP_ERR__FENCED = - 144 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__APPLICATION \u00b6 public RD_KAFKA_RESP_ERR__APPLICATION = - 143 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID \u00b6 public RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE \u00b6 public RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED \u00b6 public RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS \u00b6 public RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC \u00b6 public RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_RECORD \u00b6 public RD_KAFKA_RESP_ERR_INVALID_RECORD = 87 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT \u00b6 public RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88 enum rd_kafka_resp_err_t RD_KAFKA_EVENT_DELETERECORDS_RESULT \u00b6 public RD_KAFKA_EVENT_DELETERECORDS_RESULT = 105 define RD_KAFKA_EVENT_DELETEGROUPS_RESULT \u00b6 public RD_KAFKA_EVENT_DELETEGROUPS_RESULT = 106 define RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT \u00b6 public RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT = 107 define RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST \u00b6 public RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = - 142 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR__NOOP \u00b6 public RD_KAFKA_RESP_ERR__NOOP = - 141 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED \u00b6 public RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_PRODUCER_FENCED \u00b6 public RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND \u00b6 public RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE \u00b6 public RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL \u00b6 public RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET \u00b6 public RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION \u00b6 public RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED \u00b6 public RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE \u00b6 public RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP_DELETERECORDS \u00b6 public RD_KAFKA_ADMIN_OP_DELETERECORDS = 6 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_DELETEGROUPS \u00b6 public RD_KAFKA_ADMIN_OP_DELETEGROUPS = 7 enum rd_kafka_admin_op_t RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS \u00b6 public RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS = 8 enum rd_kafka_admin_op_t RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET \u00b6 public RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = - 140 enum rd_kafka_resp_err_t RD_KAFKA_SUPPORTED_METHODS \u00b6 public RD_KAFKA_SUPPORTED_METHODS = [ 'rd_kafka_version' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_version_str' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_debug_contexts' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_err_descs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_err2str' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_err2name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_last_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_errno2err' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_errno' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_fatal_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_test_fatal_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_add_range' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_del' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_del_by_idx' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_copy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_set_offset' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_find' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_sort' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_copy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_remove' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get_last' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get_all' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_timestamp' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_latency' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_detach_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_set_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_cnt' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_status' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dup_filter' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_events' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_background_event_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_dr_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_dr_msg_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_consume_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_rebalance_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_offset_commit_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_error_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_throttle_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_log_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_stats_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_socket_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_connect_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_closesocket_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_default_topic_conf' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dump_free' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_properties_show' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_default_topic_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_partitioner_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_msg_order_cmp' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_available' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_consistent' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_consistent_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_murmur2' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_murmur2_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_destroy_flags' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_memberid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_clusterid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_controllerid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_yield' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_pause_partitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_resume_partitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_query_watermark_offsets' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_watermark_offsets' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offsets_for_times' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_free' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_main' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_consumer' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_partition' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_background' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_forward' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_log_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_length' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_io_event_enable' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_cb_event_enable' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_start' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_start_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_stop' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_seek' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_batch' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_callback' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_batch_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_callback_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offset_store' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offsets_store' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_subscribe' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_unsubscribe' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_subscription' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_close' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_assign' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_message' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_committed' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_position' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_produce' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_producev' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_produce_batch' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_flush' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_purge' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_metadata' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_metadata_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_list_groups' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_group_list_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_brokers_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_logger' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_log_level' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_log_print' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_log_syslog' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_outq_len' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_thread_cnt' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_wait_destroyed' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_unittest' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_poll_set_consumer' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_next' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_count' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error_is_fatal' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_log' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_stats' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_topic_partition_list' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_topic_partition' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_CreateTopics_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteTopics_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_CreatePartitions_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_AlterConfigs_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DescribeConfigs_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_poll_callback' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_plugin_f_conf_init_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_set_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_dup_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_destroy_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_new_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_destroy_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_send_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_acknowledgement_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_consume_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_commit_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_request_sent_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_send' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_acknowledgement' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_consume' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_commit' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_request_sent' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_request_timeout' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_operation_timeout' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_validate_only' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_broker' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_set_replica_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_set_config' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreateTopics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreateTopics_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopics_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_set_replica_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreatePartitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreatePartitions_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigSource_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_value' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_source' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_read_only' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_default' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_sensitive' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_synonym' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_synonyms' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ResourceType_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_set_config' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_configs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AlterConfigs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AlterConfigs_result_resources' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DescribeConfigs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DescribeConfigs_result_resources' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_oauthbearer_token_refresh_cb' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_ssl_cert_verify_cb' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_ssl_cert' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_event_config_string' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_oauthbearer_set_token' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_oauthbearer_set_token_failure' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_thread_start_t' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_thread_exit_t' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_thread_start' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_thread_exit' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_new' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_destroy' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_handle' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_bootstraps' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_push_request_errors' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_topic_set_error' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_leader' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_follower' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_follower_wmarks' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_rack' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_error_code' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_name' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_string' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_is_fatal' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_is_retriable' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_txn_requires_abort' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_destroy' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_new' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_fnv1a' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_fnv1a_random' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_new' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_destroy' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_write' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_read' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_init_transactions' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_begin_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_send_offsets_to_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_abort_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_handle_mock_cluster' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_topic_create' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_down' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_up' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_coordinator_set' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_set_apiversion' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_rtt' => [ 'min' => '1.4.4' , 'max' => '1.8.2' ], 'rd_kafka_message_errstr' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_message_broker_id' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_produceva' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_event_debug_contexts' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_push_request_errors' => [ 'min' => '1.5.0' , 'max' => '1.6.1' ], 'rd_kafka_conf_get_default_topic_conf' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_yield' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_seek_partitions' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_incremental_assign' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_incremental_unassign' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_rebalance_protocol' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_assignment_lost' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_new_with_genid' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteRecords_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteGroups_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteConsumerGroupOffsets_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_error' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_name' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_partitions' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_result_offsets' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroups_result_groups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_result_groups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_clear_request_errors' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_push_request_errors_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_response_received_t' => [ 'min' => '1.6.1' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_response_received' => [ 'min' => '1.6.1' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_engine_callback_data' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_calloc' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_malloc' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_push_request_error_rtts' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ]] RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16777471 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 75 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16777727 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16843007 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16908543 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16908799 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16909055 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 16974079 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17039615 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17040127 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17040639 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17105151 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17105663 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 89 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17105919 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 89 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17170687 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17170943 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17236223 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17301759 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h RD_KAFKA_VERSION \u00b6 public RD_KAFKA_VERSION = 17302271 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE \u00b6 public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t RD_KAFKA_RESP_ERR_END_ALL \u00b6 public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t RD_KAFKA_ADMIN_OP__CNT \u00b6 public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t RD_KAFKA_CDEF \u00b6 public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"Constants"},{"location":"api/constants/#constants","text":"","title":"Constants"},{"location":"api/constants/#rd_kafka_log_print","text":"public RD_KAFKA_LOG_PRINT = 100","title":"RD_KAFKA_LOG_PRINT"},{"location":"api/constants/#rd_kafka_log_syslog","text":"public RD_KAFKA_LOG_SYSLOG = 101","title":"RD_KAFKA_LOG_SYSLOG"},{"location":"api/constants/#rd_kafka_log_syslog_print","text":"public RD_KAFKA_LOG_SYSLOG_PRINT = 102","title":"RD_KAFKA_LOG_SYSLOG_PRINT"},{"location":"api/constants/#rd_kafka_msg_partitioner_random","text":"public RD_KAFKA_MSG_PARTITIONER_RANDOM = 2","title":"RD_KAFKA_MSG_PARTITIONER_RANDOM"},{"location":"api/constants/#rd_kafka_msg_partitioner_consistent","text":"public RD_KAFKA_MSG_PARTITIONER_CONSISTENT = 3","title":"RD_KAFKA_MSG_PARTITIONER_CONSISTENT"},{"location":"api/constants/#rd_kafka_msg_partitioner_consistent_random","text":"public RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM = 4","title":"RD_KAFKA_MSG_PARTITIONER_CONSISTENT_RANDOM"},{"location":"api/constants/#rd_kafka_msg_partitioner_murmur2","text":"public RD_KAFKA_MSG_PARTITIONER_MURMUR2 = 5","title":"RD_KAFKA_MSG_PARTITIONER_MURMUR2"},{"location":"api/constants/#rd_kafka_msg_partitioner_murmur2_random","text":"public RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM = 6","title":"RD_KAFKA_MSG_PARTITIONER_MURMUR2_RANDOM"},{"location":"api/constants/#rd_kafka_msg_partitioner_fnv1a","text":"public RD_KAFKA_MSG_PARTITIONER_FNV1A = 7","title":"RD_KAFKA_MSG_PARTITIONER_FNV1A"},{"location":"api/constants/#rd_kafka_msg_partitioner_fnv1a_random","text":"public RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM = 8","title":"RD_KAFKA_MSG_PARTITIONER_FNV1A_RANDOM"},{"location":"api/constants/#rd_kafka_destroy_f_no_consumer_close","text":"public RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE = 8 define","title":"RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE"},{"location":"api/constants/#rd_kafka_partition_ua","text":"public RD_KAFKA_PARTITION_UA = - 1 Unassigned partition. The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3002d1858385de283ea004893e352863","title":"RD_KAFKA_PARTITION_UA"},{"location":"api/constants/#rd_kafka_offset_beginning","text":"public RD_KAFKA_OFFSET_BEGINNING = - 2 Start consuming from beginning of kafka partition queue: oldest msg See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba","title":"RD_KAFKA_OFFSET_BEGINNING"},{"location":"api/constants/#rd_kafka_offset_end","text":"public RD_KAFKA_OFFSET_END = - 1 Start consuming from end of kafka partition queue: next msg See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06","title":"RD_KAFKA_OFFSET_END"},{"location":"api/constants/#rd_kafka_offset_stored","text":"public RD_KAFKA_OFFSET_STORED = - 1000 Start consuming from offset retrieved from offset store See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be","title":"RD_KAFKA_OFFSET_STORED"},{"location":"api/constants/#rd_kafka_offset_invalid","text":"public RD_KAFKA_OFFSET_INVALID = - 1001 Invalid offset See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1","title":"RD_KAFKA_OFFSET_INVALID"},{"location":"api/constants/#rd_kafka_offset_tail_base","text":"public RD_KAFKA_OFFSET_TAIL_BASE = - 2000 define","title":"RD_KAFKA_OFFSET_TAIL_BASE"},{"location":"api/constants/#rd_kafka_msg_f_free","text":"public RD_KAFKA_MSG_F_FREE = 1 Producer message flags. Delegate freeing of payload to rdkafka. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7","title":"RD_KAFKA_MSG_F_FREE"},{"location":"api/constants/#rd_kafka_msg_f_copy","text":"public RD_KAFKA_MSG_F_COPY = 2 rdkafka will make a copy of the payload. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d","title":"RD_KAFKA_MSG_F_COPY"},{"location":"api/constants/#rd_kafka_msg_f_block","text":"public RD_KAFKA_MSG_F_BLOCK = 4 Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call rd_kafka_poll() (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the produce() call when the message queue is full. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2","title":"RD_KAFKA_MSG_F_BLOCK"},{"location":"api/constants/#rd_kafka_msg_f_partition","text":"public RD_KAFKA_MSG_F_PARTITION = 8 define","title":"RD_KAFKA_MSG_F_PARTITION"},{"location":"api/constants/#rd_kafka_purge_f_queue","text":"public RD_KAFKA_PURGE_F_QUEUE = 1 define","title":"RD_KAFKA_PURGE_F_QUEUE"},{"location":"api/constants/#rd_kafka_purge_f_inflight","text":"public RD_KAFKA_PURGE_F_INFLIGHT = 2 define","title":"RD_KAFKA_PURGE_F_INFLIGHT"},{"location":"api/constants/#rd_kafka_purge_f_non_blocking","text":"public RD_KAFKA_PURGE_F_NON_BLOCKING = 4 define","title":"RD_KAFKA_PURGE_F_NON_BLOCKING"},{"location":"api/constants/#rd_kafka_event_none","text":"public RD_KAFKA_EVENT_NONE = 0 define","title":"RD_KAFKA_EVENT_NONE"},{"location":"api/constants/#rd_kafka_event_dr","text":"public RD_KAFKA_EVENT_DR = 1 Producer Delivery report batch See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132","title":"RD_KAFKA_EVENT_DR"},{"location":"api/constants/#rd_kafka_event_fetch","text":"public RD_KAFKA_EVENT_FETCH = 2 Fetched message (consumer) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865","title":"RD_KAFKA_EVENT_FETCH"},{"location":"api/constants/#rd_kafka_event_log","text":"public RD_KAFKA_EVENT_LOG = 4 Log message See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f","title":"RD_KAFKA_EVENT_LOG"},{"location":"api/constants/#rd_kafka_event_error","text":"public RD_KAFKA_EVENT_ERROR = 8 Error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a080a7ad60de643f47424031ee95da103","title":"RD_KAFKA_EVENT_ERROR"},{"location":"api/constants/#rd_kafka_event_rebalance","text":"public RD_KAFKA_EVENT_REBALANCE = 16 Group rebalance (consumer) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b","title":"RD_KAFKA_EVENT_REBALANCE"},{"location":"api/constants/#rd_kafka_event_offset_commit","text":"public RD_KAFKA_EVENT_OFFSET_COMMIT = 32 Offset commit result See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437","title":"RD_KAFKA_EVENT_OFFSET_COMMIT"},{"location":"api/constants/#rd_kafka_event_stats","text":"public RD_KAFKA_EVENT_STATS = 64 define","title":"RD_KAFKA_EVENT_STATS"},{"location":"api/constants/#rd_kafka_event_createtopics_result","text":"public RD_KAFKA_EVENT_CREATETOPICS_RESULT = 100 define","title":"RD_KAFKA_EVENT_CREATETOPICS_RESULT"},{"location":"api/constants/#rd_kafka_event_deletetopics_result","text":"public RD_KAFKA_EVENT_DELETETOPICS_RESULT = 101 define","title":"RD_KAFKA_EVENT_DELETETOPICS_RESULT"},{"location":"api/constants/#rd_kafka_event_createpartitions_result","text":"public RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT = 102 define","title":"RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT"},{"location":"api/constants/#rd_kafka_event_alterconfigs_result","text":"public RD_KAFKA_EVENT_ALTERCONFIGS_RESULT = 103 define","title":"RD_KAFKA_EVENT_ALTERCONFIGS_RESULT"},{"location":"api/constants/#rd_kafka_event_describeconfigs_result","text":"public RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT = 104 define","title":"RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT"},{"location":"api/constants/#rd_kafka_producer","text":"public RD_KAFKA_PRODUCER = 0 Producer client See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831","title":"RD_KAFKA_PRODUCER"},{"location":"api/constants/#rd_kafka_consumer","text":"public RD_KAFKA_CONSUMER = 1 Consumer client See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831","title":"RD_KAFKA_CONSUMER"},{"location":"api/constants/#rd_kafka_timestamp_not_available","text":"public RD_KAFKA_TIMESTAMP_NOT_AVAILABLE = 0 Timestamp not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3","title":"RD_KAFKA_TIMESTAMP_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_timestamp_create_time","text":"public RD_KAFKA_TIMESTAMP_CREATE_TIME = 1 Message creation time See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3","title":"RD_KAFKA_TIMESTAMP_CREATE_TIME"},{"location":"api/constants/#rd_kafka_timestamp_log_append_time","text":"public RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME = 2 Log append time See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3","title":"RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME"},{"location":"api/constants/#rd_kafka_resp_err__begin","text":"public RD_KAFKA_RESP_ERR__BEGIN = - 200 Begin internal error codes See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__BEGIN"},{"location":"api/constants/#rd_kafka_resp_err__bad_msg","text":"public RD_KAFKA_RESP_ERR__BAD_MSG = - 199 Received message is incorrect See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__BAD_MSG"},{"location":"api/constants/#rd_kafka_resp_err__bad_compression","text":"public RD_KAFKA_RESP_ERR__BAD_COMPRESSION = - 198 Bad/unknown compression See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__BAD_COMPRESSION"},{"location":"api/constants/#rd_kafka_resp_err__destroy","text":"public RD_KAFKA_RESP_ERR__DESTROY = - 197 Broker is going away See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__DESTROY"},{"location":"api/constants/#rd_kafka_resp_err__fail","text":"public RD_KAFKA_RESP_ERR__FAIL = - 196 Generic failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__FAIL"},{"location":"api/constants/#rd_kafka_resp_err__transport","text":"public RD_KAFKA_RESP_ERR__TRANSPORT = - 195 Broker transport failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__TRANSPORT"},{"location":"api/constants/#rd_kafka_resp_err__crit_sys_resource","text":"public RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = - 194 Critical system resource See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE"},{"location":"api/constants/#rd_kafka_resp_err__resolve","text":"public RD_KAFKA_RESP_ERR__RESOLVE = - 193 Failed to resolve broker See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__RESOLVE"},{"location":"api/constants/#rd_kafka_resp_err__msg_timed_out","text":"public RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = - 192 Produced message timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__MSG_TIMED_OUT"},{"location":"api/constants/#rd_kafka_resp_err__partition_eof","text":"public RD_KAFKA_RESP_ERR__PARTITION_EOF = - 191 Reached the end of the topic+partition queue on the broker. Not really an error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__PARTITION_EOF"},{"location":"api/constants/#rd_kafka_resp_err__unknown_partition","text":"public RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = - 190 Permanent: Partition does not exist in cluster. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION"},{"location":"api/constants/#rd_kafka_resp_err__fs","text":"public RD_KAFKA_RESP_ERR__FS = - 189 File or filesystem error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__FS"},{"location":"api/constants/#rd_kafka_resp_err__unknown_topic","text":"public RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = - 188 Permanent: Topic does not exist in cluster. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC"},{"location":"api/constants/#rd_kafka_resp_err__all_brokers_down","text":"public RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = - 187 All broker connections are down. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN"},{"location":"api/constants/#rd_kafka_resp_err__invalid_arg","text":"public RD_KAFKA_RESP_ERR__INVALID_ARG = - 186 Invalid argument, or invalid configuration See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__INVALID_ARG"},{"location":"api/constants/#rd_kafka_resp_err__timed_out","text":"public RD_KAFKA_RESP_ERR__TIMED_OUT = - 185 Operation timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__TIMED_OUT"},{"location":"api/constants/#rd_kafka_resp_err__queue_full","text":"public RD_KAFKA_RESP_ERR__QUEUE_FULL = - 184 Queue is full See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__QUEUE_FULL"},{"location":"api/constants/#rd_kafka_resp_err__isr_insuff","text":"public RD_KAFKA_RESP_ERR__ISR_INSUFF = - 183 ISR count < required.acks See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__ISR_INSUFF"},{"location":"api/constants/#rd_kafka_resp_err__node_update","text":"public RD_KAFKA_RESP_ERR__NODE_UPDATE = - 182 Broker node update See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__NODE_UPDATE"},{"location":"api/constants/#rd_kafka_resp_err__ssl","text":"public RD_KAFKA_RESP_ERR__SSL = - 181 SSL error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__SSL"},{"location":"api/constants/#rd_kafka_resp_err__wait_coord","text":"public RD_KAFKA_RESP_ERR__WAIT_COORD = - 180 Waiting for coordinator to become available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__WAIT_COORD"},{"location":"api/constants/#rd_kafka_resp_err__unknown_group","text":"public RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = - 179 Unknown client group See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__UNKNOWN_GROUP"},{"location":"api/constants/#rd_kafka_resp_err__in_progress","text":"public RD_KAFKA_RESP_ERR__IN_PROGRESS = - 178 Operation in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err__prev_in_progress","text":"public RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = - 177 Previous operation in progress, wait for it to finish. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err__existing_subscription","text":"public RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = - 176 This operation would interfere with an existing subscription See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION"},{"location":"api/constants/#rd_kafka_resp_err__assign_partitions","text":"public RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = - 175 Assigned partitions (rebalance_cb) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS"},{"location":"api/constants/#rd_kafka_resp_err__revoke_partitions","text":"public RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = - 174 Revoked partitions (rebalance_cb) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS"},{"location":"api/constants/#rd_kafka_resp_err__conflict","text":"public RD_KAFKA_RESP_ERR__CONFLICT = - 173 Conflicting use See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__CONFLICT"},{"location":"api/constants/#rd_kafka_resp_err__state","text":"public RD_KAFKA_RESP_ERR__STATE = - 172 Wrong state See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__STATE"},{"location":"api/constants/#rd_kafka_resp_err__unknown_protocol","text":"public RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = - 171 Unknown protocol See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL"},{"location":"api/constants/#rd_kafka_resp_err__not_implemented","text":"public RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = - 170 Not implemented See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED"},{"location":"api/constants/#rd_kafka_resp_err__authentication","text":"public RD_KAFKA_RESP_ERR__AUTHENTICATION = - 169 Authentication failure See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__AUTHENTICATION"},{"location":"api/constants/#rd_kafka_resp_err__no_offset","text":"public RD_KAFKA_RESP_ERR__NO_OFFSET = - 168 No stored offset See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__NO_OFFSET"},{"location":"api/constants/#rd_kafka_resp_err__outdated","text":"public RD_KAFKA_RESP_ERR__OUTDATED = - 167 Outdated See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__OUTDATED"},{"location":"api/constants/#rd_kafka_resp_err__timed_out_queue","text":"public RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = - 166 Timed out in queue See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE"},{"location":"api/constants/#rd_kafka_resp_err__unsupported_feature","text":"public RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = - 165 Feature not supported by broker See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE"},{"location":"api/constants/#rd_kafka_resp_err__wait_cache","text":"public RD_KAFKA_RESP_ERR__WAIT_CACHE = - 164 Awaiting cache update See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__WAIT_CACHE"},{"location":"api/constants/#rd_kafka_resp_err__intr","text":"public RD_KAFKA_RESP_ERR__INTR = - 163 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__INTR"},{"location":"api/constants/#rd_kafka_resp_err__key_serialization","text":"public RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = - 162 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__KEY_SERIALIZATION"},{"location":"api/constants/#rd_kafka_resp_err__value_serialization","text":"public RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = - 161 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION"},{"location":"api/constants/#rd_kafka_resp_err__key_deserialization","text":"public RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = - 160 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION"},{"location":"api/constants/#rd_kafka_resp_err__value_deserialization","text":"public RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = - 159 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION"},{"location":"api/constants/#rd_kafka_resp_err__partial","text":"public RD_KAFKA_RESP_ERR__PARTIAL = - 158 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__PARTIAL"},{"location":"api/constants/#rd_kafka_resp_err__read_only","text":"public RD_KAFKA_RESP_ERR__READ_ONLY = - 157 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__READ_ONLY"},{"location":"api/constants/#rd_kafka_resp_err__noent","text":"public RD_KAFKA_RESP_ERR__NOENT = - 156 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__NOENT"},{"location":"api/constants/#rd_kafka_resp_err__underflow","text":"public RD_KAFKA_RESP_ERR__UNDERFLOW = - 155 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__UNDERFLOW"},{"location":"api/constants/#rd_kafka_resp_err__invalid_type","text":"public RD_KAFKA_RESP_ERR__INVALID_TYPE = - 154 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__INVALID_TYPE"},{"location":"api/constants/#rd_kafka_resp_err__retry","text":"public RD_KAFKA_RESP_ERR__RETRY = - 153 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__RETRY"},{"location":"api/constants/#rd_kafka_resp_err__purge_queue","text":"public RD_KAFKA_RESP_ERR__PURGE_QUEUE = - 152 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__PURGE_QUEUE"},{"location":"api/constants/#rd_kafka_resp_err__purge_inflight","text":"public RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = - 151 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__PURGE_INFLIGHT"},{"location":"api/constants/#rd_kafka_resp_err__fatal","text":"public RD_KAFKA_RESP_ERR__FATAL = - 150 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__FATAL"},{"location":"api/constants/#rd_kafka_resp_err__inconsistent","text":"public RD_KAFKA_RESP_ERR__INCONSISTENT = - 149 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__INCONSISTENT"},{"location":"api/constants/#rd_kafka_resp_err__gapless_guarantee","text":"public RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = - 148 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE"},{"location":"api/constants/#rd_kafka_resp_err__max_poll_exceeded","text":"public RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = - 147 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED"},{"location":"api/constants/#rd_kafka_resp_err__end","text":"public RD_KAFKA_RESP_ERR__END = - 100 End internal error codes See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR__END"},{"location":"api/constants/#rd_kafka_resp_err_unknown","text":"public RD_KAFKA_RESP_ERR_UNKNOWN = - 1 Unknown broker error See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNKNOWN"},{"location":"api/constants/#rd_kafka_resp_err_no_error","text":"public RD_KAFKA_RESP_ERR_NO_ERROR = 0 Success See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NO_ERROR"},{"location":"api/constants/#rd_kafka_resp_err_offset_out_of_range","text":"public RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1 Offset out of range See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE"},{"location":"api/constants/#rd_kafka_resp_err_invalid_msg","text":"public RD_KAFKA_RESP_ERR_INVALID_MSG = 2 Invalid message See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_MSG"},{"location":"api/constants/#rd_kafka_resp_err_unknown_topic_or_part","text":"public RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3 Unknown topic or partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART"},{"location":"api/constants/#rd_kafka_resp_err_invalid_msg_size","text":"public RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4 Invalid message size See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE"},{"location":"api/constants/#rd_kafka_resp_err_leader_not_available","text":"public RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5 Leader not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_not_leader_for_partition","text":"public RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6 Not leader for partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION"},{"location":"api/constants/#rd_kafka_resp_err_request_timed_out","text":"public RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7 Request timed out See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT"},{"location":"api/constants/#rd_kafka_resp_err_broker_not_available","text":"public RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8 Broker not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_replica_not_available","text":"public RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9 Replica not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_msg_size_too_large","text":"public RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10 Message size too large See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE"},{"location":"api/constants/#rd_kafka_resp_err_stale_ctrl_epoch","text":"public RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11 StaleControllerEpochCode See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_offset_metadata_too_large","text":"public RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12 Offset metadata string too large See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE"},{"location":"api/constants/#rd_kafka_resp_err_network_exception","text":"public RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13 Broker disconnected before response received See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION"},{"location":"api/constants/#rd_kafka_resp_err_group_load_in_progress","text":"public RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14 Group coordinator load in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err_group_coordinator_not_available","text":"public RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15 Group coordinator not available See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_not_coordinator_for_group","text":"public RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16 Not coordinator for group See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP"},{"location":"api/constants/#rd_kafka_resp_err_topic_exception","text":"public RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17 Invalid topic See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION"},{"location":"api/constants/#rd_kafka_resp_err_record_list_too_large","text":"public RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18 Message batch larger than configured server segment size See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE"},{"location":"api/constants/#rd_kafka_resp_err_not_enough_replicas","text":"public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19 Not enough in-sync replicas See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS"},{"location":"api/constants/#rd_kafka_resp_err_not_enough_replicas_after_append","text":"public RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20 Message(s) written to insufficient number of in-sync replicas See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND"},{"location":"api/constants/#rd_kafka_resp_err_invalid_required_acks","text":"public RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21 Invalid required acks value See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS"},{"location":"api/constants/#rd_kafka_resp_err_illegal_generation","text":"public RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22 Specified group generation id is not valid See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION"},{"location":"api/constants/#rd_kafka_resp_err_inconsistent_group_protocol","text":"public RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23 Inconsistent group protocol See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL"},{"location":"api/constants/#rd_kafka_resp_err_invalid_group_id","text":"public RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24 Invalid group.id See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_GROUP_ID"},{"location":"api/constants/#rd_kafka_resp_err_unknown_member_id","text":"public RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25 Unknown member See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID"},{"location":"api/constants/#rd_kafka_resp_err_invalid_session_timeout","text":"public RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26 Invalid session timeout See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT"},{"location":"api/constants/#rd_kafka_resp_err_rebalance_in_progress","text":"public RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27 Group rebalance in progress See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err_invalid_commit_offset_size","text":"public RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28 Commit offset data size is not valid See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE"},{"location":"api/constants/#rd_kafka_resp_err_topic_authorization_failed","text":"public RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29 Topic authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_group_authorization_failed","text":"public RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30 Group authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_cluster_authorization_failed","text":"public RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31 Cluster authorization failed See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_invalid_timestamp","text":"public RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32 Invalid timestamp See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_sasl_mechanism","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33 Unsupported SASL mechanism See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM"},{"location":"api/constants/#rd_kafka_resp_err_illegal_sasl_state","text":"public RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34 Illegal SASL state See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_version","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35 Unuspported version See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_topic_already_exists","text":"public RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36 Topic already exists See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS"},{"location":"api/constants/#rd_kafka_resp_err_invalid_partitions","text":"public RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37 Invalid number of partitions See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_PARTITIONS"},{"location":"api/constants/#rd_kafka_resp_err_invalid_replication_factor","text":"public RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38 Invalid replication factor See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR"},{"location":"api/constants/#rd_kafka_resp_err_invalid_replica_assignment","text":"public RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39 Invalid replica assignment See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT"},{"location":"api/constants/#rd_kafka_resp_err_invalid_config","text":"public RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40 Invalid config See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_CONFIG"},{"location":"api/constants/#rd_kafka_resp_err_not_controller","text":"public RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41 Not controller for cluster See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_NOT_CONTROLLER"},{"location":"api/constants/#rd_kafka_resp_err_invalid_request","text":"public RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42 Invalid request See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_INVALID_REQUEST"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_for_message_format","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43 Message format on broker does not support request See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT"},{"location":"api/constants/#rd_kafka_resp_err_policy_violation","text":"public RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_POLICY_VIOLATION"},{"location":"api/constants/#rd_kafka_resp_err_out_of_order_sequence_number","text":"public RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER"},{"location":"api/constants/#rd_kafka_resp_err_duplicate_sequence_number","text":"public RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER"},{"location":"api/constants/#rd_kafka_resp_err_invalid_producer_epoch","text":"public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_invalid_txn_state","text":"public RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_TXN_STATE"},{"location":"api/constants/#rd_kafka_resp_err_invalid_producer_id_mapping","text":"public RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING"},{"location":"api/constants/#rd_kafka_resp_err_invalid_transaction_timeout","text":"public RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT"},{"location":"api/constants/#rd_kafka_resp_err_concurrent_transactions","text":"public RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS"},{"location":"api/constants/#rd_kafka_resp_err_transaction_coordinator_fenced","text":"public RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED"},{"location":"api/constants/#rd_kafka_resp_err_transactional_id_authorization_failed","text":"public RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_security_disabled","text":"public RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_SECURITY_DISABLED"},{"location":"api/constants/#rd_kafka_resp_err_operation_not_attempted","text":"public RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED"},{"location":"api/constants/#rd_kafka_resp_err_kafka_storage_error","text":"public RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR"},{"location":"api/constants/#rd_kafka_resp_err_log_dir_not_found","text":"public RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_sasl_authentication_failed","text":"public RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_unknown_producer_id","text":"public RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID"},{"location":"api/constants/#rd_kafka_resp_err_reassignment_in_progress","text":"public RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_auth_disabled","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_not_found","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_owner_mismatch","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_request_not_allowed","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_authorization_failed","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_delegation_token_expired","text":"public RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED"},{"location":"api/constants/#rd_kafka_resp_err_invalid_principal_type","text":"public RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_non_empty_group","text":"public RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP"},{"location":"api/constants/#rd_kafka_resp_err_group_id_not_found","text":"public RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_fetch_session_id_not_found","text":"public RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_invalid_fetch_session_epoch","text":"public RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_listener_not_found","text":"public RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_topic_deletion_disabled","text":"public RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED"},{"location":"api/constants/#rd_kafka_vtype_end","text":"public RD_KAFKA_VTYPE_END = 0 va-arg sentinel See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165 https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_END"},{"location":"api/constants/#rd_kafka_vtype_topic","text":"public RD_KAFKA_VTYPE_TOPIC = 1 (const char *) Topic name See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_TOPIC"},{"location":"api/constants/#rd_kafka_vtype_rkt","text":"public RD_KAFKA_VTYPE_RKT = 2 (rd_kafka_topic_t *) Topic handle See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_RKT"},{"location":"api/constants/#rd_kafka_vtype_partition","text":"public RD_KAFKA_VTYPE_PARTITION = 3 (int32_t) Partition See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_PARTITION"},{"location":"api/constants/#rd_kafka_vtype_value","text":"public RD_KAFKA_VTYPE_VALUE = 4 (void *, size_t) Message value (payload) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_VALUE"},{"location":"api/constants/#rd_kafka_vtype_key","text":"public RD_KAFKA_VTYPE_KEY = 5 (void *, size_t) Message key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_KEY"},{"location":"api/constants/#rd_kafka_vtype_opaque","text":"public RD_KAFKA_VTYPE_OPAQUE = 6 (void *) Application opaque See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_OPAQUE"},{"location":"api/constants/#rd_kafka_vtype_msgflags","text":"public RD_KAFKA_VTYPE_MSGFLAGS = 7 (int) RD_KAFKA_MSG_F_.. flags See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_MSGFLAGS"},{"location":"api/constants/#rd_kafka_vtype_timestamp","text":"public RD_KAFKA_VTYPE_TIMESTAMP = 8 (int64_t) Milliseconds since epoch UTC See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b","title":"RD_KAFKA_VTYPE_TIMESTAMP"},{"location":"api/constants/#rd_kafka_vtype_header","text":"public RD_KAFKA_VTYPE_HEADER = 9 enum rd_kafka_vtype_t","title":"RD_KAFKA_VTYPE_HEADER"},{"location":"api/constants/#rd_kafka_vtype_headers","text":"public RD_KAFKA_VTYPE_HEADERS = 10 enum rd_kafka_vtype_t","title":"RD_KAFKA_VTYPE_HEADERS"},{"location":"api/constants/#rd_kafka_msg_status_not_persisted","text":"public RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0 enum rd_kafka_msg_status_t","title":"RD_KAFKA_MSG_STATUS_NOT_PERSISTED"},{"location":"api/constants/#rd_kafka_msg_status_possibly_persisted","text":"public RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1 enum rd_kafka_msg_status_t","title":"RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED"},{"location":"api/constants/#rd_kafka_msg_status_persisted","text":"public RD_KAFKA_MSG_STATUS_PERSISTED = 2 enum rd_kafka_msg_status_t","title":"RD_KAFKA_MSG_STATUS_PERSISTED"},{"location":"api/constants/#rd_kafka_conf_unknown","text":"public RD_KAFKA_CONF_UNKNOWN = - 2 Unknown configuration name. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4","title":"RD_KAFKA_CONF_UNKNOWN"},{"location":"api/constants/#rd_kafka_conf_invalid","text":"public RD_KAFKA_CONF_INVALID = - 1 Invalid configuration value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4","title":"RD_KAFKA_CONF_INVALID"},{"location":"api/constants/#rd_kafka_conf_ok","text":"public RD_KAFKA_CONF_OK = 0 Configuration okay See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4","title":"RD_KAFKA_CONF_OK"},{"location":"api/constants/#rd_kafka_admin_op_any","text":"public RD_KAFKA_ADMIN_OP_ANY = 0 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_ANY"},{"location":"api/constants/#rd_kafka_admin_op_createtopics","text":"public RD_KAFKA_ADMIN_OP_CREATETOPICS = 1 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_CREATETOPICS"},{"location":"api/constants/#rd_kafka_admin_op_deletetopics","text":"public RD_KAFKA_ADMIN_OP_DELETETOPICS = 2 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_DELETETOPICS"},{"location":"api/constants/#rd_kafka_admin_op_createpartitions","text":"public RD_KAFKA_ADMIN_OP_CREATEPARTITIONS = 3 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_CREATEPARTITIONS"},{"location":"api/constants/#rd_kafka_admin_op_alterconfigs","text":"public RD_KAFKA_ADMIN_OP_ALTERCONFIGS = 4 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_ALTERCONFIGS"},{"location":"api/constants/#rd_kafka_admin_op_describeconfigs","text":"public RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS = 5 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS"},{"location":"api/constants/#rd_kafka_config_source_unknown_config","text":"public RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG"},{"location":"api/constants/#rd_kafka_config_source_dynamic_topic_config","text":"public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG"},{"location":"api/constants/#rd_kafka_config_source_dynamic_broker_config","text":"public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG"},{"location":"api/constants/#rd_kafka_config_source_dynamic_default_broker_config","text":"public RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG"},{"location":"api/constants/#rd_kafka_config_source_static_broker_config","text":"public RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG"},{"location":"api/constants/#rd_kafka_config_source_default_config","text":"public RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG"},{"location":"api/constants/#rd_kafka_config_source__cnt","text":"public RD_KAFKA_CONFIG_SOURCE__CNT = 6 enum rd_kafka_ConfigSource_t","title":"RD_KAFKA_CONFIG_SOURCE__CNT"},{"location":"api/constants/#rd_kafka_resource_unknown","text":"public RD_KAFKA_RESOURCE_UNKNOWN = 0 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE_UNKNOWN"},{"location":"api/constants/#rd_kafka_resource_any","text":"public RD_KAFKA_RESOURCE_ANY = 1 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE_ANY"},{"location":"api/constants/#rd_kafka_resource_topic","text":"public RD_KAFKA_RESOURCE_TOPIC = 2 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE_TOPIC"},{"location":"api/constants/#rd_kafka_resource_group","text":"public RD_KAFKA_RESOURCE_GROUP = 3 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE_GROUP"},{"location":"api/constants/#rd_kafka_resource_broker","text":"public RD_KAFKA_RESOURCE_BROKER = 4 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE_BROKER"},{"location":"api/constants/#rd_kafka_resource__cnt","text":"public RD_KAFKA_RESOURCE__CNT = 5 enum rd_kafka_ResourceType_t","title":"RD_KAFKA_RESOURCE__CNT"},{"location":"api/constants/#rd_kafka_resp_err_fenced_leader_epoch","text":"public RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_unknown_leader_epoch","text":"public RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_stale_broker_epoch","text":"public RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH"},{"location":"api/constants/#rd_kafka_resp_err_offset_not_available","text":"public RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_member_id_required","text":"public RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED"},{"location":"api/constants/#rd_kafka_resp_err_preferred_leader_not_available","text":"public RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_group_max_size_reached","text":"public RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED"},{"location":"api/constants/#rd_kafka_event_oauthbearer_token_refresh","text":"public RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH = 256 define","title":"RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH"},{"location":"api/constants/#rd_kafka_cert_public_key","text":"public RD_KAFKA_CERT_PUBLIC_KEY = 0 enum rd_kafka_cert_type_t","title":"RD_KAFKA_CERT_PUBLIC_KEY"},{"location":"api/constants/#rd_kafka_cert_private_key","text":"public RD_KAFKA_CERT_PRIVATE_KEY = 1 enum rd_kafka_cert_type_t","title":"RD_KAFKA_CERT_PRIVATE_KEY"},{"location":"api/constants/#rd_kafka_cert_ca","text":"public RD_KAFKA_CERT_CA = 2 enum rd_kafka_cert_type_t","title":"RD_KAFKA_CERT_CA"},{"location":"api/constants/#rd_kafka_cert__cnt","text":"public RD_KAFKA_CERT__CNT = 3 enum rd_kafka_cert_type_t","title":"RD_KAFKA_CERT__CNT"},{"location":"api/constants/#rd_kafka_cert_enc_pkcs12","text":"public RD_KAFKA_CERT_ENC_PKCS12 = 0 enum rd_kafka_cert_enc_t","title":"RD_KAFKA_CERT_ENC_PKCS12"},{"location":"api/constants/#rd_kafka_cert_enc_der","text":"public RD_KAFKA_CERT_ENC_DER = 1 enum rd_kafka_cert_enc_t","title":"RD_KAFKA_CERT_ENC_DER"},{"location":"api/constants/#rd_kafka_cert_enc_pem","text":"public RD_KAFKA_CERT_ENC_PEM = 2 enum rd_kafka_cert_enc_t","title":"RD_KAFKA_CERT_ENC_PEM"},{"location":"api/constants/#rd_kafka_cert_enc__cnt","text":"public RD_KAFKA_CERT_ENC__CNT = 3 enum rd_kafka_cert_enc_t","title":"RD_KAFKA_CERT_ENC__CNT"},{"location":"api/constants/#rd_kafka_thread_main","text":"public RD_KAFKA_THREAD_MAIN = 0 enum rd_kafka_thread_type_t","title":"RD_KAFKA_THREAD_MAIN"},{"location":"api/constants/#rd_kafka_thread_background","text":"public RD_KAFKA_THREAD_BACKGROUND = 1 enum rd_kafka_thread_type_t","title":"RD_KAFKA_THREAD_BACKGROUND"},{"location":"api/constants/#rd_kafka_thread_broker","text":"public RD_KAFKA_THREAD_BROKER = 2 enum rd_kafka_thread_type_t","title":"RD_KAFKA_THREAD_BROKER"},{"location":"api/constants/#rd_kafka_resp_err__unknown_broker","text":"public RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = - 146 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__UNKNOWN_BROKER"},{"location":"api/constants/#rd_kafka_resp_err_coordinator_load_in_progress","text":"public RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err_coordinator_not_available","text":"public RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_not_coordinator","text":"public RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_NOT_COORDINATOR"},{"location":"api/constants/#rd_kafka_resp_err__not_configured","text":"public RD_KAFKA_RESP_ERR__NOT_CONFIGURED = - 145 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__NOT_CONFIGURED"},{"location":"api/constants/#rd_kafka_resp_err__fenced","text":"public RD_KAFKA_RESP_ERR__FENCED = - 144 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__FENCED"},{"location":"api/constants/#rd_kafka_resp_err__application","text":"public RD_KAFKA_RESP_ERR__APPLICATION = - 143 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__APPLICATION"},{"location":"api/constants/#rd_kafka_resp_err_fenced_instance_id","text":"public RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID"},{"location":"api/constants/#rd_kafka_resp_err_eligible_leaders_not_available","text":"public RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE"},{"location":"api/constants/#rd_kafka_resp_err_election_not_needed","text":"public RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED"},{"location":"api/constants/#rd_kafka_resp_err_no_reassignment_in_progress","text":"public RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS"},{"location":"api/constants/#rd_kafka_resp_err_group_subscribed_to_topic","text":"public RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC"},{"location":"api/constants/#rd_kafka_resp_err_invalid_record","text":"public RD_KAFKA_RESP_ERR_INVALID_RECORD = 87 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_RECORD"},{"location":"api/constants/#rd_kafka_resp_err_unstable_offset_commit","text":"public RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT"},{"location":"api/constants/#rd_kafka_event_deleterecords_result","text":"public RD_KAFKA_EVENT_DELETERECORDS_RESULT = 105 define","title":"RD_KAFKA_EVENT_DELETERECORDS_RESULT"},{"location":"api/constants/#rd_kafka_event_deletegroups_result","text":"public RD_KAFKA_EVENT_DELETEGROUPS_RESULT = 106 define","title":"RD_KAFKA_EVENT_DELETEGROUPS_RESULT"},{"location":"api/constants/#rd_kafka_event_deleteconsumergroupoffsets_result","text":"public RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT = 107 define","title":"RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT"},{"location":"api/constants/#rd_kafka_resp_err__assignment_lost","text":"public RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = - 142 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST"},{"location":"api/constants/#rd_kafka_resp_err__noop","text":"public RD_KAFKA_RESP_ERR__NOOP = - 141 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__NOOP"},{"location":"api/constants/#rd_kafka_resp_err_throttling_quota_exceeded","text":"public RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED"},{"location":"api/constants/#rd_kafka_resp_err_producer_fenced","text":"public RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_PRODUCER_FENCED"},{"location":"api/constants/#rd_kafka_resp_err_resource_not_found","text":"public RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND"},{"location":"api/constants/#rd_kafka_resp_err_duplicate_resource","text":"public RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE"},{"location":"api/constants/#rd_kafka_resp_err_unacceptable_credential","text":"public RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL"},{"location":"api/constants/#rd_kafka_resp_err_inconsistent_voter_set","text":"public RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET"},{"location":"api/constants/#rd_kafka_resp_err_invalid_update_version","text":"public RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_feature_update_failed","text":"public RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED"},{"location":"api/constants/#rd_kafka_resp_err_principal_deserialization_failure","text":"public RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE"},{"location":"api/constants/#rd_kafka_admin_op_deleterecords","text":"public RD_KAFKA_ADMIN_OP_DELETERECORDS = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_DELETERECORDS"},{"location":"api/constants/#rd_kafka_admin_op_deletegroups","text":"public RD_KAFKA_ADMIN_OP_DELETEGROUPS = 7 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_DELETEGROUPS"},{"location":"api/constants/#rd_kafka_admin_op_deleteconsumergroupoffsets","text":"public RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS = 8 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS"},{"location":"api/constants/#rd_kafka_resp_err__auto_offset_reset","text":"public RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = - 140 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET"},{"location":"api/constants/#rd_kafka_supported_methods","text":"public RD_KAFKA_SUPPORTED_METHODS = [ 'rd_kafka_version' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_version_str' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_debug_contexts' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_err_descs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_err2str' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_err2name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_last_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_errno2err' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_errno' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_fatal_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_test_fatal_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_add_range' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_del' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_del_by_idx' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_copy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_set_offset' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_find' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_list_sort' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_headers_copy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_remove' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get_last' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_get_all' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_timestamp' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_latency' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_detach_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_set_headers' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_header_cnt' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_message_status' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dup_filter' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_events' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_background_event_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_dr_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_dr_msg_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_consume_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_rebalance_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_offset_commit_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_error_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_throttle_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_log_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_stats_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_socket_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_connect_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_closesocket_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_default_topic_conf' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_get' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_dump_free' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_properties_show' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_default_topic_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_partitioner_cb' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_conf_set_msg_order_cmp' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_partition_available' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_consistent' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_consistent_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_murmur2' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_murmur2_random' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_destroy_flags' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_memberid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_clusterid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_controllerid' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_yield' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_pause_partitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_resume_partitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_query_watermark_offsets' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_get_watermark_offsets' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offsets_for_times' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_free' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_main' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_consumer' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_partition' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_get_background' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_forward' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_log_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_length' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_io_event_enable' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_cb_event_enable' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_start' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_start_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_stop' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_seek' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_batch' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_callback' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_batch_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consume_callback_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offset_store' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_offsets_store' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_subscribe' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_unsubscribe' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_subscription' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_close' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_assign' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_message' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_queue' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_committed' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_position' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_produce' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_producev' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_produce_batch' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_flush' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_purge' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_metadata' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_metadata_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_list_groups' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_group_list_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_brokers_add' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_logger' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_set_log_level' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_log_print' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_log_syslog' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_outq_len' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_dump' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_thread_cnt' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_wait_destroyed' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_unittest' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_poll_set_consumer' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_next' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_message_count' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_error_is_fatal' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_log' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_stats' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_topic_partition_list' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_topic_partition' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_CreateTopics_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteTopics_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_CreatePartitions_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_AlterConfigs_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DescribeConfigs_result' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_poll' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_poll_callback' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_plugin_f_conf_init_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_set_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_dup_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_conf_destroy_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_new_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_destroy_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_send_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_acknowledgement_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_consume_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_commit_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_request_sent_t' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_set' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_dup' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_conf_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_interceptor_add_on_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_send' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_acknowledgement' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_consume' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_commit' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_request_sent' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_topic_result_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_request_timeout' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_operation_timeout' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_validate_only' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_broker' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AdminOptions_set_opaque' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_set_replica_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewTopic_set_config' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreateTopics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreateTopics_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopic_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteTopics_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_NewPartitions_set_replica_assignment' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreatePartitions' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_CreatePartitions_result_topics' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigSource_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_value' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_source' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_read_only' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_default' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_sensitive' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_is_synonym' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigEntry_synonyms' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ResourceType_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_new' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_destroy' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_destroy_array' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_set_config' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_configs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_type' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_name' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_error' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_ConfigResource_error_string' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AlterConfigs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_AlterConfigs_result_resources' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DescribeConfigs' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_DescribeConfigs_result_resources' => [ 'min' => '1.0.0' , 'max' => '1.8.2' ], 'rd_kafka_conf' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_oauthbearer_token_refresh_cb' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_ssl_cert_verify_cb' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_ssl_cert' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_event_config_string' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_oauthbearer_set_token' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_oauthbearer_set_token_failure' => [ 'min' => '1.1.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_thread_start_t' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_thread_exit_t' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_thread_start' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_thread_exit' => [ 'min' => '1.2.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_new' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_destroy' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_handle' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_cluster_bootstraps' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_push_request_errors' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_topic_set_error' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_leader' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_follower' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_partition_set_follower_wmarks' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_rack' => [ 'min' => '1.3.0' , 'max' => '1.8.2' ], 'rd_kafka_error_code' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_name' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_string' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_is_fatal' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_is_retriable' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_txn_requires_abort' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_destroy' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_error_new' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_fnv1a' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_msg_partitioner_fnv1a_random' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_new' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_destroy' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_write' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_read' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_init_transactions' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_begin_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_send_offsets_to_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_commit_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_abort_transaction' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_handle_mock_cluster' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_topic_create' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_down' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_up' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_coordinator_set' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_set_apiversion' => [ 'min' => '1.4.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_set_rtt' => [ 'min' => '1.4.4' , 'max' => '1.8.2' ], 'rd_kafka_message_errstr' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_message_broker_id' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_produceva' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_event_debug_contexts' => [ 'min' => '1.5.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_push_request_errors' => [ 'min' => '1.5.0' , 'max' => '1.6.1' ], 'rd_kafka_conf_get_default_topic_conf' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_queue_yield' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_seek_partitions' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_incremental_assign' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_incremental_unassign' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_rebalance_protocol' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_assignment_lost' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_consumer_group_metadata_new_with_genid' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteRecords_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteGroups_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_event_DeleteConsumerGroupOffsets_result' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_error' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_name' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_group_result_partitions' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteRecords_result_offsets' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroup_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteGroups_result_groups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_new' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_destroy' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_destroy_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_DeleteConsumerGroupOffsets_result_groups' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_clear_request_errors' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_push_request_errors_array' => [ 'min' => '1.6.0' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_f_on_response_received_t' => [ 'min' => '1.6.1' , 'max' => '1.8.2' ], 'rd_kafka_interceptor_add_on_response_received' => [ 'min' => '1.6.1' , 'max' => '1.8.2' ], 'rd_kafka_conf_set_engine_callback_data' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_calloc' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mem_malloc' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ], 'rd_kafka_mock_broker_push_request_error_rtts' => [ 'min' => '1.7.0' , 'max' => '1.8.2' ]]","title":"RD_KAFKA_SUPPORTED_METHODS"},{"location":"api/constants/#rd_kafka_version","text":"public RD_KAFKA_VERSION = 16777471 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all","text":"public RD_KAFKA_RESP_ERR_END_ALL = 75 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 74, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_1","text":"public RD_KAFKA_VERSION = 16777727 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_1","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_1","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_1","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_1","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_2","text":"public RD_KAFKA_VERSION = 16843007 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_2","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_2","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_2","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_2","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *opaque), void *opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *opaque), void *opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_3","text":"public RD_KAFKA_VERSION = 16908543 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_3","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_3","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_3","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_3","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_4","text":"public RD_KAFKA_VERSION = 16908799 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_4","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_4","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_4","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_4","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_5","text":"public RD_KAFKA_VERSION = 16909055 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_5","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_5","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_5","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_5","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_6","text":"public RD_KAFKA_VERSION = 16974079 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_6","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_6","text":"public RD_KAFKA_RESP_ERR_END_ALL = 82 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_6","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_6","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_7","text":"public RD_KAFKA_VERSION = 17039615 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_7","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_7","text":"public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_7","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_7","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_8","text":"public RD_KAFKA_VERSION = 17040127 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_8","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_8","text":"public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_8","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_8","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_9","text":"public RD_KAFKA_VERSION = 17040639 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_9","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_9","text":"public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_9","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_9","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_10","text":"public RD_KAFKA_VERSION = 17105151 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_10","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_10","text":"public RD_KAFKA_RESP_ERR_END_ALL = 83 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_10","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_10","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_11","text":"public RD_KAFKA_VERSION = 17105663 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_11","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_11","text":"public RD_KAFKA_RESP_ERR_END_ALL = 89 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_11","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_11","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_12","text":"public RD_KAFKA_VERSION = 17105919 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_12","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_12","text":"public RD_KAFKA_RESP_ERR_END_ALL = 89 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_12","text":"public RD_KAFKA_ADMIN_OP__CNT = 6 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_12","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_13","text":"public RD_KAFKA_VERSION = 17170687 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_13","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_13","text":"public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_13","text":"public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_13","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_14","text":"public RD_KAFKA_VERSION = 17170943 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_14","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_14","text":"public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_14","text":"public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_14","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_15","text":"public RD_KAFKA_VERSION = 17236223 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_15","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_15","text":"public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_15","text":"public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_15","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_16","text":"public RD_KAFKA_VERSION = 17301759 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_16","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_16","text":"public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_16","text":"public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_16","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/constants/#rd_kafka_version_17","text":"public RD_KAFKA_VERSION = 17302271 librdkafka version Interpreted as hex MM.mm.rr.xx : MM = Major mm = minor rr = revision xx = pre-release id (0xff is the final release) E.g.: 0x000801ff = 0.8.1 Remarks This value should only be used during compile time, for runtime checks of version use rd_kafka_version() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e","title":"RD_KAFKA_VERSION"},{"location":"api/constants/#rd_kafka_resp_err_unsupported_compression_type_17","text":"public RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE"},{"location":"api/constants/#rd_kafka_resp_err_end_all_17","text":"public RD_KAFKA_RESP_ERR_END_ALL = 98 enum rd_kafka_resp_err_t","title":"RD_KAFKA_RESP_ERR_END_ALL"},{"location":"api/constants/#rd_kafka_admin_op__cnt_17","text":"public RD_KAFKA_ADMIN_OP__CNT = 9 enum rd_kafka_admin_op_t","title":"RD_KAFKA_ADMIN_OP__CNT"},{"location":"api/constants/#rd_kafka_cdef_17","text":"public RD_KAFKA_CDEF = 'typedef long int ssize_t; typedef struct _IO_FILE FILE; typedef long int mode_t; typedef signed int int16_t; typedef signed int int32_t; typedef signed long int int64_t; int rd_kafka_version(void); const char *rd_kafka_version_str(void); typedef enum rd_kafka_type_t { RD_KAFKA_PRODUCER, RD_KAFKA_CONSUMER, } rd_kafka_type_t; typedef enum rd_kafka_timestamp_type_t { RD_KAFKA_TIMESTAMP_NOT_AVAILABLE, RD_KAFKA_TIMESTAMP_CREATE_TIME, RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME, } rd_kafka_timestamp_type_t; const char *rd_kafka_get_debug_contexts(void); typedef struct rd_kafka_s rd_kafka_t; typedef struct rd_kafka_topic_s rd_kafka_topic_t; typedef struct rd_kafka_conf_s rd_kafka_conf_t; typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t; typedef struct rd_kafka_queue_s rd_kafka_queue_t; typedef struct rd_kafka_op_s rd_kafka_event_t; typedef struct rd_kafka_topic_result_s rd_kafka_topic_result_t; typedef struct rd_kafka_consumer_group_metadata_s rd_kafka_consumer_group_metadata_t; typedef struct rd_kafka_error_s { unsigned int code; char *errstr; unsigned char fatal; unsigned char retriable; unsigned char txn_requires_abort; } rd_kafka_error_t; typedef struct rd_kafka_headers_s rd_kafka_headers_t; typedef struct rd_kafka_group_result_s rd_kafka_group_result_t; typedef enum { RD_KAFKA_RESP_ERR__BEGIN = (- 200), RD_KAFKA_RESP_ERR__BAD_MSG = (- 199), RD_KAFKA_RESP_ERR__BAD_COMPRESSION = (- 198), RD_KAFKA_RESP_ERR__DESTROY = (- 197), RD_KAFKA_RESP_ERR__FAIL = (- 196), RD_KAFKA_RESP_ERR__TRANSPORT = (- 195), RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = (- 194), RD_KAFKA_RESP_ERR__RESOLVE = (- 193), RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = (- 192), RD_KAFKA_RESP_ERR__PARTITION_EOF = (- 191), RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = (- 190), RD_KAFKA_RESP_ERR__FS = (- 189), RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = (- 188), RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = (- 187), RD_KAFKA_RESP_ERR__INVALID_ARG = (- 186), RD_KAFKA_RESP_ERR__TIMED_OUT = (- 185), RD_KAFKA_RESP_ERR__QUEUE_FULL = (- 184), RD_KAFKA_RESP_ERR__ISR_INSUFF = (- 183), RD_KAFKA_RESP_ERR__NODE_UPDATE = (- 182), RD_KAFKA_RESP_ERR__SSL = (- 181), RD_KAFKA_RESP_ERR__WAIT_COORD = (- 180), RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = (- 179), RD_KAFKA_RESP_ERR__IN_PROGRESS = (- 178), RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = (- 177), RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = (- 176), RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = (- 175), RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = (- 174), RD_KAFKA_RESP_ERR__CONFLICT = (- 173), RD_KAFKA_RESP_ERR__STATE = (- 172), RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = (- 171), RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = (- 170), RD_KAFKA_RESP_ERR__AUTHENTICATION = (- 169), RD_KAFKA_RESP_ERR__NO_OFFSET = (- 168), RD_KAFKA_RESP_ERR__OUTDATED = (- 167), RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = (- 166), RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = (- 165), RD_KAFKA_RESP_ERR__WAIT_CACHE = (- 164), RD_KAFKA_RESP_ERR__INTR = (- 163), RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = (- 162), RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = (- 161), RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = (- 160), RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = (- 159), RD_KAFKA_RESP_ERR__PARTIAL = (- 158), RD_KAFKA_RESP_ERR__READ_ONLY = (- 157), RD_KAFKA_RESP_ERR__NOENT = (- 156), RD_KAFKA_RESP_ERR__UNDERFLOW = (- 155), RD_KAFKA_RESP_ERR__INVALID_TYPE = (- 154), RD_KAFKA_RESP_ERR__RETRY = (- 153), RD_KAFKA_RESP_ERR__PURGE_QUEUE = (- 152), RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = (- 151), RD_KAFKA_RESP_ERR__FATAL = (- 150), RD_KAFKA_RESP_ERR__INCONSISTENT = (- 149), RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = (- 148), RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = (- 147), RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = (- 146), RD_KAFKA_RESP_ERR__NOT_CONFIGURED = (- 145), RD_KAFKA_RESP_ERR__FENCED = (- 144), RD_KAFKA_RESP_ERR__APPLICATION = (- 143), RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = (- 142), RD_KAFKA_RESP_ERR__NOOP = (- 141), RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = (- 140), RD_KAFKA_RESP_ERR__END = (- 100), RD_KAFKA_RESP_ERR_UNKNOWN = (- 1), RD_KAFKA_RESP_ERR_NO_ERROR = 0, RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1, RD_KAFKA_RESP_ERR_INVALID_MSG = 2, RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3, RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5, RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6, RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7, RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8, RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9, RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10, RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11, RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12, RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13, RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14, RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15, RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16, RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17, RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19, RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20, RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21, RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22, RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23, RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24, RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25, RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26, RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27, RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28, RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29, RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30, RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31, RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32, RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33, RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34, RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35, RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36, RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37, RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38, RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39, RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40, RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41, RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42, RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43, RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44, RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45, RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47, RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48, RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49, RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50, RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51, RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52, RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53, RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54, RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55, RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56, RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57, RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58, RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59, RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65, RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66, RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67, RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68, RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69, RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70, RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71, RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72, RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73, RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74, RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75, RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76, RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77, RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78, RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79, RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80, RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81, RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82, RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83, RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84, RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85, RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86, RD_KAFKA_RESP_ERR_INVALID_RECORD = 87, RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88, RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89, RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90, RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91, RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92, RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93, RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94, RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95, RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96, RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97, RD_KAFKA_RESP_ERR_END_ALL, } rd_kafka_resp_err_t; struct rd_kafka_err_desc { rd_kafka_resp_err_t code; char *name; char *desc; }; void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs, size_t *cntp); const char *rd_kafka_err2str(rd_kafka_resp_err_t err); const char *rd_kafka_err2name(rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_last_error(void); rd_kafka_resp_err_t rd_kafka_errno2err(int errnox); int rd_kafka_errno(void); rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_test_fatal_error(rd_kafka_t *rk, rd_kafka_resp_err_t err, const char *reason); rd_kafka_resp_err_t rd_kafka_error_code(const rd_kafka_error_t *error); const char *rd_kafka_error_name(const rd_kafka_error_t *error); const char *rd_kafka_error_string(const rd_kafka_error_t *error); int rd_kafka_error_is_fatal(const rd_kafka_error_t *error); int rd_kafka_error_is_retriable(const rd_kafka_error_t *error); int rd_kafka_error_txn_requires_abort(const rd_kafka_error_t *error); void rd_kafka_error_destroy(rd_kafka_error_t *error); rd_kafka_error_t *rd_kafka_error_new(rd_kafka_resp_err_t code, const char *fmt, ...); typedef struct rd_kafka_topic_partition_s { char *topic; int32_t partition; int64_t offset; void *metadata; size_t metadata_size; void *opaque; rd_kafka_resp_err_t err; void *_private; } rd_kafka_topic_partition_t; void rd_kafka_topic_partition_destroy(rd_kafka_topic_partition_t *rktpar); typedef struct rd_kafka_topic_partition_list_s { int cnt; int size; rd_kafka_topic_partition_t *elems; } rd_kafka_topic_partition_list_t; rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_new(int size); void rd_kafka_topic_partition_list_destroy(rd_kafka_topic_partition_list_t *rkparlist); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_add(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_add_range(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop); int rd_kafka_topic_partition_list_del(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); int rd_kafka_topic_partition_list_del_by_idx(rd_kafka_topic_partition_list_t *rktparlist, int idx); rd_kafka_topic_partition_list_t *rd_kafka_topic_partition_list_copy(const rd_kafka_topic_partition_list_t *src); rd_kafka_resp_err_t rd_kafka_topic_partition_list_set_offset(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset); rd_kafka_topic_partition_t *rd_kafka_topic_partition_list_find(const rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition); void rd_kafka_topic_partition_list_sort(rd_kafka_topic_partition_list_t *rktparlist, int (*cmp)(const void *a, const void *b, void *cmp_opaque), void *cmp_opaque); typedef enum rd_kafka_vtype_t { RD_KAFKA_VTYPE_END, RD_KAFKA_VTYPE_TOPIC, RD_KAFKA_VTYPE_RKT, RD_KAFKA_VTYPE_PARTITION, RD_KAFKA_VTYPE_VALUE, RD_KAFKA_VTYPE_KEY, RD_KAFKA_VTYPE_OPAQUE, RD_KAFKA_VTYPE_MSGFLAGS, RD_KAFKA_VTYPE_TIMESTAMP, RD_KAFKA_VTYPE_HEADER, RD_KAFKA_VTYPE_HEADERS, } rd_kafka_vtype_t; typedef struct rd_kafka_vu_s { rd_kafka_vtype_t vtype; union { char *cstr; rd_kafka_topic_t *rkt; int i; int32_t i32; int64_t i64; struct { void *ptr; size_t size; } mem; struct { char *name; void *val; ssize_t size; } header; rd_kafka_headers_t *headers; void *ptr; char _pad[64]; } u; } rd_kafka_vu_t; rd_kafka_headers_t *rd_kafka_headers_new(size_t initial_count); void rd_kafka_headers_destroy(rd_kafka_headers_t *hdrs); rd_kafka_headers_t *rd_kafka_headers_copy(const rd_kafka_headers_t *src); rd_kafka_resp_err_t rd_kafka_header_add(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size); rd_kafka_resp_err_t rd_kafka_header_remove(rd_kafka_headers_t *hdrs, const char *name); rd_kafka_resp_err_t rd_kafka_header_get_last(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep); rd_kafka_resp_err_t rd_kafka_header_get_all(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep); typedef struct rd_kafka_message_s { rd_kafka_resp_err_t err; rd_kafka_topic_t *rkt; int32_t partition; void *payload; size_t len; void *key; size_t key_len; int64_t offset; void *_private; } rd_kafka_message_t; void rd_kafka_message_destroy(rd_kafka_message_t *rkmessage); const char *rd_kafka_message_errstr(const rd_kafka_message_t *rkmessage); int64_t rd_kafka_message_timestamp(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype); int64_t rd_kafka_message_latency(const rd_kafka_message_t *rkmessage); int32_t rd_kafka_message_broker_id(const rd_kafka_message_t *rkmessage); rd_kafka_resp_err_t rd_kafka_message_headers(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); rd_kafka_resp_err_t rd_kafka_message_detach_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp); void rd_kafka_message_set_headers(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs); size_t rd_kafka_header_cnt(const rd_kafka_headers_t *hdrs); typedef enum { RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0, RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1, RD_KAFKA_MSG_STATUS_PERSISTED = 2, } rd_kafka_msg_status_t; rd_kafka_msg_status_t rd_kafka_message_status(const rd_kafka_message_t *rkmessage); typedef enum { RD_KAFKA_CONF_UNKNOWN = (- 2), RD_KAFKA_CONF_INVALID = (- 1), RD_KAFKA_CONF_OK = 0, } rd_kafka_conf_res_t; rd_kafka_conf_t *rd_kafka_conf_new(void); void rd_kafka_conf_destroy(rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup(const rd_kafka_conf_t *conf); rd_kafka_conf_t *rd_kafka_conf_dup_filter(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter); const rd_kafka_conf_t *rd_kafka_conf(rd_kafka_t *rk); rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_conf_set_events(rd_kafka_conf_t *conf, int events); void rd_kafka_conf_set_background_event_cb(rd_kafka_conf_t *conf, void (*event_cb)(rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque)); void rd_kafka_conf_set_dr_cb(rd_kafka_conf_t *conf, void (*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque)); void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf, void (*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_consume_cb(rd_kafka_conf_t *conf, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque)); void rd_kafka_conf_set_rebalance_cb(rd_kafka_conf_t *conf, void (*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque)); void rd_kafka_conf_set_offset_commit_cb(rd_kafka_conf_t *conf, void (*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque)); void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf, void (*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque)); void rd_kafka_conf_set_throttle_cb(rd_kafka_conf_t *conf, void (*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)); void rd_kafka_conf_set_log_cb(rd_kafka_conf_t *conf, void (*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_conf_set_stats_cb(rd_kafka_conf_t *conf, int (*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)); void rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf, void (*oauthbearer_token_refresh_cb)(rd_kafka_t *rk, const char *oauthbearer_config, void *opaque)); void rd_kafka_conf_set_socket_cb(rd_kafka_conf_t *conf, int (*socket_cb)(int domain, int type, int protocol, void *opaque)); void rd_kafka_conf_set_connect_cb(rd_kafka_conf_t *conf, int (*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)); void rd_kafka_conf_set_closesocket_cb(rd_kafka_conf_t *conf, int (*closesocket_cb)(int sockfd, void *opaque)); rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb(rd_kafka_conf_t *conf, int (*ssl_cert_verify_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int *x509_error, int depth, const char *buf, size_t size, char *errstr, size_t errstr_size, void *opaque)); typedef enum rd_kafka_cert_type_t { RD_KAFKA_CERT_PUBLIC_KEY, RD_KAFKA_CERT_PRIVATE_KEY, RD_KAFKA_CERT_CA, RD_KAFKA_CERT__CNT, } rd_kafka_cert_type_t; typedef enum rd_kafka_cert_enc_t { RD_KAFKA_CERT_ENC_PKCS12, RD_KAFKA_CERT_ENC_DER, RD_KAFKA_CERT_ENC_PEM, RD_KAFKA_CERT_ENC__CNT, } rd_kafka_cert_enc_t; rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert(rd_kafka_conf_t *conf, rd_kafka_cert_type_t cert_type, rd_kafka_cert_enc_t cert_enc, const void *buffer, size_t size, char *errstr, size_t errstr_size); void rd_kafka_conf_set_engine_callback_data(rd_kafka_conf_t *conf, void *callback_data); void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf, void *opaque); void *rd_kafka_opaque(const rd_kafka_t *rk); void rd_kafka_conf_set_default_topic_conf(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf); rd_kafka_topic_conf_t *rd_kafka_conf_get_default_topic_conf(rd_kafka_conf_t *conf); rd_kafka_conf_res_t rd_kafka_conf_get(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size); rd_kafka_conf_res_t rd_kafka_topic_conf_get(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size); const char **rd_kafka_conf_dump(rd_kafka_conf_t *conf, size_t *cntp); const char **rd_kafka_topic_conf_dump(rd_kafka_topic_conf_t *conf, size_t *cntp); void rd_kafka_conf_dump_free(const char **arr, size_t cnt); void rd_kafka_conf_properties_show(FILE *fp); rd_kafka_topic_conf_t *rd_kafka_topic_conf_new(void); rd_kafka_topic_conf_t *rd_kafka_topic_conf_dup(const rd_kafka_topic_conf_t *conf); rd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup(rd_kafka_t *rk); void rd_kafka_topic_conf_destroy(rd_kafka_topic_conf_t *topic_conf); rd_kafka_conf_res_t rd_kafka_topic_conf_set(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size); void rd_kafka_topic_conf_set_opaque(rd_kafka_topic_conf_t *conf, void *rkt_opaque); void rd_kafka_topic_conf_set_partitioner_cb(rd_kafka_topic_conf_t *topic_conf, int32_t (*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)); void rd_kafka_topic_conf_set_msg_order_cmp(rd_kafka_topic_conf_t *topic_conf, int (*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b)); int rd_kafka_topic_partition_available(const rd_kafka_topic_t *rkt, int32_t partition); int32_t rd_kafka_msg_partitioner_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_consistent_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_murmur2_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); int32_t rd_kafka_msg_partitioner_fnv1a_random(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque); rd_kafka_t *rd_kafka_new(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size); void rd_kafka_destroy(rd_kafka_t *rk); void rd_kafka_destroy_flags(rd_kafka_t *rk, int flags); const char *rd_kafka_name(const rd_kafka_t *rk); rd_kafka_type_t rd_kafka_type(const rd_kafka_t *rk); char *rd_kafka_memberid(const rd_kafka_t *rk); char *rd_kafka_clusterid(rd_kafka_t *rk, int timeout_ms); int32_t rd_kafka_controllerid(rd_kafka_t *rk, int timeout_ms); rd_kafka_topic_t *rd_kafka_topic_new(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf); void rd_kafka_topic_destroy(rd_kafka_topic_t *rkt); const char *rd_kafka_topic_name(const rd_kafka_topic_t *rkt); void *rd_kafka_topic_opaque(const rd_kafka_topic_t *rkt); int rd_kafka_poll(rd_kafka_t *rk, int timeout_ms); void rd_kafka_yield(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_pause_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_resume_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_query_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms); rd_kafka_resp_err_t rd_kafka_get_watermark_offsets(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high); rd_kafka_resp_err_t rd_kafka_offsets_for_times(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms); void *rd_kafka_mem_calloc(rd_kafka_t *rk, size_t num, size_t size); void *rd_kafka_mem_malloc(rd_kafka_t *rk, size_t size); void rd_kafka_mem_free(rd_kafka_t *rk, void *ptr); rd_kafka_queue_t *rd_kafka_queue_new(rd_kafka_t *rk); void rd_kafka_queue_destroy(rd_kafka_queue_t *rkqu); rd_kafka_queue_t *rd_kafka_queue_get_main(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_consumer(rd_kafka_t *rk); rd_kafka_queue_t *rd_kafka_queue_get_partition(rd_kafka_t *rk, const char *topic, int32_t partition); rd_kafka_queue_t *rd_kafka_queue_get_background(rd_kafka_t *rk); void rd_kafka_queue_forward(rd_kafka_queue_t *src, rd_kafka_queue_t *dst); rd_kafka_resp_err_t rd_kafka_set_log_queue(rd_kafka_t *rk, rd_kafka_queue_t *rkqu); size_t rd_kafka_queue_length(rd_kafka_queue_t *rkqu); void rd_kafka_queue_io_event_enable(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size); void rd_kafka_queue_cb_event_enable(rd_kafka_queue_t *rkqu, void (*event_cb)(rd_kafka_t *rk, void *qev_opaque), void *qev_opaque); void rd_kafka_queue_yield(rd_kafka_queue_t *rkqu); int rd_kafka_consume_start(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); int rd_kafka_consume_start_queue(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu); int rd_kafka_consume_stop(rd_kafka_topic_t *rkt, int32_t partition); rd_kafka_resp_err_t rd_kafka_seek(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms); rd_kafka_error_t *rd_kafka_seek_partitions(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_message_t *rd_kafka_consume(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms); ssize_t rd_kafka_consume_batch(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_message_t *rd_kafka_consume_queue(rd_kafka_queue_t *rkqu, int timeout_ms); ssize_t rd_kafka_consume_batch_queue(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size); int rd_kafka_consume_callback_queue(rd_kafka_queue_t *rkqu, int timeout_ms, void (*consume_cb)(rd_kafka_message_t *rkmessage, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_offset_store(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset); rd_kafka_resp_err_t rd_kafka_offsets_store(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets); rd_kafka_resp_err_t rd_kafka_subscribe(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics); rd_kafka_resp_err_t rd_kafka_unsubscribe(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_subscription(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics); rd_kafka_message_t *rd_kafka_consumer_poll(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_consumer_close(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_incremental_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_error_t *rd_kafka_incremental_unassign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); const char *rd_kafka_rebalance_protocol(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_assign(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions); rd_kafka_resp_err_t rd_kafka_assignment(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions); int rd_kafka_assignment_lost(rd_kafka_t *rk); rd_kafka_resp_err_t rd_kafka_commit(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async); rd_kafka_resp_err_t rd_kafka_commit_message(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async); rd_kafka_resp_err_t rd_kafka_commit_queue(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void (*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque), void *commit_opaque); rd_kafka_resp_err_t rd_kafka_committed(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms); rd_kafka_resp_err_t rd_kafka_position(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata(rd_kafka_t *rk); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new(const char *group_id); rd_kafka_consumer_group_metadata_t *rd_kafka_consumer_group_metadata_new_with_genid(const char *group_id, int32_t generation_id, const char *member_id, const char *group_instance_id); void rd_kafka_consumer_group_metadata_destroy(rd_kafka_consumer_group_metadata_t *); rd_kafka_error_t *rd_kafka_consumer_group_metadata_write(const rd_kafka_consumer_group_metadata_t *cgmd, void **bufferp, size_t *sizep); rd_kafka_error_t *rd_kafka_consumer_group_metadata_read(rd_kafka_consumer_group_metadata_t **cgmdp, const void *buffer, size_t size); int rd_kafka_produce(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque); rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk, ...); rd_kafka_error_t *rd_kafka_produceva(rd_kafka_t *rk, const rd_kafka_vu_t *vus, size_t cnt); int rd_kafka_produce_batch(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt); rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms); rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags); typedef struct rd_kafka_metadata_broker { int32_t id; char *host; int port; } rd_kafka_metadata_broker_t; typedef struct rd_kafka_metadata_partition { int32_t id; rd_kafka_resp_err_t err; int32_t leader; int replica_cnt; int32_t *replicas; int isr_cnt; int32_t *isrs; } rd_kafka_metadata_partition_t; typedef struct rd_kafka_metadata_topic { char *topic; int partition_cnt; struct rd_kafka_metadata_partition *partitions; rd_kafka_resp_err_t err; } rd_kafka_metadata_topic_t; typedef struct rd_kafka_metadata { int broker_cnt; struct rd_kafka_metadata_broker *brokers; int topic_cnt; struct rd_kafka_metadata_topic *topics; int32_t orig_broker_id; char *orig_broker_name; } rd_kafka_metadata_t; rd_kafka_resp_err_t rd_kafka_metadata(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms); void rd_kafka_metadata_destroy(const struct rd_kafka_metadata *metadata); struct rd_kafka_group_member_info { char *member_id; char *client_id; char *client_host; void *member_metadata; int member_metadata_size; void *member_assignment; int member_assignment_size; }; struct rd_kafka_group_info { struct rd_kafka_metadata_broker broker; char *group; rd_kafka_resp_err_t err; char *state; char *protocol_type; char *protocol; struct rd_kafka_group_member_info *members; int member_cnt; }; struct rd_kafka_group_list { struct rd_kafka_group_info *groups; int group_cnt; }; rd_kafka_resp_err_t rd_kafka_list_groups(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms); void rd_kafka_group_list_destroy(const struct rd_kafka_group_list *grplist); int rd_kafka_brokers_add(rd_kafka_t *rk, const char *brokerlist); void rd_kafka_set_logger(rd_kafka_t *rk, void (*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)); void rd_kafka_set_log_level(rd_kafka_t *rk, int level); void rd_kafka_log_print(const rd_kafka_t *rk, int level, const char *fac, const char *buf); void rd_kafka_log_syslog(const rd_kafka_t *rk, int level, const char *fac, const char *buf); int rd_kafka_outq_len(rd_kafka_t *rk); void rd_kafka_dump(FILE *fp, rd_kafka_t *rk); int rd_kafka_thread_cnt(void); typedef enum rd_kafka_thread_type_t { RD_KAFKA_THREAD_MAIN, RD_KAFKA_THREAD_BACKGROUND, RD_KAFKA_THREAD_BROKER, } rd_kafka_thread_type_t; int rd_kafka_wait_destroyed(int timeout_ms); int rd_kafka_unittest(void); rd_kafka_resp_err_t rd_kafka_poll_set_consumer(rd_kafka_t *rk); typedef int rd_kafka_event_type_t; rd_kafka_event_type_t rd_kafka_event_type(const rd_kafka_event_t *rkev); const char *rd_kafka_event_name(const rd_kafka_event_t *rkev); void rd_kafka_event_destroy(rd_kafka_event_t *rkev); const rd_kafka_message_t *rd_kafka_event_message_next(rd_kafka_event_t *rkev); size_t rd_kafka_event_message_array(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size); size_t rd_kafka_event_message_count(rd_kafka_event_t *rkev); const char *rd_kafka_event_config_string(rd_kafka_event_t *rkev); rd_kafka_resp_err_t rd_kafka_event_error(rd_kafka_event_t *rkev); const char *rd_kafka_event_error_string(rd_kafka_event_t *rkev); int rd_kafka_event_error_is_fatal(rd_kafka_event_t *rkev); void *rd_kafka_event_opaque(rd_kafka_event_t *rkev); int rd_kafka_event_log(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level); int rd_kafka_event_debug_contexts(rd_kafka_event_t *rkev, char *dst, size_t dstsize); const char *rd_kafka_event_stats(rd_kafka_event_t *rkev); rd_kafka_topic_partition_list_t *rd_kafka_event_topic_partition_list(rd_kafka_event_t *rkev); rd_kafka_topic_partition_t *rd_kafka_event_topic_partition(rd_kafka_event_t *rkev); typedef rd_kafka_event_t rd_kafka_CreateTopics_result_t; typedef rd_kafka_event_t rd_kafka_DeleteTopics_result_t; typedef rd_kafka_event_t rd_kafka_CreatePartitions_result_t; typedef rd_kafka_event_t rd_kafka_AlterConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DescribeConfigs_result_t; typedef rd_kafka_event_t rd_kafka_DeleteRecords_result_t; typedef rd_kafka_event_t rd_kafka_DeleteGroups_result_t; typedef rd_kafka_event_t rd_kafka_DeleteConsumerGroupOffsets_result_t; const rd_kafka_CreateTopics_result_t *rd_kafka_event_CreateTopics_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteTopics_result_t *rd_kafka_event_DeleteTopics_result(rd_kafka_event_t *rkev); const rd_kafka_CreatePartitions_result_t *rd_kafka_event_CreatePartitions_result(rd_kafka_event_t *rkev); const rd_kafka_AlterConfigs_result_t *rd_kafka_event_AlterConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DescribeConfigs_result_t *rd_kafka_event_DescribeConfigs_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteRecords_result_t *rd_kafka_event_DeleteRecords_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteGroups_result_t *rd_kafka_event_DeleteGroups_result(rd_kafka_event_t *rkev); const rd_kafka_DeleteConsumerGroupOffsets_result_t *rd_kafka_event_DeleteConsumerGroupOffsets_result(rd_kafka_event_t *rkev); rd_kafka_event_t *rd_kafka_queue_poll(rd_kafka_queue_t *rkqu, int timeout_ms); int rd_kafka_queue_poll_callback(rd_kafka_queue_t *rkqu, int timeout_ms); typedef rd_kafka_resp_err_t (rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size); typedef rd_kafka_conf_res_t (rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_request_sent_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_response_received_t)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, int64_t rtt, rd_kafka_resp_err_t err, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_start_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); typedef rd_kafka_resp_err_t (rd_kafka_interceptor_f_on_thread_exit_t)(rd_kafka_t *rk, rd_kafka_thread_type_t thread_type, const char *thread_name, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_response_received_t *on_response_received, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_start_t *on_thread_start, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_thread_exit_t *on_thread_exit, void *ic_opaque); rd_kafka_resp_err_t rd_kafka_topic_result_error(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_error_string(const rd_kafka_topic_result_t *topicres); const char *rd_kafka_topic_result_name(const rd_kafka_topic_result_t *topicres); const rd_kafka_error_t *rd_kafka_group_result_error(const rd_kafka_group_result_t *groupres); const char *rd_kafka_group_result_name(const rd_kafka_group_result_t *groupres); const rd_kafka_topic_partition_list_t *rd_kafka_group_result_partitions(const rd_kafka_group_result_t *groupres); typedef enum rd_kafka_admin_op_t { RD_KAFKA_ADMIN_OP_ANY = 0, RD_KAFKA_ADMIN_OP_CREATETOPICS, RD_KAFKA_ADMIN_OP_DELETETOPICS, RD_KAFKA_ADMIN_OP_CREATEPARTITIONS, RD_KAFKA_ADMIN_OP_ALTERCONFIGS, RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS, RD_KAFKA_ADMIN_OP_DELETERECORDS, RD_KAFKA_ADMIN_OP_DELETEGROUPS, RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS, RD_KAFKA_ADMIN_OP__CNT, } rd_kafka_admin_op_t; typedef struct rd_kafka_AdminOptions_s rd_kafka_AdminOptions_t; rd_kafka_AdminOptions_t *rd_kafka_AdminOptions_new(rd_kafka_t *rk, rd_kafka_admin_op_t for_api); void rd_kafka_AdminOptions_destroy(rd_kafka_AdminOptions_t *options); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout(rd_kafka_AdminOptions_t *options, int timeout_ms, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only(rd_kafka_AdminOptions_t *options, int true_or_false, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker(rd_kafka_AdminOptions_t *options, int32_t broker_id, char *errstr, size_t errstr_size); void rd_kafka_AdminOptions_set_opaque(rd_kafka_AdminOptions_t *options, void *ev_opaque); typedef struct rd_kafka_NewTopic_s rd_kafka_NewTopic_t; rd_kafka_NewTopic_t *rd_kafka_NewTopic_new(const char *topic, int num_partitions, int replication_factor, char *errstr, size_t errstr_size); void rd_kafka_NewTopic_destroy(rd_kafka_NewTopic_t *new_topic); void rd_kafka_NewTopic_destroy_array(rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt); rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment(rd_kafka_NewTopic_t *new_topic, int32_t partition, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_NewTopic_set_config(rd_kafka_NewTopic_t *new_topic, const char *name, const char *value); void rd_kafka_CreateTopics(rd_kafka_t *rk, rd_kafka_NewTopic_t **new_topics, size_t new_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreateTopics_result_topics(const rd_kafka_CreateTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteTopic_s rd_kafka_DeleteTopic_t; rd_kafka_DeleteTopic_t *rd_kafka_DeleteTopic_new(const char *topic); void rd_kafka_DeleteTopic_destroy(rd_kafka_DeleteTopic_t *del_topic); void rd_kafka_DeleteTopic_destroy_array(rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt); void rd_kafka_DeleteTopics(rd_kafka_t *rk, rd_kafka_DeleteTopic_t **del_topics, size_t del_topic_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_DeleteTopics_result_topics(const rd_kafka_DeleteTopics_result_t *result, size_t *cntp); typedef struct rd_kafka_NewPartitions_s rd_kafka_NewPartitions_t; rd_kafka_NewPartitions_t *rd_kafka_NewPartitions_new(const char *topic, size_t new_total_cnt, char *errstr, size_t errstr_size); void rd_kafka_NewPartitions_destroy(rd_kafka_NewPartitions_t *new_parts); void rd_kafka_NewPartitions_destroy_array(rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt); rd_kafka_resp_err_t rd_kafka_NewPartitions_set_replica_assignment(rd_kafka_NewPartitions_t *new_parts, int32_t new_partition_idx, int32_t *broker_ids, size_t broker_id_cnt, char *errstr, size_t errstr_size); void rd_kafka_CreatePartitions(rd_kafka_t *rk, rd_kafka_NewPartitions_t **new_parts, size_t new_parts_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_result_t **rd_kafka_CreatePartitions_result_topics(const rd_kafka_CreatePartitions_result_t *result, size_t *cntp); typedef enum rd_kafka_ConfigSource_t { RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2, RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3, RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4, RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5, RD_KAFKA_CONFIG_SOURCE__CNT, } rd_kafka_ConfigSource_t; const char *rd_kafka_ConfigSource_name(rd_kafka_ConfigSource_t confsource); typedef struct rd_kafka_ConfigEntry_s rd_kafka_ConfigEntry_t; const char *rd_kafka_ConfigEntry_name(const rd_kafka_ConfigEntry_t *entry); const char *rd_kafka_ConfigEntry_value(const rd_kafka_ConfigEntry_t *entry); rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_source(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_read_only(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_default(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_sensitive(const rd_kafka_ConfigEntry_t *entry); int rd_kafka_ConfigEntry_is_synonym(const rd_kafka_ConfigEntry_t *entry); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigEntry_synonyms(const rd_kafka_ConfigEntry_t *entry, size_t *cntp); typedef enum rd_kafka_ResourceType_t { RD_KAFKA_RESOURCE_UNKNOWN = 0, RD_KAFKA_RESOURCE_ANY = 1, RD_KAFKA_RESOURCE_TOPIC = 2, RD_KAFKA_RESOURCE_GROUP = 3, RD_KAFKA_RESOURCE_BROKER = 4, RD_KAFKA_RESOURCE__CNT, } rd_kafka_ResourceType_t; const char *rd_kafka_ResourceType_name(rd_kafka_ResourceType_t restype); typedef struct rd_kafka_ConfigResource_s rd_kafka_ConfigResource_t; rd_kafka_ConfigResource_t *rd_kafka_ConfigResource_new(rd_kafka_ResourceType_t restype, const char *resname); void rd_kafka_ConfigResource_destroy(rd_kafka_ConfigResource_t *config); void rd_kafka_ConfigResource_destroy_array(rd_kafka_ConfigResource_t **config, size_t config_cnt); rd_kafka_resp_err_t rd_kafka_ConfigResource_set_config(rd_kafka_ConfigResource_t *config, const char *name, const char *value); const rd_kafka_ConfigEntry_t **rd_kafka_ConfigResource_configs(const rd_kafka_ConfigResource_t *config, size_t *cntp); rd_kafka_ResourceType_t rd_kafka_ConfigResource_type(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_name(const rd_kafka_ConfigResource_t *config); rd_kafka_resp_err_t rd_kafka_ConfigResource_error(const rd_kafka_ConfigResource_t *config); const char *rd_kafka_ConfigResource_error_string(const rd_kafka_ConfigResource_t *config); void rd_kafka_AlterConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_AlterConfigs_result_resources(const rd_kafka_AlterConfigs_result_t *result, size_t *cntp); void rd_kafka_DescribeConfigs(rd_kafka_t *rk, rd_kafka_ConfigResource_t **configs, size_t config_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_ConfigResource_t **rd_kafka_DescribeConfigs_result_resources(const rd_kafka_DescribeConfigs_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteRecords_s rd_kafka_DeleteRecords_t; rd_kafka_DeleteRecords_t *rd_kafka_DeleteRecords_new(const rd_kafka_topic_partition_list_t *before_offsets); void rd_kafka_DeleteRecords_destroy(rd_kafka_DeleteRecords_t *del_records); void rd_kafka_DeleteRecords_destroy_array(rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt); void rd_kafka_DeleteRecords(rd_kafka_t *rk, rd_kafka_DeleteRecords_t **del_records, size_t del_record_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_topic_partition_list_t *rd_kafka_DeleteRecords_result_offsets(const rd_kafka_DeleteRecords_result_t *result); typedef struct rd_kafka_DeleteGroup_s rd_kafka_DeleteGroup_t; rd_kafka_DeleteGroup_t *rd_kafka_DeleteGroup_new(const char *group); void rd_kafka_DeleteGroup_destroy(rd_kafka_DeleteGroup_t *del_group); void rd_kafka_DeleteGroup_destroy_array(rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt); void rd_kafka_DeleteGroups(rd_kafka_t *rk, rd_kafka_DeleteGroup_t **del_groups, size_t del_group_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteGroups_result_groups(const rd_kafka_DeleteGroups_result_t *result, size_t *cntp); typedef struct rd_kafka_DeleteConsumerGroupOffsets_s rd_kafka_DeleteConsumerGroupOffsets_t; rd_kafka_DeleteConsumerGroupOffsets_t *rd_kafka_DeleteConsumerGroupOffsets_new(const char *group, const rd_kafka_topic_partition_list_t *partitions); void rd_kafka_DeleteConsumerGroupOffsets_destroy(rd_kafka_DeleteConsumerGroupOffsets_t *del_grpoffsets); void rd_kafka_DeleteConsumerGroupOffsets_destroy_array(rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffset_cnt); void rd_kafka_DeleteConsumerGroupOffsets(rd_kafka_t *rk, rd_kafka_DeleteConsumerGroupOffsets_t **del_grpoffsets, size_t del_grpoffsets_cnt, const rd_kafka_AdminOptions_t *options, rd_kafka_queue_t *rkqu); const rd_kafka_group_result_t **rd_kafka_DeleteConsumerGroupOffsets_result_groups(const rd_kafka_DeleteConsumerGroupOffsets_result_t *result, size_t *cntp); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token(rd_kafka_t *rk, const char *token_value, int64_t md_lifetime_ms, const char *md_principal_name, const char **extensions, size_t extension_size, char *errstr, size_t errstr_size); rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure(rd_kafka_t *rk, const char *errstr); rd_kafka_error_t *rd_kafka_init_transactions(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_begin_transaction(rd_kafka_t *rk); rd_kafka_error_t *rd_kafka_send_offsets_to_transaction(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, const rd_kafka_consumer_group_metadata_t *cgmetadata, int timeout_ms); rd_kafka_error_t *rd_kafka_commit_transaction(rd_kafka_t *rk, int timeout_ms); rd_kafka_error_t *rd_kafka_abort_transaction(rd_kafka_t *rk, int timeout_ms); typedef struct rd_kafka_mock_cluster_s rd_kafka_mock_cluster_t; rd_kafka_mock_cluster_t *rd_kafka_mock_cluster_new(rd_kafka_t *rk, int broker_cnt); void rd_kafka_mock_cluster_destroy(rd_kafka_mock_cluster_t *mcluster); rd_kafka_t *rd_kafka_mock_cluster_handle(const rd_kafka_mock_cluster_t *mcluster); rd_kafka_mock_cluster_t *rd_kafka_handle_mock_cluster(const rd_kafka_t *rk); const char *rd_kafka_mock_cluster_bootstraps(const rd_kafka_mock_cluster_t *mcluster); void rd_kafka_mock_clear_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey); void rd_kafka_mock_push_request_errors(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_push_request_errors_array(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, size_t cnt, const rd_kafka_resp_err_t *errors); rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_error_rtts(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int16_t ApiKey, size_t cnt, ...); void rd_kafka_mock_topic_set_error(rd_kafka_mock_cluster_t *mcluster, const char *topic, rd_kafka_resp_err_t err); rd_kafka_resp_err_t rd_kafka_mock_topic_create(rd_kafka_mock_cluster_t *mcluster, const char *topic, int partition_cnt, int replication_factor); rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks(rd_kafka_mock_cluster_t *mcluster, const char *topic, int32_t partition, int64_t lo, int64_t hi); rd_kafka_resp_err_t rd_kafka_mock_broker_set_down(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_up(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, int rtt_ms); rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack(rd_kafka_mock_cluster_t *mcluster, int32_t broker_id, const char *rack); rd_kafka_resp_err_t rd_kafka_mock_coordinator_set(rd_kafka_mock_cluster_t *mcluster, const char *key_type, const char *key, int32_t broker_id); rd_kafka_resp_err_t rd_kafka_mock_set_apiversion(rd_kafka_mock_cluster_t *mcluster, int16_t ApiKey, int16_t MinVersion, int16_t MaxVersion); ' rdkafka.h, rdkafka_mock.h","title":"RD_KAFKA_CDEF"},{"location":"api/functions/","text":"Functions \u00b6 rd_kafka_err2name \u00b6 \\rd_kafka_err2name () ( int $err ) : string Parameters err int Error code Returns string The error name as a string. rd_kafka_err2str \u00b6 \\rd_kafka_err2str () ( int $err ) : string Parameters err int Error code Returns string The error description a string. rd_kafka_errno2err \u00b6 \\rd_kafka_errno2err () ( int $errnox ) : int Parameters errnox int A system errno Returns int A kafka error code as an integer. Deprecated rd_kafka_errno \u00b6 \\rd_kafka_errno () ( ) : int Returns int The system errno as an integer. Deprecated rd_kafka_offset_tail \u00b6 \\rd_kafka_offset_tail () ( int $cnt ) : int Parameters cnt int Returns int Returns the special offset as an integer. rd_kafka_thread_cnt \u00b6 \\rd_kafka_thread_cnt () ( ) : int Returns int Retrieve the current number of threads in use by librdkafka. rd_kafka_version \u00b6 \\rd_kafka_version () ( ) : string Returns string The librdkafka version.","title":"Functions"},{"location":"api/functions/#functions","text":"","title":"Functions"},{"location":"api/functions/#rd_kafka_err2name","text":"\\rd_kafka_err2name () ( int $err ) : string Parameters err int Error code Returns string The error name as a string.","title":"rd_kafka_err2name"},{"location":"api/functions/#rd_kafka_err2str","text":"\\rd_kafka_err2str () ( int $err ) : string Parameters err int Error code Returns string The error description a string.","title":"rd_kafka_err2str"},{"location":"api/functions/#rd_kafka_errno2err","text":"\\rd_kafka_errno2err () ( int $errnox ) : int Parameters errnox int A system errno Returns int A kafka error code as an integer. Deprecated","title":"rd_kafka_errno2err"},{"location":"api/functions/#rd_kafka_errno","text":"\\rd_kafka_errno () ( ) : int Returns int The system errno as an integer. Deprecated","title":"rd_kafka_errno"},{"location":"api/functions/#rd_kafka_offset_tail","text":"\\rd_kafka_offset_tail () ( int $cnt ) : int Parameters cnt int Returns int Returns the special offset as an integer.","title":"rd_kafka_offset_tail"},{"location":"api/functions/#rd_kafka_thread_cnt","text":"\\rd_kafka_thread_cnt () ( ) : int Returns int Retrieve the current number of threads in use by librdkafka.","title":"rd_kafka_thread_cnt"},{"location":"api/functions/#rd_kafka_version","text":"\\rd_kafka_version () ( ) : string Returns string The librdkafka version.","title":"rd_kafka_version"},{"location":"api/RdKafka/Conf/","text":"Class Conf \u00b6 Class \\RdKafka\\Conf See also Configuration reference for librdkafka Methods \u00b6 __construct() \u00b6 public __construct ( ) : __destruct() \u00b6 public __destruct ( ) : dump() \u00b6 public dump ( ) : array Returns array get() \u00b6 public get ( string $name ) : string | null Parameters name string Returns string|null getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData set() \u00b6 public set ( string $name , string $value ) : void Setting non string values like callbacks or default_topic_conf TopicConf objects is not supported. For callbacks and default_topic_conf use corresponding methods directly. Parameters name string value string See also \\RdKafka\\Conf::setLogCb() \\RdKafka\\Conf::setErrorCb() \\RdKafka\\Conf::setOffsetCommitCb() \\RdKafka\\Conf::setRebalanceCb() \\RdKafka\\Conf::setStatsCb() \\RdKafka\\Conf::setDrMsgCb() \\RdKafka\\Conf::setDefaultTopicConf() setDefaultTopicConf() \u00b6 public setDefaultTopicConf ( \\RdKafka\\TopicConf $topic_conf ) : void Parameters topic_conf \\RdKafka\\TopicConf Deprecated Set custom TopicConf explicitly in Producer::newTopic() , Consumer::newTopic() or KafkaConsumer::newTopic() . Note: Topic config properties can be also set directly via Conf. See also \\RdKafka\\Producer::newTopic() \\RdKafka\\Consumer::newTopic() \\RdKafka\\KafkaConsumer::newTopic() setDrMsgCb() \u00b6 public setDrMsgCb ( callable $callback ) : void Parameters callback callable function(Producer $producer, Message $message, ?mixed $opaque = null) setErrorCb() \u00b6 public setErrorCb ( callable $callback ) : void Parameters callback callable function($consumerOrProducer, int $err, string $reason, ?mixed $opaque = null) setLogCb() \u00b6 public setLogCb ( ? callable $callback ) : void Parameters callback ?callable function($consumerOrProducer, int $level, string $facility, string $message) or null to disable logging setOffsetCommitCb() \u00b6 public setOffsetCommitCb ( callable $callback ) : void Parameters callback callable function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null) setOpaque() \u00b6 public setOpaque ( mixed $opaque ) : void Parameters opaque mixed setRebalanceCb() \u00b6 public setRebalanceCb ( callable $callback ) : void Parameters callback callable function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null) setStatsCb() \u00b6 public setStatsCb ( callable $callback ) : void Parameters callback callable function($consumerOrProducer, string $json, int $jsonLength, ?mixed $opaque = null) Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 94.2% (65 / 69) \ud83d\udc9b Methods: 85.71% (12 / 14)","title":"Conf"},{"location":"api/RdKafka/Conf/#class-conf","text":"Class \\RdKafka\\Conf See also Configuration reference for librdkafka","title":"Class Conf"},{"location":"api/RdKafka/Conf/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Conf/#__construct","text":"public __construct ( ) :","title":"__construct()"},{"location":"api/RdKafka/Conf/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Conf/#dump","text":"public dump ( ) : array Returns array","title":"dump()"},{"location":"api/RdKafka/Conf/#get","text":"public get ( string $name ) : string | null Parameters name string Returns string|null","title":"get()"},{"location":"api/RdKafka/Conf/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Conf/#set","text":"public set ( string $name , string $value ) : void Setting non string values like callbacks or default_topic_conf TopicConf objects is not supported. For callbacks and default_topic_conf use corresponding methods directly. Parameters name string value string See also \\RdKafka\\Conf::setLogCb() \\RdKafka\\Conf::setErrorCb() \\RdKafka\\Conf::setOffsetCommitCb() \\RdKafka\\Conf::setRebalanceCb() \\RdKafka\\Conf::setStatsCb() \\RdKafka\\Conf::setDrMsgCb() \\RdKafka\\Conf::setDefaultTopicConf()","title":"set()"},{"location":"api/RdKafka/Conf/#setdefaulttopicconf","text":"public setDefaultTopicConf ( \\RdKafka\\TopicConf $topic_conf ) : void Parameters topic_conf \\RdKafka\\TopicConf Deprecated Set custom TopicConf explicitly in Producer::newTopic() , Consumer::newTopic() or KafkaConsumer::newTopic() . Note: Topic config properties can be also set directly via Conf. See also \\RdKafka\\Producer::newTopic() \\RdKafka\\Consumer::newTopic() \\RdKafka\\KafkaConsumer::newTopic()","title":"setDefaultTopicConf()"},{"location":"api/RdKafka/Conf/#setdrmsgcb","text":"public setDrMsgCb ( callable $callback ) : void Parameters callback callable function(Producer $producer, Message $message, ?mixed $opaque = null)","title":"setDrMsgCb()"},{"location":"api/RdKafka/Conf/#seterrorcb","text":"public setErrorCb ( callable $callback ) : void Parameters callback callable function($consumerOrProducer, int $err, string $reason, ?mixed $opaque = null)","title":"setErrorCb()"},{"location":"api/RdKafka/Conf/#setlogcb","text":"public setLogCb ( ? callable $callback ) : void Parameters callback ?callable function($consumerOrProducer, int $level, string $facility, string $message) or null to disable logging","title":"setLogCb()"},{"location":"api/RdKafka/Conf/#setoffsetcommitcb","text":"public setOffsetCommitCb ( callable $callback ) : void Parameters callback callable function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null)","title":"setOffsetCommitCb()"},{"location":"api/RdKafka/Conf/#setopaque","text":"public setOpaque ( mixed $opaque ) : void Parameters opaque mixed","title":"setOpaque()"},{"location":"api/RdKafka/Conf/#setrebalancecb","text":"public setRebalanceCb ( callable $callback ) : void Parameters callback callable function(KafkaConsumer $consumer, int $err, array $topicPartitions, ?mixed $opaque = null)","title":"setRebalanceCb()"},{"location":"api/RdKafka/Conf/#setstatscb","text":"public setStatsCb ( callable $callback ) : void Parameters callback callable function($consumerOrProducer, string $json, int $jsonLength, ?mixed $opaque = null)","title":"setStatsCb()"},{"location":"api/RdKafka/Conf/#test-coverage","text":"\ud83d\udc9a Lines: 94.2% (65 / 69) \ud83d\udc9b Methods: 85.71% (12 / 14)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Consumer/","text":"Class Consumer \u00b6 Class \\RdKafka\\Consumer extends \\RdKafka Methods \u00b6 __construct() \u00b6 public __construct ( ? \\RdKafka\\Conf $conf = null ) : Parameters conf ? \\RdKafka\\Conf addBrokers() \u00b6 public addBrokers ( string $broker_list ) : int Parameters broker_list string Returns int getOutQLen() \u00b6 public getOutQLen ( ) : int Returns int newQueue() \u00b6 public newQueue ( ) : \\RdKafka\\Queue Returns \\RdKafka\\Queue newTopic() \u00b6 public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\ConsumerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\ConsumerTopic poll() \u00b6 public poll ( int $timeout_ms ) : int Parameters timeout_ms int Returns int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (6 / 6)","title":"Consumer"},{"location":"api/RdKafka/Consumer/#class-consumer","text":"Class \\RdKafka\\Consumer extends \\RdKafka","title":"Class Consumer"},{"location":"api/RdKafka/Consumer/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Consumer/#__construct","text":"public __construct ( ? \\RdKafka\\Conf $conf = null ) : Parameters conf ? \\RdKafka\\Conf","title":"__construct()"},{"location":"api/RdKafka/Consumer/#addbrokers","text":"public addBrokers ( string $broker_list ) : int Parameters broker_list string Returns int","title":"addBrokers()"},{"location":"api/RdKafka/Consumer/#getoutqlen","text":"public getOutQLen ( ) : int Returns int","title":"getOutQLen()"},{"location":"api/RdKafka/Consumer/#newqueue","text":"public newQueue ( ) : \\RdKafka\\Queue Returns \\RdKafka\\Queue","title":"newQueue()"},{"location":"api/RdKafka/Consumer/#newtopic","text":"public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\ConsumerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\ConsumerTopic","title":"newTopic()"},{"location":"api/RdKafka/Consumer/#poll","text":"public poll ( int $timeout_ms ) : int Parameters timeout_ms int Returns int","title":"poll()"},{"location":"api/RdKafka/Consumer/#test-coverage","text":"\ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (6 / 6)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/ConsumerTopic/","text":"Class ConsumerTopic \u00b6 Class \\RdKafka\\ConsumerTopic extends \\RdKafka\\Topic Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\Consumer $consumer , string $name , \\RdKafka\\TopicConf $conf = null ) : Parameters consumer \\RdKafka\\Consumer name string conf \\RdKafka\\TopicConf __destruct() \u00b6 public __destruct ( ) : consume() \u00b6 public consume ( int $partition , int $timeout_ms ) : ? \\RdKafka\\Message Parameters partition int timeout_ms int Returns ? \\RdKafka\\Message consumeBatch() \u00b6 public consumeBatch ( int $partition , int $timeout_ms , int $batch_size ) : \\RdKafka\\Message [] Parameters partition int timeout_ms int batch_size int Returns \\RdKafka\\Message [] consumeCallback() \u00b6 public consumeCallback ( int $partition , int $timeout_ms , callable $callback , mixed $opaque = null ) : int Parameters partition int timeout_ms int callback callable opaque mixed Returns int Deprecated since 1.4.0 librdkafka consumeQueueStart() \u00b6 public consumeQueueStart ( int $partition , int $offset , \\RdKafka\\Queue $queue ) : void Parameters partition int offset int queue \\RdKafka\\Queue consumeStart() \u00b6 public consumeStart ( int $partition , int $offset ) : void Parameters partition int offset int consumeStop() \u00b6 public consumeStop ( int $partition ) : void Parameters partition int offsetStore() \u00b6 public offsetStore ( int $partition , int $offset ) : void Parameters partition int offset int Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 78.85% (82 / 104) \u2764\ufe0f Methods: 27.27% (3 / 11)","title":"ConsumerTopic"},{"location":"api/RdKafka/ConsumerTopic/#class-consumertopic","text":"Class \\RdKafka\\ConsumerTopic extends \\RdKafka\\Topic","title":"Class ConsumerTopic"},{"location":"api/RdKafka/ConsumerTopic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/ConsumerTopic/#__construct","text":"public __construct ( \\RdKafka\\Consumer $consumer , string $name , \\RdKafka\\TopicConf $conf = null ) : Parameters consumer \\RdKafka\\Consumer name string conf \\RdKafka\\TopicConf","title":"__construct()"},{"location":"api/RdKafka/ConsumerTopic/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/ConsumerTopic/#consume","text":"public consume ( int $partition , int $timeout_ms ) : ? \\RdKafka\\Message Parameters partition int timeout_ms int Returns ? \\RdKafka\\Message","title":"consume()"},{"location":"api/RdKafka/ConsumerTopic/#consumebatch","text":"public consumeBatch ( int $partition , int $timeout_ms , int $batch_size ) : \\RdKafka\\Message [] Parameters partition int timeout_ms int batch_size int Returns \\RdKafka\\Message []","title":"consumeBatch()"},{"location":"api/RdKafka/ConsumerTopic/#consumecallback","text":"public consumeCallback ( int $partition , int $timeout_ms , callable $callback , mixed $opaque = null ) : int Parameters partition int timeout_ms int callback callable opaque mixed Returns int Deprecated since 1.4.0 librdkafka","title":"consumeCallback()"},{"location":"api/RdKafka/ConsumerTopic/#consumequeuestart","text":"public consumeQueueStart ( int $partition , int $offset , \\RdKafka\\Queue $queue ) : void Parameters partition int offset int queue \\RdKafka\\Queue","title":"consumeQueueStart()"},{"location":"api/RdKafka/ConsumerTopic/#consumestart","text":"public consumeStart ( int $partition , int $offset ) : void Parameters partition int offset int","title":"consumeStart()"},{"location":"api/RdKafka/ConsumerTopic/#consumestop","text":"public consumeStop ( int $partition ) : void Parameters partition int","title":"consumeStop()"},{"location":"api/RdKafka/ConsumerTopic/#offsetstore","text":"public offsetStore ( int $partition , int $offset ) : void Parameters partition int offset int","title":"offsetStore()"},{"location":"api/RdKafka/ConsumerTopic/#test-coverage","text":"\ud83d\udc9b Lines: 78.85% (82 / 104) \u2764\ufe0f Methods: 27.27% (3 / 11)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Event/","text":"Class Event \u00b6 Class \\RdKafka\\Event Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $event ) : Parameters event \\FFI\\CData __destruct() \u00b6 public __destruct ( ) : error() \u00b6 public error ( ) : int Returns int errorIsFatal() \u00b6 public errorIsFatal ( ) : bool Returns bool errorString() \u00b6 public errorString ( ) : string Returns string getCData() \u00b6 public getCData ( ) : mixed Returns mixed name() \u00b6 public name ( ) : string Returns string type() \u00b6 public type ( ) : int Returns int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 91.67% (11 / 12) \ud83d\udc9b Methods: 87.5% (7 / 8)","title":"Event"},{"location":"api/RdKafka/Event/#class-event","text":"Class \\RdKafka\\Event","title":"Class Event"},{"location":"api/RdKafka/Event/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Event/#__construct","text":"public __construct ( \\FFI\\CData $event ) : Parameters event \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Event/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Event/#error","text":"public error ( ) : int Returns int","title":"error()"},{"location":"api/RdKafka/Event/#errorisfatal","text":"public errorIsFatal ( ) : bool Returns bool","title":"errorIsFatal()"},{"location":"api/RdKafka/Event/#errorstring","text":"public errorString ( ) : string Returns string","title":"errorString()"},{"location":"api/RdKafka/Event/#getcdata","text":"public getCData ( ) : mixed Returns mixed","title":"getCData()"},{"location":"api/RdKafka/Event/#name","text":"public name ( ) : string Returns string","title":"name()"},{"location":"api/RdKafka/Event/#type","text":"public type ( ) : int Returns int","title":"type()"},{"location":"api/RdKafka/Event/#test-coverage","text":"\ud83d\udc9a Lines: 91.67% (11 / 12) \ud83d\udc9b Methods: 87.5% (7 / 8)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Exception/","text":"Class Exception \u00b6 Class \\RdKafka\\Exception extends \\Exception Methods \u00b6 __construct() \u00b6 public __construct ( mixed $message = '' , mixed $code , ? \\Throwable $previous = null ) : Parameters message mixed code mixed previous ?\\Throwable fromError() \u00b6 public static fromError ( int $code ) : self Parameters code int Returns self Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (3 / 3) \ud83d\udc9a Methods: 100% (2 / 2) Extended by \u00b6 \\RdKafka\\KafkaErrorException","title":"Exception"},{"location":"api/RdKafka/Exception/#class-exception","text":"Class \\RdKafka\\Exception extends \\Exception","title":"Class Exception"},{"location":"api/RdKafka/Exception/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Exception/#__construct","text":"public __construct ( mixed $message = '' , mixed $code , ? \\Throwable $previous = null ) : Parameters message mixed code mixed previous ?\\Throwable","title":"__construct()"},{"location":"api/RdKafka/Exception/#fromerror","text":"public static fromError ( int $code ) : self Parameters code int Returns self","title":"fromError()"},{"location":"api/RdKafka/Exception/#test-coverage","text":"\ud83d\udc9a Lines: 100% (3 / 3) \ud83d\udc9a Methods: 100% (2 / 2)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Exception/#extended-by","text":"\\RdKafka\\KafkaErrorException","title":"Extended by"},{"location":"api/RdKafka/KafkaConsumer/","text":"Class KafkaConsumer \u00b6 Class \\RdKafka\\KafkaConsumer extends \\RdKafka Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\Conf $conf ) : Parameters conf \\RdKafka\\Conf __destruct() \u00b6 public __destruct ( ) : assign() \u00b6 public assign ( \\RdKafka\\TopicPartition [] $topic_partitions = null ) : void Parameters topic_partitions \\RdKafka\\TopicPartition [] close() \u00b6 public close ( ) : void commit() \u00b6 public commit ( \\RdKafka\\Message | \\RdKafka\\TopicPartition [] | null $message_or_offsets = null ) : void Parameters message_or_offsets \\RdKafka\\Message | \\RdKafka\\TopicPartition []|null commitAsync() \u00b6 public commitAsync ( \\RdKafka\\Message | \\RdKafka\\TopicPartition [] | null $message_or_offsets = null ) : void Parameters message_or_offsets \\RdKafka\\Message | \\RdKafka\\TopicPartition []|null consume() \u00b6 public consume ( int $timeout_ms ) : \\RdKafka\\Message Parameters timeout_ms int Returns \\RdKafka\\Message getAssignment() \u00b6 public getAssignment ( ) : \\RdKafka\\TopicPartition [] Returns \\RdKafka\\TopicPartition [] getCommittedOffsets() \u00b6 public getCommittedOffsets ( \\RdKafka\\TopicPartition [] $topics , int $timeout_ms ) : \\RdKafka\\TopicPartition [] Parameters topics \\RdKafka\\TopicPartition [] timeout_ms int Returns \\RdKafka\\TopicPartition [] getSubscription() \u00b6 public getSubscription ( ) : array Returns array newTopic() \u00b6 public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\KafkaConsumerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\KafkaConsumerTopic offsetsForTimes() \u00b6 public offsetsForTimes ( \\RdKafka\\TopicPartition [] $topicPartitions , int $timeout_ms ) : \\RdKafka\\TopicPartition [] Parameters topicPartitions \\RdKafka\\TopicPartition [] timeout_ms int Returns \\RdKafka\\TopicPartition [] subscribe() \u00b6 public subscribe ( array $topics ) : void Parameters topics array unsubscribe() \u00b6 public unsubscribe ( ) : void Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 87.02% (114 / 131) \u2764\ufe0f Methods: 41.18% (7 / 17)","title":"KafkaConsumer"},{"location":"api/RdKafka/KafkaConsumer/#class-kafkaconsumer","text":"Class \\RdKafka\\KafkaConsumer extends \\RdKafka","title":"Class KafkaConsumer"},{"location":"api/RdKafka/KafkaConsumer/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/KafkaConsumer/#__construct","text":"public __construct ( \\RdKafka\\Conf $conf ) : Parameters conf \\RdKafka\\Conf","title":"__construct()"},{"location":"api/RdKafka/KafkaConsumer/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/KafkaConsumer/#assign","text":"public assign ( \\RdKafka\\TopicPartition [] $topic_partitions = null ) : void Parameters topic_partitions \\RdKafka\\TopicPartition []","title":"assign()"},{"location":"api/RdKafka/KafkaConsumer/#close","text":"public close ( ) : void","title":"close()"},{"location":"api/RdKafka/KafkaConsumer/#commit","text":"public commit ( \\RdKafka\\Message | \\RdKafka\\TopicPartition [] | null $message_or_offsets = null ) : void Parameters message_or_offsets \\RdKafka\\Message | \\RdKafka\\TopicPartition []|null","title":"commit()"},{"location":"api/RdKafka/KafkaConsumer/#commitasync","text":"public commitAsync ( \\RdKafka\\Message | \\RdKafka\\TopicPartition [] | null $message_or_offsets = null ) : void Parameters message_or_offsets \\RdKafka\\Message | \\RdKafka\\TopicPartition []|null","title":"commitAsync()"},{"location":"api/RdKafka/KafkaConsumer/#consume","text":"public consume ( int $timeout_ms ) : \\RdKafka\\Message Parameters timeout_ms int Returns \\RdKafka\\Message","title":"consume()"},{"location":"api/RdKafka/KafkaConsumer/#getassignment","text":"public getAssignment ( ) : \\RdKafka\\TopicPartition [] Returns \\RdKafka\\TopicPartition []","title":"getAssignment()"},{"location":"api/RdKafka/KafkaConsumer/#getcommittedoffsets","text":"public getCommittedOffsets ( \\RdKafka\\TopicPartition [] $topics , int $timeout_ms ) : \\RdKafka\\TopicPartition [] Parameters topics \\RdKafka\\TopicPartition [] timeout_ms int Returns \\RdKafka\\TopicPartition []","title":"getCommittedOffsets()"},{"location":"api/RdKafka/KafkaConsumer/#getsubscription","text":"public getSubscription ( ) : array Returns array","title":"getSubscription()"},{"location":"api/RdKafka/KafkaConsumer/#newtopic","text":"public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\KafkaConsumerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\KafkaConsumerTopic","title":"newTopic()"},{"location":"api/RdKafka/KafkaConsumer/#offsetsfortimes","text":"public offsetsForTimes ( \\RdKafka\\TopicPartition [] $topicPartitions , int $timeout_ms ) : \\RdKafka\\TopicPartition [] Parameters topicPartitions \\RdKafka\\TopicPartition [] timeout_ms int Returns \\RdKafka\\TopicPartition []","title":"offsetsForTimes()"},{"location":"api/RdKafka/KafkaConsumer/#subscribe","text":"public subscribe ( array $topics ) : void Parameters topics array","title":"subscribe()"},{"location":"api/RdKafka/KafkaConsumer/#unsubscribe","text":"public unsubscribe ( ) : void","title":"unsubscribe()"},{"location":"api/RdKafka/KafkaConsumer/#test-coverage","text":"\ud83d\udc9b Lines: 87.02% (114 / 131) \u2764\ufe0f Methods: 41.18% (7 / 17)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/KafkaConsumerTopic/","text":"Class KafkaConsumerTopic \u00b6 Class \\RdKafka\\KafkaConsumerTopic extends \\RdKafka\\Topic Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\KafkaConsumer $consumer , string $name , ? \\RdKafka\\TopicConf $conf = null ) : Parameters consumer \\RdKafka\\KafkaConsumer name string conf ? \\RdKafka\\TopicConf offsetStore() \u00b6 public offsetStore ( int $partition , int $offset ) : void Parameters partition int offset int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 90.91% (10 / 11) \u2764\ufe0f Methods: 50% (1 / 2)","title":"KafkaConsumerTopic"},{"location":"api/RdKafka/KafkaConsumerTopic/#class-kafkaconsumertopic","text":"Class \\RdKafka\\KafkaConsumerTopic extends \\RdKafka\\Topic","title":"Class KafkaConsumerTopic"},{"location":"api/RdKafka/KafkaConsumerTopic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/KafkaConsumerTopic/#__construct","text":"public __construct ( \\RdKafka\\KafkaConsumer $consumer , string $name , ? \\RdKafka\\TopicConf $conf = null ) : Parameters consumer \\RdKafka\\KafkaConsumer name string conf ? \\RdKafka\\TopicConf","title":"__construct()"},{"location":"api/RdKafka/KafkaConsumerTopic/#offsetstore","text":"public offsetStore ( int $partition , int $offset ) : void Parameters partition int offset int","title":"offsetStore()"},{"location":"api/RdKafka/KafkaConsumerTopic/#test-coverage","text":"\ud83d\udc9a Lines: 90.91% (10 / 11) \u2764\ufe0f Methods: 50% (1 / 2)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/KafkaErrorException/","text":"Class KafkaErrorException \u00b6 Class \\RdKafka\\KafkaErrorException extends \\RdKafka\\Exception Methods \u00b6 __construct() \u00b6 public __construct ( string $message , int $code , string $error_string , bool $isFatal = false , bool $isRetriable = false , bool $transactionRequiresAbort = false ) : Parameters message string code int error_string string isFatal bool isRetriable bool transactionRequiresAbort bool fromCData() \u00b6 public static fromCData ( \\FFI\\CData $error ) : mixed Parameters error \\FFI\\CData Returns mixed getErrorString() \u00b6 public getErrorString ( ) : string Returns string isFatal() \u00b6 public isFatal ( ) : bool Returns bool isRetriable() \u00b6 public isRetriable ( ) : bool Returns bool transactionRequiresAbort() \u00b6 public transactionRequiresAbort ( ) : bool Returns bool Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (18 / 18) \ud83d\udc9a Methods: 100% (6 / 6)","title":"KafkaErrorException"},{"location":"api/RdKafka/KafkaErrorException/#class-kafkaerrorexception","text":"Class \\RdKafka\\KafkaErrorException extends \\RdKafka\\Exception","title":"Class KafkaErrorException"},{"location":"api/RdKafka/KafkaErrorException/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/KafkaErrorException/#__construct","text":"public __construct ( string $message , int $code , string $error_string , bool $isFatal = false , bool $isRetriable = false , bool $transactionRequiresAbort = false ) : Parameters message string code int error_string string isFatal bool isRetriable bool transactionRequiresAbort bool","title":"__construct()"},{"location":"api/RdKafka/KafkaErrorException/#fromcdata","text":"public static fromCData ( \\FFI\\CData $error ) : mixed Parameters error \\FFI\\CData Returns mixed","title":"fromCData()"},{"location":"api/RdKafka/KafkaErrorException/#geterrorstring","text":"public getErrorString ( ) : string Returns string","title":"getErrorString()"},{"location":"api/RdKafka/KafkaErrorException/#isfatal","text":"public isFatal ( ) : bool Returns bool","title":"isFatal()"},{"location":"api/RdKafka/KafkaErrorException/#isretriable","text":"public isRetriable ( ) : bool Returns bool","title":"isRetriable()"},{"location":"api/RdKafka/KafkaErrorException/#transactionrequiresabort","text":"public transactionRequiresAbort ( ) : bool Returns bool","title":"transactionRequiresAbort()"},{"location":"api/RdKafka/KafkaErrorException/#test-coverage","text":"\ud83d\udc9a Lines: 100% (18 / 18) \ud83d\udc9a Methods: 100% (6 / 6)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Message/","text":"Class Message \u00b6 Class \\RdKafka\\Message Properties \u00b6 brokerId \u00b6 public int brokerId err \u00b6 public int err headers \u00b6 public ? array headers key \u00b6 public ? string key latency \u00b6 public int latency len \u00b6 public int len offset \u00b6 public int offset opaque \u00b6 public mixed | null opaque partition \u00b6 public int partition payload \u00b6 public ? string payload status \u00b6 public int status timestamp \u00b6 public int timestamp timestampType \u00b6 public int timestampType topic_name \u00b6 public ? string topic_name Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $nativeMessage ) : Parameters nativeMessage \\FFI\\CData errstr() \u00b6 public errstr ( ) : string Returns string Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 89.09% (49 / 55) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"Message"},{"location":"api/RdKafka/Message/#class-message","text":"Class \\RdKafka\\Message","title":"Class Message"},{"location":"api/RdKafka/Message/#properties","text":"","title":"Properties"},{"location":"api/RdKafka/Message/#brokerid","text":"public int brokerId","title":"brokerId"},{"location":"api/RdKafka/Message/#err","text":"public int err","title":"err"},{"location":"api/RdKafka/Message/#headers","text":"public ? array headers","title":"headers"},{"location":"api/RdKafka/Message/#key","text":"public ? string key","title":"key"},{"location":"api/RdKafka/Message/#latency","text":"public int latency","title":"latency"},{"location":"api/RdKafka/Message/#len","text":"public int len","title":"len"},{"location":"api/RdKafka/Message/#offset","text":"public int offset","title":"offset"},{"location":"api/RdKafka/Message/#opaque","text":"public mixed | null opaque","title":"opaque"},{"location":"api/RdKafka/Message/#partition","text":"public int partition","title":"partition"},{"location":"api/RdKafka/Message/#payload","text":"public ? string payload","title":"payload"},{"location":"api/RdKafka/Message/#status","text":"public int status","title":"status"},{"location":"api/RdKafka/Message/#timestamp","text":"public int timestamp","title":"timestamp"},{"location":"api/RdKafka/Message/#timestamptype","text":"public int timestampType","title":"timestampType"},{"location":"api/RdKafka/Message/#topic_name","text":"public ? string topic_name","title":"topic_name"},{"location":"api/RdKafka/Message/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Message/#__construct","text":"public __construct ( \\FFI\\CData $nativeMessage ) : Parameters nativeMessage \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Message/#errstr","text":"public errstr ( ) : string Returns string","title":"errstr()"},{"location":"api/RdKafka/Message/#test-coverage","text":"\ud83d\udc9b Lines: 89.09% (49 / 55) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Metadata/","text":"Class Metadata \u00b6 Class \\RdKafka\\Metadata Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka , bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : Parameters kafka \\RdKafka all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int __destruct() \u00b6 public __destruct ( ) : getBrokers() \u00b6 public getBrokers ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Broker [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Broker [] getOrigBrokerId() \u00b6 public getOrigBrokerId ( ) : int Returns int getOrigBrokerName() \u00b6 public getOrigBrokerName ( ) : string Returns string getTopics() \u00b6 public getTopics ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Topic [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Topic [] Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 94% (47 / 50) \ud83d\udc9b Methods: 81.82% (9 / 11)","title":"Metadata"},{"location":"api/RdKafka/Metadata/#class-metadata","text":"Class \\RdKafka\\Metadata","title":"Class Metadata"},{"location":"api/RdKafka/Metadata/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Metadata/#__construct","text":"public __construct ( \\RdKafka $kafka , bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : Parameters kafka \\RdKafka all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int","title":"__construct()"},{"location":"api/RdKafka/Metadata/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Metadata/#getbrokers","text":"public getBrokers ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Broker [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Broker []","title":"getBrokers()"},{"location":"api/RdKafka/Metadata/#getorigbrokerid","text":"public getOrigBrokerId ( ) : int Returns int","title":"getOrigBrokerId()"},{"location":"api/RdKafka/Metadata/#getorigbrokername","text":"public getOrigBrokerName ( ) : string Returns string","title":"getOrigBrokerName()"},{"location":"api/RdKafka/Metadata/#gettopics","text":"public getTopics ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Topic [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Topic []","title":"getTopics()"},{"location":"api/RdKafka/Metadata/#test-coverage","text":"\ud83d\udc9a Lines: 94% (47 / 50) \ud83d\udc9b Methods: 81.82% (9 / 11)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Producer/","text":"Class Producer \u00b6 Class \\RdKafka\\Producer extends \\RdKafka Methods \u00b6 __construct() \u00b6 public __construct ( ? \\RdKafka\\Conf $conf = null ) : Parameters conf ? \\RdKafka\\Conf abortTransaction() \u00b6 public abortTransaction ( int $timeout_ms ) : void Parameters timeout_ms int addBrokers() \u00b6 public addBrokers ( string $broker_list ) : int Parameters broker_list string Returns int beginTransaction() \u00b6 public beginTransaction ( ) : void commitTransaction() \u00b6 public commitTransaction ( int $timeout_ms ) : void Parameters timeout_ms int flush() \u00b6 public flush ( int $timeout_ms ) : int Parameters timeout_ms int Returns int getOutQLen() \u00b6 public getOutQLen ( ) : int Returns int initTransactions() \u00b6 public initTransactions ( int $timeout_ms ) : void Initializing transactions must be done before producing and starting a transaction Parameters timeout_ms int newTopic() \u00b6 public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\ProducerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\ProducerTopic poll() \u00b6 public poll ( int $timeout_ms ) : int Parameters timeout_ms int Returns int purge() \u00b6 public purge ( int $purge_flags ) : int Parameters purge_flags int Returns int Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 83.33% (20 / 24) \ud83e\udde1 Methods: 63.64% (7 / 11)","title":"Producer"},{"location":"api/RdKafka/Producer/#class-producer","text":"Class \\RdKafka\\Producer extends \\RdKafka","title":"Class Producer"},{"location":"api/RdKafka/Producer/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Producer/#__construct","text":"public __construct ( ? \\RdKafka\\Conf $conf = null ) : Parameters conf ? \\RdKafka\\Conf","title":"__construct()"},{"location":"api/RdKafka/Producer/#aborttransaction","text":"public abortTransaction ( int $timeout_ms ) : void Parameters timeout_ms int","title":"abortTransaction()"},{"location":"api/RdKafka/Producer/#addbrokers","text":"public addBrokers ( string $broker_list ) : int Parameters broker_list string Returns int","title":"addBrokers()"},{"location":"api/RdKafka/Producer/#begintransaction","text":"public beginTransaction ( ) : void","title":"beginTransaction()"},{"location":"api/RdKafka/Producer/#committransaction","text":"public commitTransaction ( int $timeout_ms ) : void Parameters timeout_ms int","title":"commitTransaction()"},{"location":"api/RdKafka/Producer/#flush","text":"public flush ( int $timeout_ms ) : int Parameters timeout_ms int Returns int","title":"flush()"},{"location":"api/RdKafka/Producer/#getoutqlen","text":"public getOutQLen ( ) : int Returns int","title":"getOutQLen()"},{"location":"api/RdKafka/Producer/#inittransactions","text":"public initTransactions ( int $timeout_ms ) : void Initializing transactions must be done before producing and starting a transaction Parameters timeout_ms int","title":"initTransactions()"},{"location":"api/RdKafka/Producer/#newtopic","text":"public newTopic ( string $topic_name , ? \\RdKafka\\TopicConf $topic_conf = null ) : \\RdKafka\\ProducerTopic Parameters topic_name string topic_conf ? \\RdKafka\\TopicConf Returns \\RdKafka\\ProducerTopic","title":"newTopic()"},{"location":"api/RdKafka/Producer/#poll","text":"public poll ( int $timeout_ms ) : int Parameters timeout_ms int Returns int","title":"poll()"},{"location":"api/RdKafka/Producer/#purge","text":"public purge ( int $purge_flags ) : int Parameters purge_flags int Returns int","title":"purge()"},{"location":"api/RdKafka/Producer/#test-coverage","text":"\ud83d\udc9b Lines: 83.33% (20 / 24) \ud83e\udde1 Methods: 63.64% (7 / 11)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/ProducerTopic/","text":"Class ProducerTopic \u00b6 Class \\RdKafka\\ProducerTopic extends \\RdKafka\\Topic Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\Producer $producer , string $name , \\RdKafka\\TopicConf $conf = null ) : Parameters producer \\RdKafka\\Producer name string conf \\RdKafka\\TopicConf produce() \u00b6 public produce ( int $partition , int $msgflags , string $payload = null , string $key = null , mixed $opaque = null ) : void Parameters partition int msgflags int payload string key string opaque mixed producev() \u00b6 public producev ( int $partition , int $msgflags , ? string $payload = null , ? string $key = null , ? array $headers = null , ? int $timestamp_ms = null , mixed $opaque = null ) : void Parameters partition int msgflags int payload ?string key ?string headers ?array timestamp_ms ?int opaque mixed Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 89.83% (53 / 59) \ud83e\udde1 Methods: 60% (3 / 5)","title":"ProducerTopic"},{"location":"api/RdKafka/ProducerTopic/#class-producertopic","text":"Class \\RdKafka\\ProducerTopic extends \\RdKafka\\Topic","title":"Class ProducerTopic"},{"location":"api/RdKafka/ProducerTopic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/ProducerTopic/#__construct","text":"public __construct ( \\RdKafka\\Producer $producer , string $name , \\RdKafka\\TopicConf $conf = null ) : Parameters producer \\RdKafka\\Producer name string conf \\RdKafka\\TopicConf","title":"__construct()"},{"location":"api/RdKafka/ProducerTopic/#produce","text":"public produce ( int $partition , int $msgflags , string $payload = null , string $key = null , mixed $opaque = null ) : void Parameters partition int msgflags int payload string key string opaque mixed","title":"produce()"},{"location":"api/RdKafka/ProducerTopic/#producev","text":"public producev ( int $partition , int $msgflags , ? string $payload = null , ? string $key = null , ? array $headers = null , ? int $timestamp_ms = null , mixed $opaque = null ) : void Parameters partition int msgflags int payload ?string key ?string headers ?array timestamp_ms ?int opaque mixed","title":"producev()"},{"location":"api/RdKafka/ProducerTopic/#test-coverage","text":"\ud83d\udc9b Lines: 89.83% (53 / 59) \ud83e\udde1 Methods: 60% (3 / 5)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Queue/","text":"Class Queue \u00b6 Class \\RdKafka\\Queue Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $queue ) : Parameters queue \\FFI\\CData __destruct() \u00b6 public __destruct ( ) : consume() \u00b6 public consume ( int $timeout_ms ) : ? \\RdKafka\\Message Parameters timeout_ms int Returns ? \\RdKafka\\Message fromRdKafka() \u00b6 public static fromRdKafka ( \\RdKafka $kafka ) : self Parameters kafka \\RdKafka Returns self getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData poll() \u00b6 public poll ( int $timeout_ms ) : ? \\RdKafka\\Event Parameters timeout_ms int Returns ? \\RdKafka\\Event Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 76.92% (20 / 26) \u2764\ufe0f Methods: 50% (3 / 6)","title":"Queue"},{"location":"api/RdKafka/Queue/#class-queue","text":"Class \\RdKafka\\Queue","title":"Class Queue"},{"location":"api/RdKafka/Queue/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Queue/#__construct","text":"public __construct ( \\FFI\\CData $queue ) : Parameters queue \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Queue/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Queue/#consume","text":"public consume ( int $timeout_ms ) : ? \\RdKafka\\Message Parameters timeout_ms int Returns ? \\RdKafka\\Message","title":"consume()"},{"location":"api/RdKafka/Queue/#fromrdkafka","text":"public static fromRdKafka ( \\RdKafka $kafka ) : self Parameters kafka \\RdKafka Returns self","title":"fromRdKafka()"},{"location":"api/RdKafka/Queue/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Queue/#poll","text":"public poll ( int $timeout_ms ) : ? \\RdKafka\\Event Parameters timeout_ms int Returns ? \\RdKafka\\Event","title":"poll()"},{"location":"api/RdKafka/Queue/#test-coverage","text":"\ud83d\udc9b Lines: 76.92% (20 / 26) \u2764\ufe0f Methods: 50% (3 / 6)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Topic/","text":"Class Topic \u00b6 abstract Class \\RdKafka\\Topic Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka , string $name , ? \\RdKafka\\TopicConf $conf = null ) : Parameters kafka \\RdKafka name string conf ? \\RdKafka\\TopicConf __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData getName() \u00b6 public getName ( ) : string Returns string Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 88.89% (16 / 18) \ud83d\udc9b Methods: 80% (4 / 5) Extended by \u00b6 \\RdKafka\\ConsumerTopic \\RdKafka\\KafkaConsumerTopic \\RdKafka\\ProducerTopic","title":"Topic"},{"location":"api/RdKafka/Topic/#class-topic","text":"abstract Class \\RdKafka\\Topic","title":"Class Topic"},{"location":"api/RdKafka/Topic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Topic/#__construct","text":"public __construct ( \\RdKafka $kafka , string $name , ? \\RdKafka\\TopicConf $conf = null ) : Parameters kafka \\RdKafka name string conf ? \\RdKafka\\TopicConf","title":"__construct()"},{"location":"api/RdKafka/Topic/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Topic/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Topic/#getname","text":"public getName ( ) : string Returns string","title":"getName()"},{"location":"api/RdKafka/Topic/#test-coverage","text":"\ud83d\udc9b Lines: 88.89% (16 / 18) \ud83d\udc9b Methods: 80% (4 / 5)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Topic/#extended-by","text":"\\RdKafka\\ConsumerTopic \\RdKafka\\KafkaConsumerTopic \\RdKafka\\ProducerTopic","title":"Extended by"},{"location":"api/RdKafka/TopicConf/","text":"Class TopicConf \u00b6 Class \\RdKafka\\TopicConf See also Configuration reference for librdkafka Methods \u00b6 __construct() \u00b6 public __construct ( ) : __destruct() \u00b6 public __destruct ( ) : dump() \u00b6 public dump ( ) : array Returns array getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData getOpaque() \u00b6 public getOpaque ( ) : mixed | null Returns mixed|null set() \u00b6 public set ( string $name , string $value ) : void Parameters name string value string setOpaque() \u00b6 public setOpaque ( mixed $opaque ) : void Parameters opaque mixed setPartitioner() \u00b6 public setPartitioner ( int $partitioner ) : void Parameters partitioner int setPartitionerCb() \u00b6 public setPartitionerCb ( callable $callback ) : void Parameters callback callable Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 77.27% (51 / 66) \ud83e\udde1 Methods: 66.67% (6 / 9)","title":"TopicConf"},{"location":"api/RdKafka/TopicConf/#class-topicconf","text":"Class \\RdKafka\\TopicConf See also Configuration reference for librdkafka","title":"Class TopicConf"},{"location":"api/RdKafka/TopicConf/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/TopicConf/#__construct","text":"public __construct ( ) :","title":"__construct()"},{"location":"api/RdKafka/TopicConf/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/TopicConf/#dump","text":"public dump ( ) : array Returns array","title":"dump()"},{"location":"api/RdKafka/TopicConf/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/TopicConf/#getopaque","text":"public getOpaque ( ) : mixed | null Returns mixed|null","title":"getOpaque()"},{"location":"api/RdKafka/TopicConf/#set","text":"public set ( string $name , string $value ) : void Parameters name string value string","title":"set()"},{"location":"api/RdKafka/TopicConf/#setopaque","text":"public setOpaque ( mixed $opaque ) : void Parameters opaque mixed","title":"setOpaque()"},{"location":"api/RdKafka/TopicConf/#setpartitioner","text":"public setPartitioner ( int $partitioner ) : void Parameters partitioner int","title":"setPartitioner()"},{"location":"api/RdKafka/TopicConf/#setpartitionercb","text":"public setPartitionerCb ( callable $callback ) : void Parameters callback callable","title":"setPartitionerCb()"},{"location":"api/RdKafka/TopicConf/#test-coverage","text":"\ud83d\udc9b Lines: 77.27% (51 / 66) \ud83e\udde1 Methods: 66.67% (6 / 9)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/TopicPartition/","text":"Class TopicPartition \u00b6 Class \\RdKafka\\TopicPartition Methods \u00b6 __construct() \u00b6 public __construct ( string $topic , int $partition , int $offset , string | null $metadata = null ) : Parameters topic string partition int offset int metadata string|null requires librdkafka >= 1.2.0 fromCData() \u00b6 public static fromCData ( \\FFI\\CData $topicPartition ) : self Parameters topicPartition \\FFI\\CData Returns self getErr() \u00b6 public getErr ( ) : ? int Returns ?int getMetadata() \u00b6 public getMetadata ( ) : ? string Returns ?string getMetadataSize() \u00b6 public getMetadataSize ( ) : int Returns int getOffset() \u00b6 public getOffset ( ) : int Returns int getOpqaque() \u00b6 public getOpqaque ( ) : ? object Returns ?object getPartition() \u00b6 public getPartition ( ) : int Returns int getTopic() \u00b6 public getTopic ( ) : string Returns string setMetadata() \u00b6 public setMetadata ( ? string $metadata ) : void Parameters metadata ?string setOffset() \u00b6 public setOffset ( int $offset ) : void Parameters offset int setPartition() \u00b6 public setPartition ( int $partition ) : void Parameters partition int setTopic() \u00b6 public setTopic ( string $topic_name ) : void Parameters topic_name string Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (34 / 34) \ud83d\udc9a Methods: 100% (13 / 13)","title":"TopicPartition"},{"location":"api/RdKafka/TopicPartition/#class-topicpartition","text":"Class \\RdKafka\\TopicPartition","title":"Class TopicPartition"},{"location":"api/RdKafka/TopicPartition/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/TopicPartition/#__construct","text":"public __construct ( string $topic , int $partition , int $offset , string | null $metadata = null ) : Parameters topic string partition int offset int metadata string|null requires librdkafka >= 1.2.0","title":"__construct()"},{"location":"api/RdKafka/TopicPartition/#fromcdata","text":"public static fromCData ( \\FFI\\CData $topicPartition ) : self Parameters topicPartition \\FFI\\CData Returns self","title":"fromCData()"},{"location":"api/RdKafka/TopicPartition/#geterr","text":"public getErr ( ) : ? int Returns ?int","title":"getErr()"},{"location":"api/RdKafka/TopicPartition/#getmetadata","text":"public getMetadata ( ) : ? string Returns ?string","title":"getMetadata()"},{"location":"api/RdKafka/TopicPartition/#getmetadatasize","text":"public getMetadataSize ( ) : int Returns int","title":"getMetadataSize()"},{"location":"api/RdKafka/TopicPartition/#getoffset","text":"public getOffset ( ) : int Returns int","title":"getOffset()"},{"location":"api/RdKafka/TopicPartition/#getopqaque","text":"public getOpqaque ( ) : ? object Returns ?object","title":"getOpqaque()"},{"location":"api/RdKafka/TopicPartition/#getpartition","text":"public getPartition ( ) : int Returns int","title":"getPartition()"},{"location":"api/RdKafka/TopicPartition/#gettopic","text":"public getTopic ( ) : string Returns string","title":"getTopic()"},{"location":"api/RdKafka/TopicPartition/#setmetadata","text":"public setMetadata ( ? string $metadata ) : void Parameters metadata ?string","title":"setMetadata()"},{"location":"api/RdKafka/TopicPartition/#setoffset","text":"public setOffset ( int $offset ) : void Parameters offset int","title":"setOffset()"},{"location":"api/RdKafka/TopicPartition/#setpartition","text":"public setPartition ( int $partition ) : void Parameters partition int","title":"setPartition()"},{"location":"api/RdKafka/TopicPartition/#settopic","text":"public setTopic ( string $topic_name ) : void Parameters topic_name string","title":"setTopic()"},{"location":"api/RdKafka/TopicPartition/#test-coverage","text":"\ud83d\udc9a Lines: 100% (34 / 34) \ud83d\udc9a Methods: 100% (13 / 13)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/TopicPartitionList/","text":"Class TopicPartitionList \u00b6 Class \\RdKafka\\TopicPartitionList implements \\Iterator implements \\Countable Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\TopicPartition [] $items ) : Parameters items \\RdKafka\\TopicPartition [] asArray() \u00b6 public asArray ( ) : \\RdKafka\\TopicPartition [] Returns \\RdKafka\\TopicPartition [] count() \u00b6 public count ( ) : int Returns int current() \u00b6 public current ( ) : \\RdKafka\\TopicPartition Returns \\RdKafka\\TopicPartition fromCData() \u00b6 public static fromCData ( \\FFI\\CData $topicPartitionList ) : self Parameters topicPartitionList \\FFI\\CData Returns self getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData key() \u00b6 public key ( ) : int Returns int next() \u00b6 public next ( ) : void rewind() \u00b6 public rewind ( ) : void valid() \u00b6 public valid ( ) : bool Returns bool Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 96.55% (28 / 29) \ud83d\udc9b Methods: 90% (9 / 10)","title":"TopicPartitionList"},{"location":"api/RdKafka/TopicPartitionList/#class-topicpartitionlist","text":"Class \\RdKafka\\TopicPartitionList implements \\Iterator implements \\Countable","title":"Class TopicPartitionList"},{"location":"api/RdKafka/TopicPartitionList/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/TopicPartitionList/#__construct","text":"public __construct ( \\RdKafka\\TopicPartition [] $items ) : Parameters items \\RdKafka\\TopicPartition []","title":"__construct()"},{"location":"api/RdKafka/TopicPartitionList/#asarray","text":"public asArray ( ) : \\RdKafka\\TopicPartition [] Returns \\RdKafka\\TopicPartition []","title":"asArray()"},{"location":"api/RdKafka/TopicPartitionList/#count","text":"public count ( ) : int Returns int","title":"count()"},{"location":"api/RdKafka/TopicPartitionList/#current","text":"public current ( ) : \\RdKafka\\TopicPartition Returns \\RdKafka\\TopicPartition","title":"current()"},{"location":"api/RdKafka/TopicPartitionList/#fromcdata","text":"public static fromCData ( \\FFI\\CData $topicPartitionList ) : self Parameters topicPartitionList \\FFI\\CData Returns self","title":"fromCData()"},{"location":"api/RdKafka/TopicPartitionList/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/TopicPartitionList/#key","text":"public key ( ) : int Returns int","title":"key()"},{"location":"api/RdKafka/TopicPartitionList/#next","text":"public next ( ) : void","title":"next()"},{"location":"api/RdKafka/TopicPartitionList/#rewind","text":"public rewind ( ) : void","title":"rewind()"},{"location":"api/RdKafka/TopicPartitionList/#valid","text":"public valid ( ) : bool Returns bool","title":"valid()"},{"location":"api/RdKafka/TopicPartitionList/#test-coverage","text":"\ud83d\udc9a Lines: 96.55% (28 / 29) \ud83d\udc9b Methods: 90% (9 / 10)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/","text":"Class AlterConfigsOptions \u00b6 Class \\RdKafka\\Admin\\AlterConfigsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"AlterConfigsOptions"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#class-alterconfigsoptions","text":"Class \\RdKafka\\Admin\\AlterConfigsOptions extends \\RdKafka\\Admin\\Options","title":"Class AlterConfigsOptions"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/AlterConfigsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/Client/","text":"Class Client \u00b6 Class \\RdKafka\\Admin\\Client Methods \u00b6 alterConfigs() \u00b6 public alterConfigs ( \\RdKafka\\Admin\\ConfigResource [] $resources , ? \\RdKafka\\Admin\\AlterConfigsOptions $options = null ) : \\RdKafka\\Admin\\ConfigResourceResult [] Parameters resources \\RdKafka\\Admin\\ConfigResource [] options ? \\RdKafka\\Admin\\AlterConfigsOptions Returns \\RdKafka\\Admin\\ConfigResourceResult [] createPartitions() \u00b6 public createPartitions ( \\RdKafka\\Admin\\NewPartitions [] $partitions , ? \\RdKafka\\Admin\\CreatePartitionsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters partitions \\RdKafka\\Admin\\NewPartitions [] options ? \\RdKafka\\Admin\\CreatePartitionsOptions Returns \\RdKafka\\Admin\\TopicResult [] createTopics() \u00b6 public createTopics ( \\RdKafka\\Admin\\NewTopic [] $topics , ? \\RdKafka\\Admin\\CreateTopicsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters topics \\RdKafka\\Admin\\NewTopic [] options ? \\RdKafka\\Admin\\CreateTopicsOptions Returns \\RdKafka\\Admin\\TopicResult [] deleteConsumerGroupOffsets() \u00b6 public deleteConsumerGroupOffsets ( \\RdKafka\\Admin\\DeleteConsumerGroupOffsets $offsets , ? \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions $options = null ) : \\RdKafka\\Admin\\GroupResult [] Parameters offsets \\RdKafka\\Admin\\DeleteConsumerGroupOffsets options ? \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions Returns \\RdKafka\\Admin\\GroupResult [] deleteGroups() \u00b6 public deleteGroups ( \\RdKafka\\Admin\\DeleteGroup [] $groups , ? \\RdKafka\\Admin\\DeleteGroupsOptions $options = null ) : \\RdKafka\\Admin\\GroupResult [] Parameters groups \\RdKafka\\Admin\\DeleteGroup [] options ? \\RdKafka\\Admin\\DeleteGroupsOptions Returns \\RdKafka\\Admin\\GroupResult [] deleteRecords() \u00b6 public deleteRecords ( \\RdKafka\\Admin\\DeleteRecords [] $records , ? \\RdKafka\\Admin\\DeleteRecordsOptions $options = null ) : \\RdKafka\\TopicPartition [] Parameters records \\RdKafka\\Admin\\DeleteRecords [] options ? \\RdKafka\\Admin\\DeleteRecordsOptions Returns \\RdKafka\\TopicPartition [] deleteTopics() \u00b6 public deleteTopics ( \\RdKafka\\Admin\\DeleteTopic [] $topics , ? \\RdKafka\\Admin\\DeleteTopicsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters topics \\RdKafka\\Admin\\DeleteTopic [] options ? \\RdKafka\\Admin\\DeleteTopicsOptions Returns \\RdKafka\\Admin\\TopicResult [] describeConfigs() \u00b6 public describeConfigs ( \\RdKafka\\Admin\\ConfigResource [] $resources , ? \\RdKafka\\Admin\\DescribeConfigsOptions $options = null ) : \\RdKafka\\Admin\\ConfigResourceResult [] Parameters resources \\RdKafka\\Admin\\ConfigResource [] options ? \\RdKafka\\Admin\\DescribeConfigsOptions Returns \\RdKafka\\Admin\\ConfigResourceResult [] fromConf() \u00b6 public static fromConf ( \\RdKafka\\Conf $conf ) : \\RdKafka\\Admin\\Client Parameters conf \\RdKafka\\Conf Returns \\RdKafka\\Admin\\Client fromConsumer() \u00b6 public static fromConsumer ( \\RdKafka\\Consumer $consumer ) : self Parameters consumer \\RdKafka\\Consumer Returns self fromProducer() \u00b6 public static fromProducer ( \\RdKafka\\Producer $producer ) : self Parameters producer \\RdKafka\\Producer Returns self getMetadata() \u00b6 public getMetadata ( bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : \\RdKafka\\Metadata Parameters all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int Returns \\RdKafka\\Metadata newAlterConfigsOptions() \u00b6 public newAlterConfigsOptions ( ) : \\RdKafka\\Admin\\AlterConfigsOptions Returns \\RdKafka\\Admin\\AlterConfigsOptions newCreatePartitionsOptions() \u00b6 public newCreatePartitionsOptions ( ) : \\RdKafka\\Admin\\CreatePartitionsOptions Returns \\RdKafka\\Admin\\CreatePartitionsOptions newCreateTopicsOptions() \u00b6 public newCreateTopicsOptions ( ) : \\RdKafka\\Admin\\CreateTopicsOptions Returns \\RdKafka\\Admin\\CreateTopicsOptions newDeleteConsumerGroupOffsetsOptions() \u00b6 public newDeleteConsumerGroupOffsetsOptions ( ) : \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions Returns \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions newDeleteGroupsOptions() \u00b6 public newDeleteGroupsOptions ( ) : \\RdKafka\\Admin\\DeleteGroupsOptions Returns \\RdKafka\\Admin\\DeleteGroupsOptions newDeleteRecordsOptions() \u00b6 public newDeleteRecordsOptions ( ) : \\RdKafka\\Admin\\DeleteRecordsOptions Returns \\RdKafka\\Admin\\DeleteRecordsOptions newDeleteTopicsOptions() \u00b6 public newDeleteTopicsOptions ( ) : \\RdKafka\\Admin\\DeleteTopicsOptions Returns \\RdKafka\\Admin\\DeleteTopicsOptions newDescribeConfigsOptions() \u00b6 public newDescribeConfigsOptions ( ) : \\RdKafka\\Admin\\DescribeConfigsOptions Returns \\RdKafka\\Admin\\DescribeConfigsOptions setWaitForResultEventTimeout() \u00b6 public setWaitForResultEventTimeout ( int $timeoutMs ) : void Parameters timeoutMs int Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 84.78% (156 / 184) \ud83d\udc9b Methods: 79.17% (19 / 24)","title":"Client"},{"location":"api/RdKafka/Admin/Client/#class-client","text":"Class \\RdKafka\\Admin\\Client","title":"Class Client"},{"location":"api/RdKafka/Admin/Client/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/Client/#alterconfigs","text":"public alterConfigs ( \\RdKafka\\Admin\\ConfigResource [] $resources , ? \\RdKafka\\Admin\\AlterConfigsOptions $options = null ) : \\RdKafka\\Admin\\ConfigResourceResult [] Parameters resources \\RdKafka\\Admin\\ConfigResource [] options ? \\RdKafka\\Admin\\AlterConfigsOptions Returns \\RdKafka\\Admin\\ConfigResourceResult []","title":"alterConfigs()"},{"location":"api/RdKafka/Admin/Client/#createpartitions","text":"public createPartitions ( \\RdKafka\\Admin\\NewPartitions [] $partitions , ? \\RdKafka\\Admin\\CreatePartitionsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters partitions \\RdKafka\\Admin\\NewPartitions [] options ? \\RdKafka\\Admin\\CreatePartitionsOptions Returns \\RdKafka\\Admin\\TopicResult []","title":"createPartitions()"},{"location":"api/RdKafka/Admin/Client/#createtopics","text":"public createTopics ( \\RdKafka\\Admin\\NewTopic [] $topics , ? \\RdKafka\\Admin\\CreateTopicsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters topics \\RdKafka\\Admin\\NewTopic [] options ? \\RdKafka\\Admin\\CreateTopicsOptions Returns \\RdKafka\\Admin\\TopicResult []","title":"createTopics()"},{"location":"api/RdKafka/Admin/Client/#deleteconsumergroupoffsets","text":"public deleteConsumerGroupOffsets ( \\RdKafka\\Admin\\DeleteConsumerGroupOffsets $offsets , ? \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions $options = null ) : \\RdKafka\\Admin\\GroupResult [] Parameters offsets \\RdKafka\\Admin\\DeleteConsumerGroupOffsets options ? \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions Returns \\RdKafka\\Admin\\GroupResult []","title":"deleteConsumerGroupOffsets()"},{"location":"api/RdKafka/Admin/Client/#deletegroups","text":"public deleteGroups ( \\RdKafka\\Admin\\DeleteGroup [] $groups , ? \\RdKafka\\Admin\\DeleteGroupsOptions $options = null ) : \\RdKafka\\Admin\\GroupResult [] Parameters groups \\RdKafka\\Admin\\DeleteGroup [] options ? \\RdKafka\\Admin\\DeleteGroupsOptions Returns \\RdKafka\\Admin\\GroupResult []","title":"deleteGroups()"},{"location":"api/RdKafka/Admin/Client/#deleterecords","text":"public deleteRecords ( \\RdKafka\\Admin\\DeleteRecords [] $records , ? \\RdKafka\\Admin\\DeleteRecordsOptions $options = null ) : \\RdKafka\\TopicPartition [] Parameters records \\RdKafka\\Admin\\DeleteRecords [] options ? \\RdKafka\\Admin\\DeleteRecordsOptions Returns \\RdKafka\\TopicPartition []","title":"deleteRecords()"},{"location":"api/RdKafka/Admin/Client/#deletetopics","text":"public deleteTopics ( \\RdKafka\\Admin\\DeleteTopic [] $topics , ? \\RdKafka\\Admin\\DeleteTopicsOptions $options = null ) : \\RdKafka\\Admin\\TopicResult [] Parameters topics \\RdKafka\\Admin\\DeleteTopic [] options ? \\RdKafka\\Admin\\DeleteTopicsOptions Returns \\RdKafka\\Admin\\TopicResult []","title":"deleteTopics()"},{"location":"api/RdKafka/Admin/Client/#describeconfigs","text":"public describeConfigs ( \\RdKafka\\Admin\\ConfigResource [] $resources , ? \\RdKafka\\Admin\\DescribeConfigsOptions $options = null ) : \\RdKafka\\Admin\\ConfigResourceResult [] Parameters resources \\RdKafka\\Admin\\ConfigResource [] options ? \\RdKafka\\Admin\\DescribeConfigsOptions Returns \\RdKafka\\Admin\\ConfigResourceResult []","title":"describeConfigs()"},{"location":"api/RdKafka/Admin/Client/#fromconf","text":"public static fromConf ( \\RdKafka\\Conf $conf ) : \\RdKafka\\Admin\\Client Parameters conf \\RdKafka\\Conf Returns \\RdKafka\\Admin\\Client","title":"fromConf()"},{"location":"api/RdKafka/Admin/Client/#fromconsumer","text":"public static fromConsumer ( \\RdKafka\\Consumer $consumer ) : self Parameters consumer \\RdKafka\\Consumer Returns self","title":"fromConsumer()"},{"location":"api/RdKafka/Admin/Client/#fromproducer","text":"public static fromProducer ( \\RdKafka\\Producer $producer ) : self Parameters producer \\RdKafka\\Producer Returns self","title":"fromProducer()"},{"location":"api/RdKafka/Admin/Client/#getmetadata","text":"public getMetadata ( bool $all_topics , ? \\RdKafka\\Topic $only_topic , int $timeout_ms ) : \\RdKafka\\Metadata Parameters all_topics bool only_topic ? \\RdKafka\\Topic timeout_ms int Returns \\RdKafka\\Metadata","title":"getMetadata()"},{"location":"api/RdKafka/Admin/Client/#newalterconfigsoptions","text":"public newAlterConfigsOptions ( ) : \\RdKafka\\Admin\\AlterConfigsOptions Returns \\RdKafka\\Admin\\AlterConfigsOptions","title":"newAlterConfigsOptions()"},{"location":"api/RdKafka/Admin/Client/#newcreatepartitionsoptions","text":"public newCreatePartitionsOptions ( ) : \\RdKafka\\Admin\\CreatePartitionsOptions Returns \\RdKafka\\Admin\\CreatePartitionsOptions","title":"newCreatePartitionsOptions()"},{"location":"api/RdKafka/Admin/Client/#newcreatetopicsoptions","text":"public newCreateTopicsOptions ( ) : \\RdKafka\\Admin\\CreateTopicsOptions Returns \\RdKafka\\Admin\\CreateTopicsOptions","title":"newCreateTopicsOptions()"},{"location":"api/RdKafka/Admin/Client/#newdeleteconsumergroupoffsetsoptions","text":"public newDeleteConsumerGroupOffsetsOptions ( ) : \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions Returns \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions","title":"newDeleteConsumerGroupOffsetsOptions()"},{"location":"api/RdKafka/Admin/Client/#newdeletegroupsoptions","text":"public newDeleteGroupsOptions ( ) : \\RdKafka\\Admin\\DeleteGroupsOptions Returns \\RdKafka\\Admin\\DeleteGroupsOptions","title":"newDeleteGroupsOptions()"},{"location":"api/RdKafka/Admin/Client/#newdeleterecordsoptions","text":"public newDeleteRecordsOptions ( ) : \\RdKafka\\Admin\\DeleteRecordsOptions Returns \\RdKafka\\Admin\\DeleteRecordsOptions","title":"newDeleteRecordsOptions()"},{"location":"api/RdKafka/Admin/Client/#newdeletetopicsoptions","text":"public newDeleteTopicsOptions ( ) : \\RdKafka\\Admin\\DeleteTopicsOptions Returns \\RdKafka\\Admin\\DeleteTopicsOptions","title":"newDeleteTopicsOptions()"},{"location":"api/RdKafka/Admin/Client/#newdescribeconfigsoptions","text":"public newDescribeConfigsOptions ( ) : \\RdKafka\\Admin\\DescribeConfigsOptions Returns \\RdKafka\\Admin\\DescribeConfigsOptions","title":"newDescribeConfigsOptions()"},{"location":"api/RdKafka/Admin/Client/#setwaitforresulteventtimeout","text":"public setWaitForResultEventTimeout ( int $timeoutMs ) : void Parameters timeoutMs int","title":"setWaitForResultEventTimeout()"},{"location":"api/RdKafka/Admin/Client/#test-coverage","text":"\ud83d\udc9b Lines: 84.78% (156 / 184) \ud83d\udc9b Methods: 79.17% (19 / 24)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Admin/ConfigEntry/","text":"Class ConfigEntry \u00b6 Class \\RdKafka\\Admin\\ConfigEntry Properties \u00b6 isDefault \u00b6 public bool isDefault isReadOnly \u00b6 public bool isReadOnly isSensitive \u00b6 public bool isSensitive isSynonym \u00b6 public bool isSynonym name \u00b6 public string name source \u00b6 public int source synonyms \u00b6 public \\RdKafka\\Admin\\ConfigEntry [] synonyms value \u00b6 public ? string value Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $entry ) : Parameters entry \\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (14 / 14) \ud83d\udc9a Methods: 100% (1 / 1)","title":"ConfigEntry"},{"location":"api/RdKafka/Admin/ConfigEntry/#class-configentry","text":"Class \\RdKafka\\Admin\\ConfigEntry","title":"Class ConfigEntry"},{"location":"api/RdKafka/Admin/ConfigEntry/#properties","text":"","title":"Properties"},{"location":"api/RdKafka/Admin/ConfigEntry/#isdefault","text":"public bool isDefault","title":"isDefault"},{"location":"api/RdKafka/Admin/ConfigEntry/#isreadonly","text":"public bool isReadOnly","title":"isReadOnly"},{"location":"api/RdKafka/Admin/ConfigEntry/#issensitive","text":"public bool isSensitive","title":"isSensitive"},{"location":"api/RdKafka/Admin/ConfigEntry/#issynonym","text":"public bool isSynonym","title":"isSynonym"},{"location":"api/RdKafka/Admin/ConfigEntry/#name","text":"public string name","title":"name"},{"location":"api/RdKafka/Admin/ConfigEntry/#source","text":"public int source","title":"source"},{"location":"api/RdKafka/Admin/ConfigEntry/#synonyms","text":"public \\RdKafka\\Admin\\ConfigEntry [] synonyms","title":"synonyms"},{"location":"api/RdKafka/Admin/ConfigEntry/#value","text":"public ? string value","title":"value"},{"location":"api/RdKafka/Admin/ConfigEntry/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/ConfigEntry/#__construct","text":"public __construct ( \\FFI\\CData $entry ) : Parameters entry \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Admin/ConfigEntry/#test-coverage","text":"\ud83d\udc9a Lines: 100% (14 / 14) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/ConfigResource/","text":"Class ConfigResource \u00b6 Class \\RdKafka\\Admin\\ConfigResource Methods \u00b6 __construct() \u00b6 public __construct ( int $type , string $name ) : Parameters type int name string __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData setConfig() \u00b6 public setConfig ( string $name , string $value ) : void Parameters name string value string Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 92.86% (13 / 14) \ud83d\udc9b Methods: 75% (3 / 4)","title":"ConfigResource"},{"location":"api/RdKafka/Admin/ConfigResource/#class-configresource","text":"Class \\RdKafka\\Admin\\ConfigResource","title":"Class ConfigResource"},{"location":"api/RdKafka/Admin/ConfigResource/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/ConfigResource/#__construct","text":"public __construct ( int $type , string $name ) : Parameters type int name string","title":"__construct()"},{"location":"api/RdKafka/Admin/ConfigResource/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/ConfigResource/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/ConfigResource/#setconfig","text":"public setConfig ( string $name , string $value ) : void Parameters name string value string","title":"setConfig()"},{"location":"api/RdKafka/Admin/ConfigResource/#test-coverage","text":"\ud83d\udc9a Lines: 92.86% (13 / 14) \ud83d\udc9b Methods: 75% (3 / 4)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/ConfigResourceResult/","text":"Class ConfigResourceResult \u00b6 Class \\RdKafka\\Admin\\ConfigResourceResult Properties \u00b6 configs \u00b6 public \\RdKafka\\Admin\\ConfigEntry [] configs error \u00b6 public int error errorString \u00b6 public ? string errorString name \u00b6 public string name type \u00b6 public int type Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (11 / 11) \ud83d\udc9a Methods: 100% (1 / 1)","title":"ConfigResourceResult"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#class-configresourceresult","text":"Class \\RdKafka\\Admin\\ConfigResourceResult","title":"Class ConfigResourceResult"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#properties","text":"","title":"Properties"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#configs","text":"public \\RdKafka\\Admin\\ConfigEntry [] configs","title":"configs"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#error","text":"public int error","title":"error"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#errorstring","text":"public ? string errorString","title":"errorString"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#name","text":"public string name","title":"name"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#type","text":"public int type","title":"type"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#__construct","text":"public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Admin/ConfigResourceResult/#test-coverage","text":"\ud83d\udc9a Lines: 100% (11 / 11) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/","text":"Class CreatePartitionsOptions \u00b6 Class \\RdKafka\\Admin\\CreatePartitionsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"CreatePartitionsOptions"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#class-createpartitionsoptions","text":"Class \\RdKafka\\Admin\\CreatePartitionsOptions extends \\RdKafka\\Admin\\Options","title":"Class CreatePartitionsOptions"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/CreatePartitionsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/","text":"Class CreateTopicsOptions \u00b6 Class \\RdKafka\\Admin\\CreateTopicsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"CreateTopicsOptions"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#class-createtopicsoptions","text":"Class \\RdKafka\\Admin\\CreateTopicsOptions extends \\RdKafka\\Admin\\Options","title":"Class CreateTopicsOptions"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/CreateTopicsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/","text":"Class DeleteConsumerGroupOffsets \u00b6 Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsets Methods \u00b6 __construct() \u00b6 public __construct ( string $group , \\RdKafka\\TopicPartition $partitions ) : Parameters group string partitions \\RdKafka\\TopicPartition __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData Test Coverage \u2764\ufe0f \u00b6 \u2764\ufe0f Lines: 0% (0 / 12) \u2764\ufe0f Methods: 0% (0 / 3)","title":"DeleteConsumerGroupOffsets"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#class-deleteconsumergroupoffsets","text":"Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsets","title":"Class DeleteConsumerGroupOffsets"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#__construct","text":"public __construct ( string $group , \\RdKafka\\TopicPartition $partitions ) : Parameters group string partitions \\RdKafka\\TopicPartition","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsets/#test-coverage","text":"\u2764\ufe0f Lines: 0% (0 / 12) \u2764\ufe0f Methods: 0% (0 / 3)","title":"Test Coverage \u2764\ufe0f"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/","text":"Class DeleteConsumerGroupOffsetsOptions \u00b6 Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \u2764\ufe0f \u00b6 \u2764\ufe0f Lines: 0% (0 / 2) \u2764\ufe0f Methods: 0% (0 / 1)","title":"DeleteConsumerGroupOffsetsOptions"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#class-deleteconsumergroupoffsetsoptions","text":"Class \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions extends \\RdKafka\\Admin\\Options","title":"Class DeleteConsumerGroupOffsetsOptions"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteConsumerGroupOffsetsOptions/#test-coverage","text":"\u2764\ufe0f Lines: 0% (0 / 2) \u2764\ufe0f Methods: 0% (0 / 1)","title":"Test Coverage \u2764\ufe0f"},{"location":"api/RdKafka/Admin/DeleteGroup/","text":"Class DeleteGroup \u00b6 Class \\RdKafka\\Admin\\DeleteGroup Methods \u00b6 __construct() \u00b6 public __construct ( string $name ) : Parameters name string __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData Test Coverage \u2764\ufe0f \u00b6 \u2764\ufe0f Lines: 0% (0 / 10) \u2764\ufe0f Methods: 0% (0 / 3)","title":"DeleteGroup"},{"location":"api/RdKafka/Admin/DeleteGroup/#class-deletegroup","text":"Class \\RdKafka\\Admin\\DeleteGroup","title":"Class DeleteGroup"},{"location":"api/RdKafka/Admin/DeleteGroup/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteGroup/#__construct","text":"public __construct ( string $name ) : Parameters name string","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteGroup/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/DeleteGroup/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/DeleteGroup/#test-coverage","text":"\u2764\ufe0f Lines: 0% (0 / 10) \u2764\ufe0f Methods: 0% (0 / 3)","title":"Test Coverage \u2764\ufe0f"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/","text":"Class DeleteGroupsOptions \u00b6 Class \\RdKafka\\Admin\\DeleteGroupsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \u2764\ufe0f \u00b6 \u2764\ufe0f Lines: 0% (0 / 2) \u2764\ufe0f Methods: 0% (0 / 1)","title":"DeleteGroupsOptions"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#class-deletegroupsoptions","text":"Class \\RdKafka\\Admin\\DeleteGroupsOptions extends \\RdKafka\\Admin\\Options","title":"Class DeleteGroupsOptions"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteGroupsOptions/#test-coverage","text":"\u2764\ufe0f Lines: 0% (0 / 2) \u2764\ufe0f Methods: 0% (0 / 1)","title":"Test Coverage \u2764\ufe0f"},{"location":"api/RdKafka/Admin/DeleteRecords/","text":"Class DeleteRecords \u00b6 Class \\RdKafka\\Admin\\DeleteRecords Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka\\TopicPartition $beforeOffsets ) : Parameters beforeOffsets \\RdKafka\\TopicPartition __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 75% (9 / 12) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"DeleteRecords"},{"location":"api/RdKafka/Admin/DeleteRecords/#class-deleterecords","text":"Class \\RdKafka\\Admin\\DeleteRecords","title":"Class DeleteRecords"},{"location":"api/RdKafka/Admin/DeleteRecords/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteRecords/#__construct","text":"public __construct ( \\RdKafka\\TopicPartition $beforeOffsets ) : Parameters beforeOffsets \\RdKafka\\TopicPartition","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteRecords/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/DeleteRecords/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/DeleteRecords/#test-coverage","text":"\ud83d\udc9b Lines: 75% (9 / 12) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/","text":"Class DeleteRecordsOptions \u00b6 Class \\RdKafka\\Admin\\DeleteRecordsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"DeleteRecordsOptions"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#class-deleterecordsoptions","text":"Class \\RdKafka\\Admin\\DeleteRecordsOptions extends \\RdKafka\\Admin\\Options","title":"Class DeleteRecordsOptions"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteRecordsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/DeleteTopic/","text":"Class DeleteTopic \u00b6 Class \\RdKafka\\Admin\\DeleteTopic Methods \u00b6 __construct() \u00b6 public __construct ( string $name ) : Parameters name string __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData Test Coverage \ud83e\udde1 \u00b6 \ud83e\udde1 Lines: 70% (7 / 10) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"DeleteTopic"},{"location":"api/RdKafka/Admin/DeleteTopic/#class-deletetopic","text":"Class \\RdKafka\\Admin\\DeleteTopic","title":"Class DeleteTopic"},{"location":"api/RdKafka/Admin/DeleteTopic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteTopic/#__construct","text":"public __construct ( string $name ) : Parameters name string","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteTopic/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/DeleteTopic/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/DeleteTopic/#test-coverage","text":"\ud83e\udde1 Lines: 70% (7 / 10) \u2764\ufe0f Methods: 33.33% (1 / 3)","title":"Test Coverage \ud83e\udde1"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/","text":"Class DeleteTopicsOptions \u00b6 Class \\RdKafka\\Admin\\DeleteTopicsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"DeleteTopicsOptions"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#class-deletetopicsoptions","text":"Class \\RdKafka\\Admin\\DeleteTopicsOptions extends \\RdKafka\\Admin\\Options","title":"Class DeleteTopicsOptions"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/DeleteTopicsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/","text":"Class DescribeConfigsOptions \u00b6 Class \\RdKafka\\Admin\\DescribeConfigsOptions extends \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"DescribeConfigsOptions"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#class-describeconfigsoptions","text":"Class \\RdKafka\\Admin\\DescribeConfigsOptions extends \\RdKafka\\Admin\\Options","title":"Class DescribeConfigsOptions"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#__construct","text":"public __construct ( \\RdKafka $kafka ) : Parameters kafka \\RdKafka","title":"__construct()"},{"location":"api/RdKafka/Admin/DescribeConfigsOptions/#test-coverage","text":"\ud83d\udc9a Lines: 100% (2 / 2) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/GroupResult/","text":"Class GroupResult \u00b6 Class \\RdKafka\\Admin\\GroupResult Properties \u00b6 error \u00b6 public int error errorString \u00b6 public ? string errorString name \u00b6 public ? string name partitions \u00b6 public array partitions Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData Test Coverage \u2764\ufe0f \u00b6 \u2764\ufe0f Lines: 0% (0 / 8) \u2764\ufe0f Methods: 0% (0 / 1)","title":"GroupResult"},{"location":"api/RdKafka/Admin/GroupResult/#class-groupresult","text":"Class \\RdKafka\\Admin\\GroupResult","title":"Class GroupResult"},{"location":"api/RdKafka/Admin/GroupResult/#properties","text":"","title":"Properties"},{"location":"api/RdKafka/Admin/GroupResult/#error","text":"public int error","title":"error"},{"location":"api/RdKafka/Admin/GroupResult/#errorstring","text":"public ? string errorString","title":"errorString"},{"location":"api/RdKafka/Admin/GroupResult/#name","text":"public ? string name","title":"name"},{"location":"api/RdKafka/Admin/GroupResult/#partitions","text":"public array partitions","title":"partitions"},{"location":"api/RdKafka/Admin/GroupResult/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/GroupResult/#__construct","text":"public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Admin/GroupResult/#test-coverage","text":"\u2764\ufe0f Lines: 0% (0 / 8) \u2764\ufe0f Methods: 0% (0 / 1)","title":"Test Coverage \u2764\ufe0f"},{"location":"api/RdKafka/Admin/NewPartitions/","text":"Class NewPartitions \u00b6 Class \\RdKafka\\Admin\\NewPartitions Methods \u00b6 __construct() \u00b6 public __construct ( string $topicName , int $new_total_cnt ) : Parameters topicName string new_total_cnt int __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData setReplicaAssignment() \u00b6 public setReplicaAssignment ( int $new_partition_id , int [] $broker_ids ) : void Parameters new_partition_id int broker_ids int[] Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 91.89% (34 / 37) \u2764\ufe0f Methods: 25% (1 / 4)","title":"NewPartitions"},{"location":"api/RdKafka/Admin/NewPartitions/#class-newpartitions","text":"Class \\RdKafka\\Admin\\NewPartitions","title":"Class NewPartitions"},{"location":"api/RdKafka/Admin/NewPartitions/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/NewPartitions/#__construct","text":"public __construct ( string $topicName , int $new_total_cnt ) : Parameters topicName string new_total_cnt int","title":"__construct()"},{"location":"api/RdKafka/Admin/NewPartitions/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/NewPartitions/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/NewPartitions/#setreplicaassignment","text":"public setReplicaAssignment ( int $new_partition_id , int [] $broker_ids ) : void Parameters new_partition_id int broker_ids int[]","title":"setReplicaAssignment()"},{"location":"api/RdKafka/Admin/NewPartitions/#test-coverage","text":"\ud83d\udc9a Lines: 91.89% (34 / 37) \u2764\ufe0f Methods: 25% (1 / 4)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/NewTopic/","text":"Class NewTopic \u00b6 Class \\RdKafka\\Admin\\NewTopic Methods \u00b6 __construct() \u00b6 public __construct ( string $name , int $num_partitions , int $replication_factor ) : Parameters name string num_partitions int replication_factor int __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData setConfig() \u00b6 public setConfig ( string $name , string $value ) : void Parameters name string value string setReplicaAssignment() \u00b6 public setReplicaAssignment ( int $partition_id , array $broker_ids ) : void Parameters partition_id int broker_ids array Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 83.33% (35 / 42) \u2764\ufe0f Methods: 20% (1 / 5)","title":"NewTopic"},{"location":"api/RdKafka/Admin/NewTopic/#class-newtopic","text":"Class \\RdKafka\\Admin\\NewTopic","title":"Class NewTopic"},{"location":"api/RdKafka/Admin/NewTopic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/NewTopic/#__construct","text":"public __construct ( string $name , int $num_partitions , int $replication_factor ) : Parameters name string num_partitions int replication_factor int","title":"__construct()"},{"location":"api/RdKafka/Admin/NewTopic/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/NewTopic/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/NewTopic/#setconfig","text":"public setConfig ( string $name , string $value ) : void Parameters name string value string","title":"setConfig()"},{"location":"api/RdKafka/Admin/NewTopic/#setreplicaassignment","text":"public setReplicaAssignment ( int $partition_id , array $broker_ids ) : void Parameters partition_id int broker_ids array","title":"setReplicaAssignment()"},{"location":"api/RdKafka/Admin/NewTopic/#test-coverage","text":"\ud83d\udc9b Lines: 83.33% (35 / 42) \u2764\ufe0f Methods: 20% (1 / 5)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/Admin/Options/","text":"Class Options \u00b6 abstract Class \\RdKafka\\Admin\\Options Methods \u00b6 __construct() \u00b6 public __construct ( \\RdKafka $kafka , int $for_api ) : Parameters kafka \\RdKafka for_api int __destruct() \u00b6 public __destruct ( ) : getCData() \u00b6 public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData setBrokerId() \u00b6 public setBrokerId ( int $broker_id ) : void Parameters broker_id int setOperationTimeout() \u00b6 public setOperationTimeout ( int $timeout_ms ) : void Parameters timeout_ms int setRequestTimeout() \u00b6 public setRequestTimeout ( int $timeout_ms ) : void Parameters timeout_ms int setValidateOnly() \u00b6 public setValidateOnly ( bool $true_or_false ) : void Parameters true_or_false bool Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 90.48% (38 / 42) \u2764\ufe0f Methods: 42.86% (3 / 7) Extended by \u00b6 \\RdKafka\\Admin\\AlterConfigsOptions \\RdKafka\\Admin\\CreatePartitionsOptions \\RdKafka\\Admin\\CreateTopicsOptions \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions \\RdKafka\\Admin\\DeleteGroupsOptions \\RdKafka\\Admin\\DeleteRecordsOptions \\RdKafka\\Admin\\DeleteTopicsOptions \\RdKafka\\Admin\\DescribeConfigsOptions","title":"Options"},{"location":"api/RdKafka/Admin/Options/#class-options","text":"abstract Class \\RdKafka\\Admin\\Options","title":"Class Options"},{"location":"api/RdKafka/Admin/Options/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/Options/#__construct","text":"public __construct ( \\RdKafka $kafka , int $for_api ) : Parameters kafka \\RdKafka for_api int","title":"__construct()"},{"location":"api/RdKafka/Admin/Options/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Admin/Options/#getcdata","text":"public getCData ( ) : \\FFI\\CData Returns \\FFI\\CData","title":"getCData()"},{"location":"api/RdKafka/Admin/Options/#setbrokerid","text":"public setBrokerId ( int $broker_id ) : void Parameters broker_id int","title":"setBrokerId()"},{"location":"api/RdKafka/Admin/Options/#setoperationtimeout","text":"public setOperationTimeout ( int $timeout_ms ) : void Parameters timeout_ms int","title":"setOperationTimeout()"},{"location":"api/RdKafka/Admin/Options/#setrequesttimeout","text":"public setRequestTimeout ( int $timeout_ms ) : void Parameters timeout_ms int","title":"setRequestTimeout()"},{"location":"api/RdKafka/Admin/Options/#setvalidateonly","text":"public setValidateOnly ( bool $true_or_false ) : void Parameters true_or_false bool","title":"setValidateOnly()"},{"location":"api/RdKafka/Admin/Options/#test-coverage","text":"\ud83d\udc9a Lines: 90.48% (38 / 42) \u2764\ufe0f Methods: 42.86% (3 / 7)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Admin/Options/#extended-by","text":"\\RdKafka\\Admin\\AlterConfigsOptions \\RdKafka\\Admin\\CreatePartitionsOptions \\RdKafka\\Admin\\CreateTopicsOptions \\RdKafka\\Admin\\DeleteConsumerGroupOffsetsOptions \\RdKafka\\Admin\\DeleteGroupsOptions \\RdKafka\\Admin\\DeleteRecordsOptions \\RdKafka\\Admin\\DeleteTopicsOptions \\RdKafka\\Admin\\DescribeConfigsOptions","title":"Extended by"},{"location":"api/RdKafka/Admin/TopicResult/","text":"Class TopicResult \u00b6 Class \\RdKafka\\Admin\\TopicResult Properties \u00b6 error \u00b6 public int error errorString \u00b6 public ? string errorString name \u00b6 public string name Methods \u00b6 __construct() \u00b6 public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"TopicResult"},{"location":"api/RdKafka/Admin/TopicResult/#class-topicresult","text":"Class \\RdKafka\\Admin\\TopicResult","title":"Class TopicResult"},{"location":"api/RdKafka/Admin/TopicResult/#properties","text":"","title":"Properties"},{"location":"api/RdKafka/Admin/TopicResult/#error","text":"public int error","title":"error"},{"location":"api/RdKafka/Admin/TopicResult/#errorstring","text":"public ? string errorString","title":"errorString"},{"location":"api/RdKafka/Admin/TopicResult/#name","text":"public string name","title":"name"},{"location":"api/RdKafka/Admin/TopicResult/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Admin/TopicResult/#__construct","text":"public __construct ( \\FFI\\CData $result ) : Parameters result \\FFI\\CData","title":"__construct()"},{"location":"api/RdKafka/Admin/TopicResult/#test-coverage","text":"\ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/CallbackProxy/","text":"Class CallbackProxy \u00b6 abstract Class \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 create() \u00b6 public static create ( callable $callback ) : \\Closure Parameters callback callable Returns \\Closure Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (2 / 2) Extended by \u00b6 \\RdKafka\\FFI\\ConsumeCallbackProxy \\RdKafka\\FFI\\DrMsgCallbackProxy \\RdKafka\\FFI\\ErrorCallbackProxy \\RdKafka\\FFI\\LogCallbackProxy \\RdKafka\\FFI\\OffsetCommitCallbackProxy \\RdKafka\\FFI\\PartitionerCallbackProxy \\RdKafka\\FFI\\RebalanceCallbackProxy \\RdKafka\\FFI\\StatsCallbackProxy","title":"CallbackProxy"},{"location":"api/RdKafka/FFI/CallbackProxy/#class-callbackproxy","text":"abstract Class \\RdKafka\\FFI\\CallbackProxy","title":"Class CallbackProxy"},{"location":"api/RdKafka/FFI/CallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/CallbackProxy/#create","text":"public static create ( callable $callback ) : \\Closure Parameters callback callable Returns \\Closure","title":"create()"},{"location":"api/RdKafka/FFI/CallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (2 / 2)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/CallbackProxy/#extended-by","text":"\\RdKafka\\FFI\\ConsumeCallbackProxy \\RdKafka\\FFI\\DrMsgCallbackProxy \\RdKafka\\FFI\\ErrorCallbackProxy \\RdKafka\\FFI\\LogCallbackProxy \\RdKafka\\FFI\\OffsetCommitCallbackProxy \\RdKafka\\FFI\\PartitionerCallbackProxy \\RdKafka\\FFI\\RebalanceCallbackProxy \\RdKafka\\FFI\\StatsCallbackProxy","title":"Extended by"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/","text":"Class ConsumeCallbackProxy \u00b6 Class \\RdKafka\\FFI\\ConsumeCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $nativeMessage , ? \\FFI\\CData $opaque = null ) : void Parameters nativeMessage \\FFI\\CData opaque ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"ConsumeCallbackProxy"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#class-consumecallbackproxy","text":"Class \\RdKafka\\FFI\\ConsumeCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class ConsumeCallbackProxy"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $nativeMessage , ? \\FFI\\CData $opaque = null ) : void Parameters nativeMessage \\FFI\\CData opaque ?\\FFI\\CData","title":"__invoke()"},{"location":"api/RdKafka/FFI/ConsumeCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/","text":"Class DrMsgCallbackProxy \u00b6 Class \\RdKafka\\FFI\\DrMsgCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $producer , \\FFI\\CData $nativeMessage , ? \\FFI\\CData $opaque = null ) : void Parameters producer \\FFI\\CData nativeMessage \\FFI\\CData opaque ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"DrMsgCallbackProxy"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#class-drmsgcallbackproxy","text":"Class \\RdKafka\\FFI\\DrMsgCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class DrMsgCallbackProxy"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $producer , \\FFI\\CData $nativeMessage , ? \\FFI\\CData $opaque = null ) : void Parameters producer \\FFI\\CData nativeMessage \\FFI\\CData opaque ?\\FFI\\CData","title":"__invoke()"},{"location":"api/RdKafka/FFI/DrMsgCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/","text":"Class ErrorCallbackProxy \u00b6 Class \\RdKafka\\FFI\\ErrorCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $consumerOrProducer , int $err , string $reason , ? \\FFI\\CData $opaque = null ) : void Parameters consumerOrProducer \\FFI\\CData err int reason string opaque ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"ErrorCallbackProxy"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#class-errorcallbackproxy","text":"Class \\RdKafka\\FFI\\ErrorCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class ErrorCallbackProxy"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $consumerOrProducer , int $err , string $reason , ? \\FFI\\CData $opaque = null ) : void Parameters consumerOrProducer \\FFI\\CData err int reason string opaque ?\\FFI\\CData","title":"__invoke()"},{"location":"api/RdKafka/FFI/ErrorCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/Library/","text":"Class Library \u00b6 Class \\RdKafka\\FFI\\Library uses \\RdKafka\\FFI\\Methods This class is for internal use. It provides access to the low level interface to librdkafka. Best practice is to use high level interfaces like \\RdKafka\\Conf , \\RdKafka\\Producer , \u2026 See also https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html Constants \u00b6 PHP_LIBRARY_VERSION \u00b6 public PHP_LIBRARY_VERSION = '0.4.0' VERSION_AUTODETECT \u00b6 public VERSION_AUTODETECT = '' VERSION_LATEST \u00b6 public VERSION_LATEST = '1.8.2' Methods \u00b6 cast() \u00b6 public static cast ( mixed $type , \\FFI\\CData $ptr ) : \\FFI\\CData Parameters type mixed ptr \\FFI\\CData Returns \\FFI\\CData getClientVersion() \u00b6 public static getClientVersion ( ) : string The client version exposed to the brokers. The version has the format v{phpLibraryVersion}-v{bindingVersion}-librdkafka-v{librdkafkaVersion} - e.g. v0.1.0-dev-v1.5.2-librdkafka-v1.5.2) Returns string getFFI() \u00b6 public static getFFI ( ) : \\FFI Returns \\FFI getLibrary() \u00b6 public static getLibrary ( ) : string Returns string getLibraryVersion() \u00b6 public static getLibraryVersion ( ) : string The version of librdkafka Returns string getVersion() \u00b6 public static getVersion ( ) : string The version of the current binding with librdkafka Returns string hasMethod() \u00b6 public static hasMethod ( string $name ) : bool Whether method is supported by current binding version. Parameters name string Returns bool init() \u00b6 public static init ( string $version = self :: VERSION_AUTODETECT , string $scope = 'RdKafka' , ? string $library = null , ? string $cdef = null ) : void Parameters version string scope string library ?string cdef ?string new() \u00b6 public static new ( string | \\FFI\\CData | mixed $type , bool $owned = true , bool $persistent = false ) : \\FFI\\CData Parameters type string|\\FFI\\CData|mixed owned bool persistent bool Returns \\FFI\\CData preload() \u00b6 public static preload ( string $version = self :: VERSION_AUTODETECT , string $scope = 'RdKafka' , ? string $library = null , ? string $cdef = null ) : \\FFI Parameters version string scope string library ?string cdef ?string Returns \\FFI rd_kafka_AdminOptions_destroy() \u00b6 public static rd_kafka_AdminOptions_destroy ( \\FFI\\CData | null $options ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* rd_kafka_AdminOptions_new() \u00b6 public static rd_kafka_AdminOptions_new ( \\FFI\\CData | null $rk , int $for_api ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* for_api int rd_kafka_admin_op_t Returns \\FFI\\CData|null rd_kafka_AdminOptions_t* rd_kafka_AdminOptions_set_broker() \u00b6 public static rd_kafka_AdminOptions_set_broker ( \\FFI\\CData | null $options , int | null $broker_id , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* broker_id int|null int32_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_opaque() \u00b6 public static rd_kafka_AdminOptions_set_opaque ( \\FFI\\CData | null $options , \\FFI\\CData | object | string | null $opaque ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_AdminOptions_set_operation_timeout() \u00b6 public static rd_kafka_AdminOptions_set_operation_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_request_timeout() \u00b6 public static rd_kafka_AdminOptions_set_request_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only() \u00b6 public static rd_kafka_AdminOptions_set_validate_only ( \\FFI\\CData | null $options , int | null $true_or_false , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* true_or_false int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AlterConfigs() \u00b6 public static rd_kafka_AlterConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_AlterConfigs_result_resources() \u00b6 public static rd_kafka_AlterConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t** rd_kafka_ConfigEntry_is_default() \u00b6 public static rd_kafka_ConfigEntry_is_default ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_read_only() \u00b6 public static rd_kafka_ConfigEntry_is_read_only ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_sensitive() \u00b6 public static rd_kafka_ConfigEntry_is_sensitive ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_synonym() \u00b6 public static rd_kafka_ConfigEntry_is_synonym ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_name() \u00b6 public static rd_kafka_ConfigEntry_name ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char* rd_kafka_ConfigEntry_source() \u00b6 public static rd_kafka_ConfigEntry_source ( \\FFI\\CData | null $entry ) : int Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_synonyms() \u00b6 public static rd_kafka_ConfigEntry_synonyms ( \\FFI\\CData | null $entry , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t** rd_kafka_ConfigEntry_value() \u00b6 public static rd_kafka_ConfigEntry_value ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char* rd_kafka_ConfigResource_configs() \u00b6 public static rd_kafka_ConfigResource_configs ( \\FFI\\CData | null $config , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t** rd_kafka_ConfigResource_destroy() \u00b6 public static rd_kafka_ConfigResource_destroy ( \\FFI\\CData | null $config ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* rd_kafka_ConfigResource_destroy_array() \u00b6 public static rd_kafka_ConfigResource_destroy_array ( \\FFI\\CData | null $config , int | null $config_cnt ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t rd_kafka_ConfigResource_error() \u00b6 public static rd_kafka_ConfigResource_error ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_resp_err_t rd_kafka_ConfigResource_error_string() \u00b6 public static rd_kafka_ConfigResource_error_string ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char* rd_kafka_ConfigResource_name() \u00b6 public static rd_kafka_ConfigResource_name ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char* rd_kafka_ConfigResource_new() \u00b6 public static rd_kafka_ConfigResource_new ( int $restype , string | null $resname ) : \\FFI\\CData | null Parameters restype int rd_kafka_ResourceType_t resname string|null const char* Returns \\FFI\\CData|null rd_kafka_ConfigResource_t* rd_kafka_ConfigResource_set_config() \u00b6 public static rd_kafka_ConfigResource_set_config ( \\FFI\\CData | null $config , string | null $name , string | null $value ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_ConfigResource_type() \u00b6 public static rd_kafka_ConfigResource_type ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_ResourceType_t rd_kafka_ConfigSource_name() \u00b6 public static rd_kafka_ConfigSource_name ( int $confsource ) : string | null Parameters confsource int rd_kafka_ConfigSource_t Returns string|null const char* rd_kafka_CreatePartitions() \u00b6 public static rd_kafka_CreatePartitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_parts , int | null $new_parts_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_CreatePartitions_result_topics() \u00b6 public static rd_kafka_CreatePartitions_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_CreateTopics() \u00b6 public static rd_kafka_CreateTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_topics , int | null $new_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_CreateTopics_result_topics() \u00b6 public static rd_kafka_CreateTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_DeleteConsumerGroupOffsets() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffsets_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffsets_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteConsumerGroupOffsets_destroy() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \\FFI\\CData | null $del_grpoffsets ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t* rd_kafka_DeleteConsumerGroupOffsets_destroy_array() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffset_cnt ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt int|null size_t rd_kafka_DeleteConsumerGroupOffsets_new() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_new ( string | null $group , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters group string|null const char* partitions \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t* rd_kafka_DeleteConsumerGroupOffsets_result_groups() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t** rd_kafka_DeleteGroup_destroy() \u00b6 public static rd_kafka_DeleteGroup_destroy ( \\FFI\\CData | null $del_group ) : void Parameters del_group \\FFI\\CData|null rd_kafka_DeleteGroup_t* rd_kafka_DeleteGroup_destroy_array() \u00b6 public static rd_kafka_DeleteGroup_destroy_array ( \\FFI\\CData | null $del_groups , int | null $del_group_cnt ) : void Parameters del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t rd_kafka_DeleteGroup_new() \u00b6 public static rd_kafka_DeleteGroup_new ( string | null $group ) : \\FFI\\CData | null Parameters group string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteGroup_t* rd_kafka_DeleteGroups() \u00b6 public static rd_kafka_DeleteGroups ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_groups , int | null $del_group_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteGroups_result_groups() \u00b6 public static rd_kafka_DeleteGroups_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t** rd_kafka_DeleteRecords() \u00b6 public static rd_kafka_DeleteRecords ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_records , int | null $del_record_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteRecords_destroy() \u00b6 public static rd_kafka_DeleteRecords_destroy ( \\FFI\\CData | null $del_records ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t* rd_kafka_DeleteRecords_destroy_array() \u00b6 public static rd_kafka_DeleteRecords_destroy_array ( \\FFI\\CData | null $del_records , int | null $del_record_cnt ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t rd_kafka_DeleteRecords_new() \u00b6 public static rd_kafka_DeleteRecords_new ( \\FFI\\CData | null $before_offsets ) : \\FFI\\CData | null Parameters before_offsets \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteRecords_t* rd_kafka_DeleteRecords_result_offsets() \u00b6 public static rd_kafka_DeleteRecords_result_offsets ( \\FFI\\CData | null $result ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t* rd_kafka_DeleteTopic_destroy() \u00b6 public static rd_kafka_DeleteTopic_destroy ( \\FFI\\CData | null $del_topic ) : void Parameters del_topic \\FFI\\CData|null rd_kafka_DeleteTopic_t* rd_kafka_DeleteTopic_destroy_array() \u00b6 public static rd_kafka_DeleteTopic_destroy_array ( \\FFI\\CData | null $del_topics , int | null $del_topic_cnt ) : void Parameters del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t rd_kafka_DeleteTopic_new() \u00b6 public static rd_kafka_DeleteTopic_new ( string | null $topic ) : \\FFI\\CData | null Parameters topic string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteTopic_t* rd_kafka_DeleteTopics() \u00b6 public static rd_kafka_DeleteTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_topics , int | null $del_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteTopics_result_topics() \u00b6 public static rd_kafka_DeleteTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_DescribeConfigs() \u00b6 public static rd_kafka_DescribeConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null const rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DescribeConfigs_result_resources() \u00b6 public static rd_kafka_DescribeConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t** rd_kafka_NewPartitions_destroy() \u00b6 public static rd_kafka_NewPartitions_destroy ( \\FFI\\CData | null $new_parts ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* rd_kafka_NewPartitions_destroy_array() \u00b6 public static rd_kafka_NewPartitions_destroy_array ( \\FFI\\CData | null $new_parts , int | null $new_parts_cnt ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t rd_kafka_NewPartitions_new() \u00b6 public static rd_kafka_NewPartitions_new ( string | null $topic , int | null $new_total_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* new_total_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewPartitions_t* rd_kafka_NewPartitions_set_replica_assignment() \u00b6 public static rd_kafka_NewPartitions_set_replica_assignment ( \\FFI\\CData | null $new_parts , int | null $new_partition_idx , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* new_partition_idx int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_NewTopic_destroy() \u00b6 public static rd_kafka_NewTopic_destroy ( \\FFI\\CData | null $new_topic ) : void Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* rd_kafka_NewTopic_destroy_array() \u00b6 public static rd_kafka_NewTopic_destroy_array ( \\FFI\\CData | null $new_topics , int | null $new_topic_cnt ) : void Parameters new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t rd_kafka_NewTopic_new() \u00b6 public static rd_kafka_NewTopic_new ( string | null $topic , int | null $num_partitions , int | null $replication_factor , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* num_partitions int|null int replication_factor int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewTopic_t* rd_kafka_NewTopic_set_config() \u00b6 public static rd_kafka_NewTopic_set_config ( \\FFI\\CData | null $new_topic , string | null $name , string | null $value ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_NewTopic_set_replica_assignment() \u00b6 public static rd_kafka_NewTopic_set_replica_assignment ( \\FFI\\CData | null $new_topic , int | null $partition , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* partition int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_ResourceType_name() \u00b6 public static rd_kafka_ResourceType_name ( int $restype ) : string | null Parameters restype int rd_kafka_ResourceType_t Returns string|null const char* rd_kafka_abort_transaction() \u00b6 public static rd_kafka_abort_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_assign() \u00b6 public static rd_kafka_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Atomic assignment of partitions to consume. The new partitions will replace the existing assignment. When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state. A zero-length partitions will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a NULL value for partitions will reset and clear the internal state. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9 rd_kafka_assignment() \u00b6 public static rd_kafka_assignment ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Returns the current partition assignment. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise partitions is updated to point to a newly allocated partition list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59 rd_kafka_assignment_lost() \u00b6 public static rd_kafka_assignment_lost ( \\FFI\\CData | null $rk ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int|null int rd_kafka_begin_transaction() \u00b6 public static rd_kafka_begin_transaction ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_brokers_add() \u00b6 public static rd_kafka_brokers_add ( \\FFI\\CData | null $rk , string | null $brokerlist ) : int | null Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata. If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion. brokerlist is a ,-separated list of brokers in the format: <broker1> ,<broker2>,.. Where each broker is in either the host or URL based format: <host> [:<port>] <proto> ://<host>[:port] <proto> is either PLAINTEXT , SSL , SASL , SASL_PLAINTEXT The two formats can be mixed but ultimately the value of the security.protocol config property decides what brokers are allowed. Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\" Remarks Brokers may also be defined with the metadata.broker.list or bootstrap.servers configuration property (preferred method). Parameters rk \\FFI\\CData|null rd_kafka_t* brokerlist string|null const char* Returns int|null int - the number of brokers successfully added. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7 rd_kafka_clusterid() \u00b6 public static rd_kafka_clusterid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null char* rd_kafka_commit() \u00b6 public static rd_kafka_commit ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $async ) : int Commit offsets on broker for the provided list of partitions. offsets should contain topic , partition , offset and possibly metadata . If offsets is NULL the current partition assignment will be used instead. If async is false this operation will block until the broker offset commit is done, returning the resulting success or error code. If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar. Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87 rd_kafka_commit_message() \u00b6 public static rd_kafka_commit_message ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , int | null $async ) : int Commit message's offset on broker for the message's partition. See also rd_kafka_commit Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null rd_kafka_message_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883 rd_kafka_commit_queue() \u00b6 public static rd_kafka_commit_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $cb , \\FFI\\CData | object | string | null $opaque ) : int Commit offsets on broker for the provided list of partitions. See rd_kafka_commit for offsets semantics. The result of the offset commit will be posted on the provided rkqu queue. If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the cb callback is required. opaque is passed to the callback. If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The opaque value will be available with rd_kafka_event_opaque() If rkqu is NULL a temporary queue will be created and the callback will be served by this call. See also rd_kafka_commit() rd_kafka_conf_set_offset_commit_cb() Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47 rd_kafka_commit_transaction() \u00b6 public static rd_kafka_commit_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_committed() \u00b6 public static rd_kafka_committed ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : int Retrieve committed offsets for topics+partitions. The offset field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13 rd_kafka_conf() \u00b6 public static rd_kafka_conf ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null const rd_kafka_conf_t* rd_kafka_conf_destroy() \u00b6 public static rd_kafka_conf_destroy ( \\FFI\\CData | null $conf ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_dump() \u00b6 public static rd_kafka_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c rd_kafka_conf_dump_free() \u00b6 public static rd_kafka_conf_dump_free ( \\FFI\\CData | null $arr , int | null $cnt ) : void Parameters arr \\FFI\\CData|null char** cnt int|null size_t rd_kafka_conf_dup() \u00b6 public static rd_kafka_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_dup_filter() \u00b6 public static rd_kafka_conf_dup_filter ( \\FFI\\CData | null $conf , int | null $filter_cnt , \\FFI\\CData | null $filter ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** Returns \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_get() \u00b6 public static rd_kafka_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve configuration value for property name . If dest is non-NULL the value will be written to dest with at most dest_size . *dest_size is updated to the full length of the value, thus if *dest_size initially is smaller than the full length the application may reallocate dest to fit the returned *dest_size and try again. If dest is NULL only the full length of the value is returned. Fallthrough: Topic-level configuration properties from the default_topic_conf may be retrieved using this interface. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property name matched, else RD_KAFKA_CONF_UNKNOWN . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97 rd_kafka_conf_get_default_topic_conf() \u00b6 public static rd_kafka_conf_get_default_topic_conf ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_conf_interceptor_add_on_conf_destroy() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_dup ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_dup , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_dup \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, rd_kafka_conf_t*, size_t, char**, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_set ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_set , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_set \\FFI\\CData|\\Closure rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new() \u00b6 public static rd_kafka_conf_interceptor_add_on_new ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_new , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_new \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, rd_kafka_conf_t*, void*, char*, size_t) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_new() \u00b6 public static rd_kafka_conf_new ( ) : \\FFI\\CData | null Create configuration object. When providing your own configuration to the rd_kafka_*_new_* () calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: 1 rd_kafka_conf_t *myconf; 2 rd_kafka_conf_res_t res; 3 4 myconf = rd_kafka_conf_new(); 5 res = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\", 6 errstr, sizeof(errstr)); 7 if (res != RD_KAFKA_CONF_OK) 8 die(\"%s\\n\", errstr); 9 10 rk = rd_kafka_new(..., myconf); Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime. The properties are identical to the Apache Kafka configuration properties whenever possible. See also rd_kafka_conf_set(), rd_kafka_conf_destroy() Returns \\FFI\\CData|null rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c rd_kafka_conf_properties_show() \u00b6 public static rd_kafka_conf_properties_show ( \\FFI\\CData | null $fp ) : void Parameters fp \\FFI\\CData|null FILE* rd_kafka_conf_set() \u00b6 public static rd_kafka_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a configuration property. conf must have been previously created with rd_kafka_conf_new(). Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the default_topic_conf . If no default_topic_conf has been set one will be created. Any sub-sequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. In case of failure errstr is updated to contain a human readable error string. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8 rd_kafka_conf_set_background_event_cb() \u00b6 public static rd_kafka_conf_set_background_event_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $event_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_event_t*, void*) rd_kafka_conf_set_closesocket_cb() \u00b6 public static rd_kafka_conf_set_closesocket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $closesocket_cb ) : void Set close socket callback. Close a socket (optionally opened with socket_cb()). Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* closesocket_cb \\FFI\\CData|\\Closure int( )(int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7 rd_kafka_conf_set_connect_cb() \u00b6 public static rd_kafka_conf_set_connect_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $connect_cb ) : void Set connect callback. The connect callback is responsible for connecting socket sockfd to peer address addr . The id field contains the broker identifier. connect_cb shall return 0 on success (socket connected) or an error number (errno) on error. Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* connect_cb \\FFI\\CData|\\Closure int( )(int, struct sockaddr , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040 rd_kafka_conf_set_consume_cb() \u00b6 public static rd_kafka_conf_set_consume_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $consume_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) rd_kafka_conf_set_default_topic_conf() \u00b6 public static rd_kafka_conf_set_default_topic_conf ( \\FFI\\CData | null $conf , \\FFI\\CData | null $tconf ) : void Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* tconf \\FFI\\CData|null rd_kafka_topic_conf_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63 rd_kafka_conf_set_dr_cb() \u00b6 public static rd_kafka_conf_set_dr_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_cb ) : void Deprecated: See rd_kafka_conf_set_dr_msg_cb() Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*, size_t, rd_kafka_resp_err_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f rd_kafka_conf_set_dr_msg_cb() \u00b6 public static rd_kafka_conf_set_dr_msg_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_msg_cb ) : void Producer: Set delivery report callback in provided conf object. The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with err set to indicate the result of the produce request. The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted. An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_msg_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_message_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a rd_kafka_conf_set_engine_callback_data() \u00b6 public static rd_kafka_conf_set_engine_callback_data ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $callback_data ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* callback_data \\FFI\\CData|object|string|null void* rd_kafka_conf_set_error_cb() \u00b6 public static rd_kafka_conf_set_error_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $error_cb ) : void Set error callback in provided conf object. The error callback is used by librdkafka to signal critical errors back to the application. If no error_cb is registered then the errors will be logged instead. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* error_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90 rd_kafka_conf_set_events() \u00b6 public static rd_kafka_conf_set_events ( \\FFI\\CData | null $conf , int | null $events ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* events int|null int rd_kafka_conf_set_log_cb() \u00b6 public static rd_kafka_conf_set_log_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $log_cb ) : void Set logger callback. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass func as NULL to disable logging. This is the configuration alternative to the deprecated rd_kafka_set_logger() Remarks The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through rd_kafka_set_log_queue() . An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded log_cb . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* log_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f rd_kafka_conf_set_oauthbearer_token_refresh_cb() \u00b6 public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $oauthbearer_token_refresh_cb ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* oauthbearer_token_refresh_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, void*) rd_kafka_conf_set_offset_commit_cb() \u00b6 public static rd_kafka_conf_set_offset_commit_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $offset_commit_cb ) : void Consumer: Set offset commit callback for use with consumer groups. The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll(). If no partitions had valid offsets to commit this callback will be called with err == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error. The offsets list contains per-partition information: offset: committed offset (attempted) err: commit error Parameters conf \\FFI\\CData|null rd_kafka_conf_t* offset_commit_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb rd_kafka_conf_set_opaque() \u00b6 public static rd_kafka_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_conf_set_rebalance_cb() \u00b6 public static rd_kafka_conf_set_rebalance_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $rebalance_cb ) : void Consumer: Set rebalance callback for use with coordinated consumer group balancing. The err field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked. Registering a rebalance_cb turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's rebalance_cb . The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where err is neither of those. Remarks In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke). Remarks The partitions list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application. The following example shows the application's responsibilities: 1 static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err, 2 rd_kafka_topic_partition_list_t *partitions, 3 void *opaque) { 4 5 switch (err) 6 { 7 case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS: 8 // application may load offets from arbitrary external 9 // storage here and update \\p partitions 10 11 rd_kafka_assign(rk, partitions); 12 break; 13 14 case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS: 15 if (manual_commits) // Optional explicit manual commit 16 rd_kafka_commit(rk, partitions, 0); // sync commit 17 18 rd_kafka_assign(rk, NULL); 19 break; 20 21 default: 22 handle_unlikely_error(err); 23 rd_kafka_assign(rk, NULL); // sync state 24 break; 25 } 26 } Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rebalance_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311 rd_kafka_conf_set_socket_cb() \u00b6 public static rd_kafka_conf_set_socket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $socket_cb ) : void Set socket callback. The socket callback is responsible for opening a socket according to the supplied domain , type and protocol . The socket shall be created with CLOEXEC set in a racefree fashion, if possible. Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* socket_cb \\FFI\\CData|\\Closure int( )(int, int, int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf rd_kafka_conf_set_ssl_cert() \u00b6 public static rd_kafka_conf_set_ssl_cert ( \\FFI\\CData | null $conf , int $cert_type , int $cert_enc , \\FFI\\CData | object | string | null $buffer , int | null $size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* cert_type int rd_kafka_cert_type_t cert_enc int rd_kafka_cert_enc_t buffer \\FFI\\CData|object|string|null void* size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert_verify_cb() \u00b6 public static rd_kafka_conf_set_ssl_cert_verify_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $ssl_cert_verify_cb ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* ssl_cert_verify_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns int rd_kafka_conf_res_t rd_kafka_conf_set_stats_cb() \u00b6 public static rd_kafka_conf_set_stats_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $stats_cb ) : void Set statistics callback in provided conf object. The statistics callback is triggered from rd_kafka_poll() every statistics.interval.ms (needs to be configured separately). Function arguments: rk - Kafka handle json - String containing the statistics data in JSON format json_len - Length of json string. opaque - Application-provided opaque. If the application wishes to hold on to the json pointer and free it at a later time it must return 1 from the stats_cb . If the application returns 0 from the stats_cb then librdkafka will immediately free the json pointer. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* stats_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , char*, size_t, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766 rd_kafka_conf_set_throttle_cb() \u00b6 public static rd_kafka_conf_set_throttle_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $throttle_cb ) : void Set throttle callback. The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests. Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero. An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks. Remarks Requires broker version 0.9.0 or later. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* throttle_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, int32_t, int, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7 rd_kafka_consume() \u00b6 public static rd_kafka_consume ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms ) : \\FFI\\CData | null Consume a single message from topic rkt and partition . timeout_ms is maximum amount of time to wait for a message to be received. Consumer must have been previously started with rd_kafka_consume_start() . Returns a message object on success or NULL on error. The message object must be destroyed with rd_kafka_message_destroy() when the application is done with it. Errors (when returning NULL): ETIMEDOUT - timeout_ms was reached with no new messages fetched. ENOENT - rkt + partition is unknown. (no prior rd_kafka_consume_start() call) NOTE: The returned message's ..->err must be checked for errors. NOTE: ..->err == RD_KAFKA_RESP_ERR__PARTITION_EOF signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore). Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e rd_kafka_consume_batch() \u00b6 public static rd_kafka_consume_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the application provided array rkmessages (of size rkmessages_size entries). rd_kafka_consume_batch() provides higher throughput performance than rd_kafka_consume() . timeout_ms is the maximum amount of time to wait for all of rkmessages_size messages to be put into rkmessages . If no messages were available within the timeout period this function returns 0 and rkmessages remains untouched. This differs somewhat from rd_kafka_consume() . The message objects must be destroyed with rd_kafka_message_destroy() when the application is done with it. See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t - the number of rkmessages added in rkmessages , or -1 on error (same error codes as for rd_kafka_consume() . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce rd_kafka_consume_batch_queue() \u00b6 public static rd_kafka_consume_batch_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume batch of messages from queue. See also rd_kafka_consume_batch() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3d949238471993b18537855aad28fa23 rd_kafka_consume_callback() \u00b6 public static rd_kafka_consume_callback ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consumes messages from topic rkt and partition , calling the provided callback for each consumed messsage. rd_kafka_consume_callback() provides higher throughput performance than both rd_kafka_consume() and rd_kafka_consume_batch() . timeout_ms is the maximum amount of time to wait for one or more messages to arrive. The provided consume_cb function is called for each message, the application MUST NOT call rd_kafka_message_destroy() on the provided rkmessage . The opaque argument is passed to the 'consume_cb' as opaque . See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int - the number of messages processed or -1 on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6 rd_kafka_consume_callback_queue() \u00b6 public static rd_kafka_consume_callback_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consume multiple messages from queue with callback. See also rd_kafka_consume_callback() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532 rd_kafka_consume_queue() \u00b6 public static rd_kafka_consume_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Consume from queue. See also rd_kafka_consume() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16 rd_kafka_consume_start() \u00b6 public static rd_kafka_consume_start ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int | null Start consuming messages for topic rkt and partition at offset offset which may either be an absolute (0..N) or one of the logical offsets: RD_KAFKA_OFFSET_BEGINNING RD_KAFKA_OFFSET_END RD_KAFKA_OFFSET_STORED RD_KAFKA_OFFSET_TAIL rdkafka will attempt to keep queued.min.messages (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached. The application shall use one of the rd_kafka_consume*() functions to consume messages from the local queue, each kafka message being represented as a rd_kafka_message_t * object. rd_kafka_consume_start() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . Use rd_kafka_errno2err() to convert sytem errno to rd_kafka_resp_err_t Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int|null int - 0 on success or -1 on error in which case errno is set accordingly: EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT) EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG) ESRCH - requested partition is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4 rd_kafka_consume_start_queue() \u00b6 public static rd_kafka_consume_start_queue ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , \\FFI\\CData | null $rkqu ) : int | null Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which must have been previously allocated with rd_kafka_queue_new() . The application must use one of the rd_kafka_consume_*_queue() functions to receive fetched messages. rd_kafka_consume_start_queue() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . rd_kafka_consume_start() and rd_kafka_consume_start_queue() must not be combined for the same topic and partition. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t rkqu \\FFI\\CData|null rd_kafka_queue_t* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258 rd_kafka_consume_stop() \u00b6 public static rd_kafka_consume_stop ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Stop consuming messages for topic rkt and partition , purging all messages currently in the local queue. NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method. The application needs to be stop all consumers before calling rd_kafka_destroy() on the main object handle. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 0 on success or -1 on error (see errno ). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4 rd_kafka_consumer_close() \u00b6 public static rd_kafka_consumer_close ( \\FFI\\CData | null $rk ) : int Close down the KafkaConsumer. Remarks This call will block until the consumer has revoked its assignment, calling the rebalance_cb if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms. Remarks The application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d rd_kafka_consumer_group_metadata() \u00b6 public static rd_kafka_consumer_group_metadata ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_destroy() \u00b6 public static rd_kafka_consumer_group_metadata_destroy ( \\FFI\\CData | null $arg0 ) : void Parameters arg0 \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_new() \u00b6 public static rd_kafka_consumer_group_metadata_new ( string | null $group_id ) : \\FFI\\CData | null Parameters group_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_new_with_genid() \u00b6 public static rd_kafka_consumer_group_metadata_new_with_genid ( string | null $group_id , int | null $generation_id , string | null $member_id , string | null $group_instance_id ) : \\FFI\\CData | null Parameters group_id string|null const char* generation_id int|null int32_t member_id string|null const char* group_instance_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_read() \u00b6 public static rd_kafka_consumer_group_metadata_read ( \\FFI\\CData | null $cgmdp , \\FFI\\CData | object | string | null $buffer , int | null $size ) : \\FFI\\CData | null Parameters cgmdp \\FFI\\CData|null rd_kafka_consumer_group_metadata_t** buffer \\FFI\\CData|object|string|null void* size int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_consumer_group_metadata_write() \u00b6 public static rd_kafka_consumer_group_metadata_write ( \\FFI\\CData | null $cgmd , \\FFI\\CData | object | string | null $bufferp , \\FFI\\CData | null $sizep ) : \\FFI\\CData | null Parameters cgmd \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* bufferp \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_consumer_poll() \u00b6 public static rd_kafka_consumer_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Poll the consumer for messages or events. Will block for at most timeout_ms milliseconds. Remarks An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. See also rd_kafka_message_t Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* - A message object which is a proper message if ->err is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf rd_kafka_controllerid() \u00b6 public static rd_kafka_controllerid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int32_t rd_kafka_default_topic_conf_dup() \u00b6 public static rd_kafka_default_topic_conf_dup ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_destroy() \u00b6 public static rd_kafka_destroy ( \\FFI\\CData | null $rk ) : void Destroy Kafka handle. Remarks This is a blocking operation. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794 rd_kafka_destroy_flags() \u00b6 public static rd_kafka_destroy_flags ( \\FFI\\CData | null $rk , int | null $flags ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* flags int|null int rd_kafka_dump() \u00b6 public static rd_kafka_dump ( \\FFI\\CData | null $fp , \\FFI\\CData | null $rk ) : void Dumps rdkafka's internal state for handle rk to stream fp . This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. Parameters fp \\FFI\\CData|null FILE* rk \\FFI\\CData|null rd_kafka_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1 rd_kafka_err2name() \u00b6 public static rd_kafka_err2name ( int $err ) : string | null Returns the error code name (enum name). Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77 rd_kafka_err2str() \u00b6 public static rd_kafka_err2str ( int $err ) : string | null Returns a human readable representation of a kafka error. Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d rd_kafka_errno() \u00b6 public static rd_kafka_errno ( ) : int | null Returns the thread-local system errno. On most platforms this is the same as errno but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for expsing the errno librdkafka uses. Remarks The value is local to the current calling thread. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aef27224d8c638e51f3ee29bb25f65f1f rd_kafka_errno2err() \u00b6 public static rd_kafka_errno2err ( int | null $errnox ) : int Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the following functions: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() Remarks A better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. See also rd_kafka_last_error() Parameters errnox int|null int - ) - System errno value to convert Returns int rd_kafka_resp_err_t - Appropriate error code for errnox See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f rd_kafka_error_code() \u00b6 public static rd_kafka_error_code ( \\FFI\\CData | null $error ) : int Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int rd_kafka_resp_err_t rd_kafka_error_destroy() \u00b6 public static rd_kafka_error_destroy ( \\FFI\\CData | null $error ) : void Parameters error \\FFI\\CData|null rd_kafka_error_t* rd_kafka_error_is_fatal() \u00b6 public static rd_kafka_error_is_fatal ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_error_is_retriable() \u00b6 public static rd_kafka_error_is_retriable ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_error_name() \u00b6 public static rd_kafka_error_name ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char* rd_kafka_error_new() \u00b6 public static rd_kafka_error_new ( int $code , string | null $fmt , mixed $args ) : \\FFI\\CData | null Parameters code int rd_kafka_resp_err_t fmt string|null const char* args mixed Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_error_string() \u00b6 public static rd_kafka_error_string ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char* rd_kafka_error_txn_requires_abort() \u00b6 public static rd_kafka_error_txn_requires_abort ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_event_AlterConfigs_result() \u00b6 public static rd_kafka_event_AlterConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* rd_kafka_event_CreatePartitions_result() \u00b6 public static rd_kafka_event_CreatePartitions_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* rd_kafka_event_CreateTopics_result() \u00b6 public static rd_kafka_event_CreateTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* rd_kafka_event_DeleteConsumerGroupOffsets_result() \u00b6 public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* rd_kafka_event_DeleteGroups_result() \u00b6 public static rd_kafka_event_DeleteGroups_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* rd_kafka_event_DeleteRecords_result() \u00b6 public static rd_kafka_event_DeleteRecords_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* rd_kafka_event_DeleteTopics_result() \u00b6 public static rd_kafka_event_DeleteTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* rd_kafka_event_DescribeConfigs_result() \u00b6 public static rd_kafka_event_DescribeConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* rd_kafka_event_config_string() \u00b6 public static rd_kafka_event_config_string ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char* rd_kafka_event_debug_contexts() \u00b6 public static rd_kafka_event_debug_contexts ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $dst , int | null $dstsize ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* dst \\FFI\\CData|null char* dstsize int|null size_t Returns int|null int rd_kafka_event_destroy() \u00b6 public static rd_kafka_event_destroy ( \\FFI\\CData | null $rkev ) : void Destroy an event. Remarks Any references to this event, such as extracted messages, will not be usable after this call. As a convenience it is okay to pass rkev as NULL in which case no action is performed. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af1835c85aa202caf629861f29f475099 rd_kafka_event_error() \u00b6 public static rd_kafka_event_error ( \\FFI\\CData | null $rkev ) : int Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int rd_kafka_resp_err_t - the error code for the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5 rd_kafka_event_error_is_fatal() \u00b6 public static rd_kafka_event_error_is_fatal ( \\FFI\\CData | null $rkev ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns int|null int rd_kafka_event_error_string() \u00b6 public static rd_kafka_event_error_string ( \\FFI\\CData | null $rkev ) : string | null Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793 rd_kafka_event_log() \u00b6 public static rd_kafka_event_log ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $fac , \\FFI\\CData | null $str , \\FFI\\CData | null $level ) : int | null Extract log message from the event. Event types: RD_KAFKA_EVENT_LOG Parameters rkev \\FFI\\CData|null rd_kafka_event_t* fac \\FFI\\CData|null char** str \\FFI\\CData|null char** level \\FFI\\CData|null int* Returns int|null int - 0 on success or -1 if unsupported event type. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7 rd_kafka_event_message_array() \u00b6 public static rd_kafka_event_message_array ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $rkmessages , int | null $size ) : int | null Extacts size message(s) from the event into the pre-allocated array rkmessages . Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* rkmessages \\FFI\\CData|null const rd_kafka_message_t** size int|null size_t Returns int|null size_t - the number of messages extracted. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8 rd_kafka_event_message_count() \u00b6 public static rd_kafka_event_message_count ( \\FFI\\CData | null $rkev ) : int | null Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null size_t - the number of remaining messages in the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90 rd_kafka_event_message_next() \u00b6 public static rd_kafka_event_message_next ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Call repeatedly until it returns NULL. Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Remarks The returned message(s) MUST NOT be freed with rd_kafka_message_destroy(). Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null const rd_kafka_message_t* - the next message from an event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c rd_kafka_event_name() \u00b6 public static rd_kafka_event_name ( \\FFI\\CData | null $rkev ) : string | null Remarks As a convenience it is okay to pass rkev as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the event type\u2019s name for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866 rd_kafka_event_opaque() \u00b6 public static rd_kafka_event_opaque ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | object | string | null Event types: RD_KAFKA_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|object|string|null void* - the user opaque (if any) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525 rd_kafka_event_stats() \u00b6 public static rd_kafka_event_stats ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char* rd_kafka_event_topic_partition() \u00b6 public static rd_kafka_event_topic_partition ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe rd_kafka_event_topic_partition_list() \u00b6 public static rd_kafka_event_topic_partition_list ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() Event types: RD_KAFKA_EVENT_REBALANCE RD_KAFKA_EVENT_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - the topic partition list from the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633 rd_kafka_event_type() \u00b6 public static rd_kafka_event_type ( \\FFI\\CData | null $rkev ) : int | null Remarks As a convenience it is okay to pass rkev as NULL in which case RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null rd_kafka_event_type_t - the event type for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d rd_kafka_fatal_error() \u00b6 public static rd_kafka_fatal_error ( \\FFI\\CData | null $rk , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_flush() \u00b6 public static rd_kafka_flush ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. Remarks This function will call rd_kafka_poll() and thus trigger callbacks. Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if timeout_ms was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d rd_kafka_get_debug_contexts() \u00b6 public static rd_kafka_get_debug_contexts ( ) : string | null Retrieve supported debug contexts for use with the \"debug\" configuration property. (runtime) Returns string|null const char* - ) - Comma-separated list of available debugging contexts. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45 rd_kafka_get_err_descs() \u00b6 public static rd_kafka_get_err_descs ( \\FFI\\CData | null $errdescs , \\FFI\\CData | null $cntp ) : void Parameters errdescs \\FFI\\CData|null struct rd_kafka_err_desc** cntp \\FFI\\CData|null size_t* rd_kafka_get_watermark_offsets() \u00b6 public static rd_kafka_get_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high ) : int Get last known low (oldest/beginning) and high (newest/end) offsets for partition. The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker. If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset. Offsets are returned in *low and *high respectively. Remarks Shall only be used with an active consumer instance. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82 rd_kafka_group_list_destroy() \u00b6 public static rd_kafka_group_list_destroy ( \\FFI\\CData | null $grplist ) : void Parameters grplist \\FFI\\CData|null struct rd_kafka_group_list* rd_kafka_group_result_error() \u00b6 public static rd_kafka_group_result_error ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_error_t* rd_kafka_group_result_name() \u00b6 public static rd_kafka_group_result_name ( \\FFI\\CData | null $groupres ) : string | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns string|null const char* rd_kafka_group_result_partitions() \u00b6 public static rd_kafka_group_result_partitions ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t* rd_kafka_handle_mock_cluster() \u00b6 public static rd_kafka_handle_mock_cluster ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_header_add() \u00b6 public static rd_kafka_header_add ( \\FFI\\CData | null $hdrs , string | null $name , int | null $name_size , \\FFI\\CData | object | string | null $value , int | null $value_size ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* name_size int|null ssize_t value \\FFI\\CData|object|string|null void* value_size int|null ssize_t Returns int rd_kafka_resp_err_t rd_kafka_header_cnt() \u00b6 public static rd_kafka_header_cnt ( \\FFI\\CData | null $hdrs ) : int | null Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* Returns int|null size_t rd_kafka_header_get() \u00b6 public static rd_kafka_header_get ( \\FFI\\CData | null $hdrs , int | null $idx , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_header_get_all() \u00b6 public static rd_kafka_header_get_all ( \\FFI\\CData | null $hdrs , int | null $idx , \\FFI\\CData | null $namep , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t namep \\FFI\\CData|null char** valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_header_get_last() \u00b6 public static rd_kafka_header_get_last ( \\FFI\\CData | null $hdrs , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_header_remove() \u00b6 public static rd_kafka_header_remove ( \\FFI\\CData | null $hdrs , string | null $name ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_headers_copy() \u00b6 public static rd_kafka_headers_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Parameters src \\FFI\\CData|null rd_kafka_headers_t* Returns \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_headers_destroy() \u00b6 public static rd_kafka_headers_destroy ( \\FFI\\CData | null $hdrs ) : void Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_headers_new() \u00b6 public static rd_kafka_headers_new ( int | null $initial_count ) : \\FFI\\CData | null Parameters initial_count int|null size_t Returns \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_incremental_assign() \u00b6 public static rd_kafka_incremental_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_incremental_unassign() \u00b6 public static rd_kafka_incremental_unassign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_init_transactions() \u00b6 public static rd_kafka_init_transactions ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_interceptor_add_on_acknowledgement() \u00b6 public static rd_kafka_interceptor_add_on_acknowledgement ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_acknowledgement , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_acknowledgement \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit() \u00b6 public static rd_kafka_interceptor_add_on_commit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_commit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_commit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume() \u00b6 public static rd_kafka_interceptor_add_on_consume ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_consume , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_consume \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy() \u00b6 public static rd_kafka_interceptor_add_on_destroy ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent() \u00b6 public static rd_kafka_interceptor_add_on_request_sent ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_request_sent , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_request_sent \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received() \u00b6 public static rd_kafka_interceptor_add_on_response_received ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_response_received , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_response_received \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send() \u00b6 public static rd_kafka_interceptor_add_on_send ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_send , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_send \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit() \u00b6 public static rd_kafka_interceptor_add_on_thread_exit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_exit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_exit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start() \u00b6 public static rd_kafka_interceptor_add_on_thread_start ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_start , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_start \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_acknowledgement_t() \u00b6 public static rd_kafka_interceptor_f_on_acknowledgement_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_commit_t() \u00b6 public static rd_kafka_interceptor_f_on_commit_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_conf_destroy_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_destroy_t ( \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_conf_dup_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_dup_t ( \\FFI\\CData | null $new_conf , \\FFI\\CData | null $old_conf , int | null $filter_cnt , \\FFI\\CData | null $filter , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters new_conf \\FFI\\CData|null rd_kafka_conf_t* old_conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_conf_set_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_set_t ( \\FFI\\CData | null $conf , string | null $name , string | null $val , \\FFI\\CData | null $errstr , int | null $errstr_size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* val string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_conf_res_t rd_kafka_interceptor_f_on_consume_t() \u00b6 public static rd_kafka_interceptor_f_on_consume_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_destroy_t() \u00b6 public static rd_kafka_interceptor_f_on_destroy_t ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_new_t() \u00b6 public static rd_kafka_interceptor_f_on_new_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $ic_opaque , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* conf \\FFI\\CData|null rd_kafka_conf_t* ic_opaque \\FFI\\CData|object|string|null void* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_request_sent_t() \u00b6 public static rd_kafka_interceptor_f_on_request_sent_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_response_received_t() \u00b6 public static rd_kafka_interceptor_f_on_response_received_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , int | null $rtt , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t rtt int|null int64_t err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_send_t() \u00b6 public static rd_kafka_interceptor_f_on_send_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_thread_exit_t() \u00b6 public static rd_kafka_interceptor_f_on_thread_exit_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_thread_start_t() \u00b6 public static rd_kafka_interceptor_f_on_thread_start_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_last_error() \u00b6 public static rd_kafka_last_error ( ) : int Returns the last error code generated by a legacy API call in the current thread. The legacy APIs are the ones using errno to propagate error value, namely: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() The main use for this function is to avoid converting system errno values to rd_kafka_resp_err_t codes for legacy APIs. Remarks The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call. Returns int rd_kafka_resp_err_t - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7 rd_kafka_list_groups() \u00b6 public static rd_kafka_list_groups ( \\FFI\\CData | null $rk , string | null $group , \\FFI\\CData | null $grplistp , int | null $timeout_ms ) : int List and describe client groups in cluster. group is an optional group name to describe, otherwise ( NULL ) all groups are returned. timeout_ms is the (approximate) maximum time to wait for response from brokers and must be a positive value. See also Use rd_kafka_group_list_destroy() to release list memory. Parameters rk \\FFI\\CData|null rd_kafka_t* group string|null const char* grplistp \\FFI\\CData|null struct rd_kafka_group_list** timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success and grplistp is updated to point to a newly allocated list of groups. Else returns an error code on failure and grplistp remains untouched. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a rd_kafka_log_print() \u00b6 public static rd_kafka_log_print ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char* rd_kafka_log_syslog() \u00b6 public static rd_kafka_log_syslog ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char* rd_kafka_mem_calloc() \u00b6 public static rd_kafka_mem_calloc ( \\FFI\\CData | null $rk , int | null $num , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* num int|null size_t size int|null size_t Returns \\FFI\\CData|object|string|null void* rd_kafka_mem_free() \u00b6 public static rd_kafka_mem_free ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ptr ) : void Free pointer returned by librdkafka. This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka. In standard setups it is usually not necessary to use this interface rather than the free(3) functione. Remarks rd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing. Parameters rk \\FFI\\CData|null rd_kafka_t* ptr \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572 rd_kafka_mem_malloc() \u00b6 public static rd_kafka_mem_malloc ( \\FFI\\CData | null $rk , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* size int|null size_t Returns \\FFI\\CData|object|string|null void* rd_kafka_memberid() \u00b6 public static rd_kafka_memberid ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Returns this client's broker-assigned group member id. Remarks This currently requires the high-level KafkaConsumer Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with free() or rd_kafka_mem_free() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6 rd_kafka_message_broker_id() \u00b6 public static rd_kafka_message_broker_id ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int32_t rd_kafka_message_destroy() \u00b6 public static rd_kafka_message_destroy ( \\FFI\\CData | null $rkmessage ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* rd_kafka_message_detach_headers() \u00b6 public static rd_kafka_message_detach_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t rd_kafka_message_errstr() \u00b6 public static rd_kafka_message_errstr ( \\FFI\\CData | null $rkmessage ) : string | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns string|null const char* rd_kafka_message_headers() \u00b6 public static rd_kafka_message_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t rd_kafka_message_latency() \u00b6 public static rd_kafka_message_latency ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int64_t rd_kafka_message_set_headers() \u00b6 public static rd_kafka_message_set_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrs ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrs \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_message_status() \u00b6 public static rd_kafka_message_status ( \\FFI\\CData | null $rkmessage ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int rd_kafka_msg_status_t rd_kafka_message_timestamp() \u00b6 public static rd_kafka_message_timestamp ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $tstype ) : int | null Returns the message timestamp for a consumed message. The timestamp is the number of milliseconds since the epoch (UTC). tstype (if not NULL) is updated to indicate the type of timestamp. Remarks Message timestamps require broker version 0.10.0 or later. Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* tstype \\FFI\\CData|null rd_kafka_timestamp_type_t* Returns int|null int64_t - message timestamp, or -1 if not available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7 rd_kafka_metadata() \u00b6 public static rd_kafka_metadata ( \\FFI\\CData | null $rk , int | null $all_topics , \\FFI\\CData | null $only_rkt , \\FFI\\CData | null $metadatap , int | null $timeout_ms ) : int Request Metadata from broker. Parameters: all_topics if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics. only_rkt only request info about this topic metadatap pointer to hold metadata result. The *metadatap pointer must be released with rd_kafka_metadata_destroy(). timeout_ms maximum response time before failing. Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. Parameters rk \\FFI\\CData|null rd_kafka_t* all_topics int|null int only_rkt \\FFI\\CData|null rd_kafka_topic_t* metadatap \\FFI\\CData|null struct rd_kafka_metadata** timeout_ms int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344 rd_kafka_metadata_destroy() \u00b6 public static rd_kafka_metadata_destroy ( \\FFI\\CData | \\Closure $metadata ) : void Parameters metadata \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, struct rd_kafka_metadata**, int) rd_kafka_mock_broker_push_request_error_rtts() \u00b6 public static rd_kafka_mock_broker_push_request_error_rtts ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_push_request_errors() \u00b6 public static rd_kafka_mock_broker_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_down() \u00b6 public static rd_kafka_mock_broker_set_down ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack() \u00b6 public static rd_kafka_mock_broker_set_rack ( \\FFI\\CData | null $mcluster , int | null $broker_id , string | null $rack ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rack string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt() \u00b6 public static rd_kafka_mock_broker_set_rtt ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $rtt_ms ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rtt_ms int|null int Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_up() \u00b6 public static rd_kafka_mock_broker_set_up ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_clear_request_errors() \u00b6 public static rd_kafka_mock_clear_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t rd_kafka_mock_cluster_bootstraps() \u00b6 public static rd_kafka_mock_cluster_bootstraps ( \\FFI\\CData | null $mcluster ) : string | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns string|null const char* rd_kafka_mock_cluster_destroy() \u00b6 public static rd_kafka_mock_cluster_destroy ( \\FFI\\CData | null $mcluster ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_mock_cluster_handle() \u00b6 public static rd_kafka_mock_cluster_handle ( \\FFI\\CData | null $mcluster ) : \\FFI\\CData | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns \\FFI\\CData|null rd_kafka_t* rd_kafka_mock_cluster_new() \u00b6 public static rd_kafka_mock_cluster_new ( \\FFI\\CData | null $rk , int | null $broker_cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* broker_cnt int|null int Returns \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_mock_coordinator_set() \u00b6 public static rd_kafka_mock_coordinator_set ( \\FFI\\CData | null $mcluster , string | null $key_type , string | null $key , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* key_type string|null const char* key string|null const char* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower() \u00b6 public static rd_kafka_mock_partition_set_follower ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks() \u00b6 public static rd_kafka_mock_partition_set_follower_wmarks ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $lo , int | null $hi ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t lo int|null int64_t hi int|null int64_t Returns int rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader() \u00b6 public static rd_kafka_mock_partition_set_leader ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_push_request_errors() \u00b6 public static rd_kafka_mock_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , mixed $args ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t args mixed rd_kafka_mock_push_request_errors_array() \u00b6 public static rd_kafka_mock_push_request_errors_array ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , \\FFI\\CData | null $errors ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t errors \\FFI\\CData|null rd_kafka_resp_err_t* rd_kafka_mock_set_apiversion() \u00b6 public static rd_kafka_mock_set_apiversion ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $MinVersion , int | null $MaxVersion ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t MinVersion int|null int16_t MaxVersion int|null int16_t Returns int rd_kafka_resp_err_t rd_kafka_mock_topic_create() \u00b6 public static rd_kafka_mock_topic_create ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition_cnt , int | null $replication_factor ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition_cnt int|null int replication_factor int|null int Returns int rd_kafka_resp_err_t rd_kafka_mock_topic_set_error() \u00b6 public static rd_kafka_mock_topic_set_error ( \\FFI\\CData | null $mcluster , string | null $topic , int $err ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* err int rd_kafka_resp_err_t rd_kafka_msg_partitioner_consistent() \u00b6 public static rd_kafka_msg_partitioner_consistent ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent partitioner. Uses consistent hashing to map identical keys onto identical partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef rd_kafka_msg_partitioner_consistent_random() \u00b6 public static rd_kafka_msg_partitioner_consistent_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent-Random partitioner. This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key (if provided) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb rd_kafka_msg_partitioner_fnv1a() \u00b6 public static rd_kafka_msg_partitioner_fnv1a ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_fnv1a_random() \u00b6 public static rd_kafka_msg_partitioner_fnv1a_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_murmur2() \u00b6 public static rd_kafka_msg_partitioner_murmur2 ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_murmur2_random() \u00b6 public static rd_kafka_msg_partitioner_murmur2_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_random() \u00b6 public static rd_kafka_msg_partitioner_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Random partitioner. Will try not to return unavailable partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a random partition between 0 and partition_cnt - 1. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8 rd_kafka_name() \u00b6 public static rd_kafka_name ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char* rd_kafka_new() \u00b6 public static rd_kafka_new ( int $type , \\FFI\\CData | null $conf , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Creates a new Kafka handle and starts its operation according to the specified type ( RD_KAFKA_CONSUMER or RD_KAFKA_PRODUCER ). conf is an optional struct created with rd_kafka_conf_new() that will be used instead of the default configuration. The conf object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See rd_kafka_conf_set() et.al for more information. errstr must be a pointer to memory of at least size errstr_size where rd_kafka_new() may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL. Remarks RD_KAFKA_CONSUMER: When a new RD_KAFKA_CONSUMER rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API. An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See also To destroy the Kafka handle, use rd_kafka_destroy(). Parameters type int rd_kafka_type_t conf \\FFI\\CData|null rd_kafka_conf_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_t* - The Kafka handle on success or NULL on error (see errstr ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24 rd_kafka_oauthbearer_set_token() \u00b6 public static rd_kafka_oauthbearer_set_token ( \\FFI\\CData | null $rk , string | null $token_value , int | null $md_lifetime_ms , string | null $md_principal_name , \\FFI\\CData | null $extensions , int | null $extension_size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* token_value string|null const char* md_lifetime_ms int|null int64_t md_principal_name string|null const char* extensions \\FFI\\CData|null char** extension_size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure() \u00b6 public static rd_kafka_oauthbearer_set_token_failure ( \\FFI\\CData | null $rk , string | null $errstr ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_offset_store() \u00b6 public static rd_kafka_offset_store ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int Store offset offset for topic rkt partition partition . The offset will be committed (written) to the offset store according to auto.commit.interval.ms . Remarks auto.commit.enable must be set to \"false\" when using this API. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4 rd_kafka_offsets_for_times() \u00b6 public static rd_kafka_offsets_for_times ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $timeout_ms ) : int Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition. The timestamps to query are represented as offset in offsets on input, and offset will contain the offset on output. The function will block for at most timeout_ms milliseconds. Remarks Duplicate Topic+Partitions are not supported. Per-partition errors may be returned in rd_kafka_topic_partition_t.err Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - an error code for general errors, else RD_KAFKA_RESP_ERR_NO_ERROR in which case per-partition errors might be set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929 rd_kafka_offsets_store() \u00b6 public static rd_kafka_offsets_store ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t rd_kafka_opaque() \u00b6 public static rd_kafka_opaque ( \\FFI\\CData | null $rk ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|object|string|null void* rd_kafka_outq_len() \u00b6 public static rd_kafka_outq_len ( \\FFI\\CData | null $rk ) : int | null Returns the current out queue length. The out queue contains messages waiting to be sent to, or acknowledged by, the broker. An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int|null int - number of messages in the out queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7 rd_kafka_pause_partitions() \u00b6 public static rd_kafka_pause_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Pause producing or consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce rd_kafka_plugin_f_conf_init_t() \u00b6 public static rd_kafka_plugin_f_conf_init_t ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $plug_opaquep , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* plug_opaquep \\FFI\\CData|object|string|null void** errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_poll() \u00b6 public static rd_kafka_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Polls the provided kafka handle for events. Events will cause application provided callbacks to be called. The timeout_ms argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as timeout_ms . To wait indefinately for an event, provide -1. Remarks An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called. Events: delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer] error callbacks (rd_kafka_conf_set_error_cb()) [all] stats callbacks (rd_kafka_conf_set_stats_cb()) [all] throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all] Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4 rd_kafka_poll_set_consumer() \u00b6 public static rd_kafka_poll_set_consumer ( \\FFI\\CData | null $rk ) : int Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). Warning It is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904 rd_kafka_position() \u00b6 public static rd_kafka_position ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Retrieve current positions (offsets) for topics+partitions. The offset field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac rd_kafka_produce() \u00b6 public static rd_kafka_produce ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | object | string | null $payload , int | null $len , \\FFI\\CData | object | string | null $key , int | null $keylen , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Produce and send a single message to broker. rkt is the target topic which must have been previously created with rd_kafka_topic_new() . rd_kafka_produce() is an asynch non-blocking API. partition is the target partition, either: RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or a fixed partition (0..N) msgflags is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block produce* () call if queue.buffering.max.messages or queue.buffering.max.kbytes are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on RD_KAFKA_MSG_F_BLOCK above. RD_KAFKA_MSG_F_FREE - rdkafka will free(3) payload when it is done with it. RD_KAFKA_MSG_F_COPY - the payload data will be copied and the payload pointer will not be used by rdkafka after the call returns. .._F_FREE and .._F_COPY are mutually exclusive. If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility. payload is the message payload of size len bytes. key is an optional message key of size keylen bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer. msg_opaque is an optional application-provided per-message opaque pointer that will provided in the delivery report callback ( dr_cb ) for referencing this message. Returns 0 on success or -1 on error in which case errno is set accordingly: ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL) EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE) ESRCH - requested partition is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also Use rd_kafka_errno2err() to convert errno to rdkafka error code. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int payload \\FFI\\CData|object|string|null void* len int|null size_t key \\FFI\\CData|object|string|null void* keylen int|null size_t msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736 rd_kafka_produce_batch() \u00b6 public static rd_kafka_produce_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | null $rkmessages , int | null $message_cnt ) : int | null Produce multiple messages. If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster). The messages are provided in the array rkmessages of count message_cnt elements. The partition and msgflags are used for all provided messages. Honoured rkmessages [] fields are: payload,len Message payload and length key,key_len Optional message key _private Message opaque pointer (msg_opaque) err Will be set according to success or failure. Application only needs to check for errors if return value != message_cnt . Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t* message_cnt int|null int Returns int|null int - the number of messages succesfully enqueued for producing. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed rd_kafka_producev() \u00b6 public static rd_kafka_producev ( \\FFI\\CData | null $rk , mixed $args ) : int Produce and send a single message to broker. The message is defined by a va-arg list using rd_kafka_vtype_t tag tuples which must be terminated with a single RD_KAFKA_V_END . See also rd_kafka_produce, RD_KAFKA_V_END Parameters rk \\FFI\\CData|null rd_kafka_t* args mixed Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc rd_kafka_produceva() \u00b6 public static rd_kafka_produceva ( \\FFI\\CData | null $rk , \\FFI\\CData | null $vus , int | null $cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* vus \\FFI\\CData|null rd_kafka_vu_t* cnt int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_purge() \u00b6 public static rd_kafka_purge ( \\FFI\\CData | null $rk , int | null $purge_flags ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* purge_flags int|null int Returns int rd_kafka_resp_err_t rd_kafka_query_watermark_offsets() \u00b6 public static rd_kafka_query_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high , int | null $timeout_ms ) : int Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. Offsets are returned in *low and *high respectively. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4550ff7d014f08406666124573f70495 rd_kafka_queue_cb_event_enable() \u00b6 public static rd_kafka_queue_cb_event_enable ( \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $event_cb , \\FFI\\CData | object | string | null $opaque ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*) opaque \\FFI\\CData|object|string|null void* rd_kafka_queue_destroy() \u00b6 public static rd_kafka_queue_destroy ( \\FFI\\CData | null $rkqu ) : void Destroy a queue, purging all of its enqueued messages. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e rd_kafka_queue_forward() \u00b6 public static rd_kafka_queue_forward ( \\FFI\\CData | null $src , \\FFI\\CData | null $dst ) : void Forward/re-route queue src to dst . If dst is NULL the forwarding is removed. The internal refcounts for both queues are increased. Remarks Regardless of whether dst is NULL or not, after calling this function, src will not forward it's fetch queue to the consumer queue. Parameters src \\FFI\\CData|null rd_kafka_queue_t* dst \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338 rd_kafka_queue_get_background() \u00b6 public static rd_kafka_queue_get_background ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_queue_get_consumer() \u00b6 public static rd_kafka_queue_get_consumer ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078 rd_kafka_queue_get_main() \u00b6 public static rd_kafka_queue_get_main ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863 rd_kafka_queue_get_partition() \u00b6 public static rd_kafka_queue_get_partition ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue This function only works on consumers. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d rd_kafka_queue_io_event_enable() \u00b6 public static rd_kafka_queue_io_event_enable ( \\FFI\\CData | null $rkqu , int | null $fd , \\FFI\\CData | object | string | null $payload , int | null $size ) : void Enable IO event triggering for queue. To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write payload (of size size ) to whenever a new element is enqueued on a previously empty queue. To remove event triggering call with fd = -1. librdkafka will maintain a copy of the payload . Remarks When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* fd int|null int payload \\FFI\\CData|object|string|null void* size int|null size_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784 rd_kafka_queue_length() \u00b6 public static rd_kafka_queue_length ( \\FFI\\CData | null $rkqu ) : int | null Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) Returns int|null size_t - the current number of elements in queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57 rd_kafka_queue_new() \u00b6 public static rd_kafka_queue_new ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Create a new message queue. See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44 rd_kafka_queue_poll() \u00b6 public static rd_kafka_queue_poll ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Poll a queue for an event for max timeout_ms . Remarks Use rd_kafka_event_destroy() to free the event. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_event_t* - an event, or NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa rd_kafka_queue_poll_callback() \u00b6 public static rd_kafka_queue_poll_callback ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : int | null Poll a queue for events served through callbacks for max timeout_ms . Remarks This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e rd_kafka_queue_yield() \u00b6 public static rd_kafka_queue_yield ( \\FFI\\CData | null $rkqu ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_rebalance_protocol() \u00b6 public static rd_kafka_rebalance_protocol ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char* rd_kafka_resume_partitions() \u00b6 public static rd_kafka_resume_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Resume producing consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2 rd_kafka_seek() \u00b6 public static rd_kafka_seek ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , int | null $timeout_ms ) : int Seek consumer for topic+partition to offset which is either an absolute or logical offset. If timeout_ms is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns RD_KAFKA_RESP_ERR__TIMED_OUT . If timeout_ms is 0 it will initiate the seek but return immediately without any error reporting (e.g., async). This call triggers a fetch queue barrier flush. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d rd_kafka_seek_partitions() \u00b6 public static rd_kafka_seek_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_send_offsets_to_transaction() \u00b6 public static rd_kafka_send_offsets_to_transaction ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $cgmetadata , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* cgmetadata \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_set_log_level() \u00b6 public static rd_kafka_set_log_level ( \\FFI\\CData | null $rk , int | null $level ) : void Specifies the maximum logging level produced by internal kafka logging and debugging. If the \"debug\" configuration property is set the level is automatically adjusted to LOG_DEBUG (7). Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4 rd_kafka_set_log_queue() \u00b6 public static rd_kafka_set_log_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkqu ) : int Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. This allows an application to serve log callbacks ( log_cb ) in its thread of choice. Remarks The configuration property log.queue MUST also be set to true. librdkafka maintains its own reference to the provided queue. Parameters rk \\FFI\\CData|null rd_kafka_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d rd_kafka_set_logger() \u00b6 public static rd_kafka_set_logger ( \\FFI\\CData | null $rk , \\FFI\\CData | \\Closure $func ) : void Set logger function. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging. Deprecated: Use rd_kafka_conf_set_log_cb() Remarks rk may be passed as NULL in the callback. Parameters rk \\FFI\\CData|null rd_kafka_t* func \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53 rd_kafka_subscribe() \u00b6 public static rd_kafka_subscribe ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Subscribe to topic set using balanced consumer groups. Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the topics list that is prefixed with \"^\" will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1 rd_kafka_subscription() \u00b6 public static rd_kafka_subscription ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Returns the current topic subscription. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise topic is updated to point to a newly allocated topic list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200 rd_kafka_test_fatal_error() \u00b6 public static rd_kafka_test_fatal_error ( \\FFI\\CData | null $rk , int $err , string | null $reason ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* err int rd_kafka_resp_err_t reason string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_thread_cnt() \u00b6 public static rd_kafka_thread_cnt ( ) : int | null Retrieve the current number of threads in use by librdkafka. Used by regression tests. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0901699375c972b807ba5255773f017f rd_kafka_topic_conf_destroy() \u00b6 public static rd_kafka_topic_conf_destroy ( \\FFI\\CData | null $topic_conf ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_topic_conf_dump() \u00b6 public static rd_kafka_topic_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the topic configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696 rd_kafka_topic_conf_dup() \u00b6 public static rd_kafka_topic_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_topic_conf_get() \u00b6 public static rd_kafka_topic_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve topic configuration value for property name . See also rd_kafka_conf_get() Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d rd_kafka_topic_conf_new() \u00b6 public static rd_kafka_topic_conf_new ( ) : \\FFI\\CData | null Create topic configuration object. See also Same semantics as for rd_kafka_conf_new(). Returns \\FFI\\CData|null rd_kafka_topic_conf_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e rd_kafka_topic_conf_set() \u00b6 public static rd_kafka_topic_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a single rd_kafka_topic_conf_t value by property name. topic_conf should have been previously set up with rd_kafka_topic_conf_new() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01 rd_kafka_topic_conf_set_msg_order_cmp() \u00b6 public static rd_kafka_topic_conf_set_msg_order_cmp ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $msg_order_cmp ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* msg_order_cmp \\FFI\\CData|\\Closure int( )(rd_kafka_message_t , rd_kafka_message_t*) rd_kafka_topic_conf_set_opaque() \u00b6 public static rd_kafka_topic_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_topic_conf_set_partitioner_cb() \u00b6 public static rd_kafka_topic_conf_set_partitioner_cb ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $partitioner ) : void Producer: Set partitioner callback in provided topic conf object. The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key. Partitioner function constraints: MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available() MUST NOT block or execute for prolonged periods of time. MUST return a value between 0 and partition_cnt-1, or the special RD_KAFKA_PARTITION_UA value if partitioning could not be performed. Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* partitioner \\FFI\\CData|\\Closure int32_t( )(rd_kafka_topic_t , void*, size_t, int32_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf rd_kafka_topic_destroy() \u00b6 public static rd_kafka_topic_destroy ( \\FFI\\CData | null $rkt ) : void Loose application's topic handle refcount as previously created with rd_kafka_topic_new() . Remarks Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff rd_kafka_topic_name() \u00b6 public static rd_kafka_topic_name ( \\FFI\\CData | null $rkt ) : string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns string|null const char* rd_kafka_topic_new() \u00b6 public static rd_kafka_topic_new ( \\FFI\\CData | null $rk , string | null $topic , \\FFI\\CData | null $conf ) : \\FFI\\CData | null Creates a new topic handle for topic named topic . conf is an optional configuration for the topic created with rd_kafka_topic_conf_new() that will be used instead of the default topic configuration. The conf object is freed by this function and must not be used or destroyed by the application sub-sequently. See rd_kafka_topic_conf_set() et.al for more information. Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources. See also rd_kafka_topic_destroy() Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system errno to an rd_kafka_resp_err_t error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8 rd_kafka_topic_opaque() \u00b6 public static rd_kafka_topic_opaque ( \\FFI\\CData | null $rkt ) : \\FFI\\CData | object | string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns \\FFI\\CData|object|string|null void* rd_kafka_topic_partition_available() \u00b6 public static rd_kafka_topic_partition_available ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Check if partition is available (has a leader broker). Warning This function must only be called from inside a partitioner function Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 1 if the partition is available, else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758 rd_kafka_topic_partition_destroy() \u00b6 public static rd_kafka_topic_partition_destroy ( \\FFI\\CData | null $rktpar ) : void Destroy a rd_kafka_topic_partition_t. Remarks This must not be called for elements in a topic partition list. Parameters rktpar \\FFI\\CData|null rd_kafka_topic_partition_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a rd_kafka_topic_partition_list_add() \u00b6 public static rd_kafka_topic_partition_list_add ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Add topic+partition to list. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) partition int|null int32_t - Partition id Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d rd_kafka_topic_partition_list_add_range() \u00b6 public static rd_kafka_topic_partition_list_add_range ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $start , int | null $stop ) : void Add range of partitions from start to stop inclusive. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) start int|null int32_t - Start partition of range stop int|null int32_t - Last partition of range (inclusive) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b rd_kafka_topic_partition_list_copy() \u00b6 public static rd_kafka_topic_partition_list_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Make a copy of an existing list. Parameters src \\FFI\\CData|null rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to src See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7 rd_kafka_topic_partition_list_del() \u00b6 public static rd_kafka_topic_partition_list_del ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : int | null Delete partition from list. Remarks Any held indices to elems[] are unusable after this call returns 1. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to modify topic string|null const char* - Topic name to match partition int|null int32_t - Partition to match Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97 rd_kafka_topic_partition_list_del_by_idx() \u00b6 public static rd_kafka_topic_partition_list_del_by_idx ( \\FFI\\CData | null $rktparlist , int | null $idx ) : int | null Delete partition from list by elems[] index. See also rd_kafka_topic_partition_list_del() Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* idx int|null int Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463 rd_kafka_topic_partition_list_destroy() \u00b6 public static rd_kafka_topic_partition_list_destroy ( \\FFI\\CData | null $rkparlist ) : void Parameters rkparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* rd_kafka_topic_partition_list_find() \u00b6 public static rd_kafka_topic_partition_list_find ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Find element by topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa rd_kafka_topic_partition_list_new() \u00b6 public static rd_kafka_topic_partition_list_new ( int | null $size ) : \\FFI\\CData | null Create a new list/vector Topic+Partition container. Remarks Use rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself. See also rd_kafka_topic_partition_list_add() Parameters size int|null int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a rd_kafka_topic_partition_list_set_offset() \u00b6 public static rd_kafka_topic_partition_list_set_offset ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition , int | null $offset ) : int Set offset to offset for topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if partition was not found in the list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d rd_kafka_topic_partition_list_sort() \u00b6 public static rd_kafka_topic_partition_list_sort ( \\FFI\\CData | null $rktparlist , \\FFI\\CData | \\Closure $cmp , \\FFI\\CData | object | string | null $opaque ) : void Sort list using comparator cmp . If cmp is NULL the default comparator will be used that sorts by ascending topic name and partition. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* cmp \\FFI\\CData|\\Closure int( )(void , void*, void*) opaque \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f rd_kafka_topic_result_error() \u00b6 public static rd_kafka_topic_result_error ( \\FFI\\CData | null $topicres ) : int Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns int rd_kafka_resp_err_t rd_kafka_topic_result_error_string() \u00b6 public static rd_kafka_topic_result_error_string ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char* rd_kafka_topic_result_name() \u00b6 public static rd_kafka_topic_result_name ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char* rd_kafka_type() \u00b6 public static rd_kafka_type ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_type_t rd_kafka_unittest() \u00b6 public static rd_kafka_unittest ( ) : int | null Returns int|null int rd_kafka_unsubscribe() \u00b6 public static rd_kafka_unsubscribe ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_resp_err_t rd_kafka_version() \u00b6 public static rd_kafka_version ( ) : int | null Returns the librdkafka version as integer. See also See RD_KAFKA_VERSION for how to parse the integer format. Use rd_kafka_version_str() to retreive the version as a string. Returns int|null int - ) - Version integer. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e rd_kafka_version_str() \u00b6 public static rd_kafka_version_str ( ) : string | null Returns the librdkafka version as string. Returns string|null const char* - ) - Version string See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a rd_kafka_wait_destroyed() \u00b6 public static rd_kafka_wait_destroyed ( int | null $timeout_ms ) : int | null Wait for all rd_kafka_t objects to be destroyed. Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached. Since rd_kafka_destroy() is an asynch operation the rd_kafka_wait_destroyed() function can be used for applications where a clean shutdown is required. Parameters timeout_ms int|null int - ) Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d rd_kafka_yield() \u00b6 public static rd_kafka_yield ( \\FFI\\CData | null $rk ) : void Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events. Remarks This function MUST ONLY be called from within a librdkafka callback. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d requireMethod() \u00b6 public static requireMethod ( string $name ) : void Method must be supported by current binding version otherwise an exception is thrown. Parameters name string requireVersion() \u00b6 public static requireVersion ( string $operator , string $version ) : void Version must match the current binding otherwise an exception is thrown. Parameters operator string version string type() \u00b6 public static type ( string | \\FFI\\CType $type ) : \\FFI\\CType Parameters type string|\\FFI\\CType Returns \\FFI\\CType versionMatches() \u00b6 public static versionMatches ( string $operator , string $version ) : bool Whether version matches the current binding version Parameters operator string version string Returns bool Test Coverage \ud83d\udc9b \u00b6 \ud83d\udc9b Lines: 83.13% (69 / 83) \u2764\ufe0f Methods: 50% (9 / 18)","title":"Library"},{"location":"api/RdKafka/FFI/Library/#class-library","text":"Class \\RdKafka\\FFI\\Library uses \\RdKafka\\FFI\\Methods This class is for internal use. It provides access to the low level interface to librdkafka. Best practice is to use high level interfaces like \\RdKafka\\Conf , \\RdKafka\\Producer , \u2026 See also https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html","title":"Class Library"},{"location":"api/RdKafka/FFI/Library/#constants","text":"","title":"Constants"},{"location":"api/RdKafka/FFI/Library/#php_library_version","text":"public PHP_LIBRARY_VERSION = '0.4.0'","title":"PHP_LIBRARY_VERSION"},{"location":"api/RdKafka/FFI/Library/#version_autodetect","text":"public VERSION_AUTODETECT = ''","title":"VERSION_AUTODETECT"},{"location":"api/RdKafka/FFI/Library/#version_latest","text":"public VERSION_LATEST = '1.8.2'","title":"VERSION_LATEST"},{"location":"api/RdKafka/FFI/Library/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/Library/#cast","text":"public static cast ( mixed $type , \\FFI\\CData $ptr ) : \\FFI\\CData Parameters type mixed ptr \\FFI\\CData Returns \\FFI\\CData","title":"cast()"},{"location":"api/RdKafka/FFI/Library/#getclientversion","text":"public static getClientVersion ( ) : string The client version exposed to the brokers. The version has the format v{phpLibraryVersion}-v{bindingVersion}-librdkafka-v{librdkafkaVersion} - e.g. v0.1.0-dev-v1.5.2-librdkafka-v1.5.2) Returns string","title":"getClientVersion()"},{"location":"api/RdKafka/FFI/Library/#getffi","text":"public static getFFI ( ) : \\FFI Returns \\FFI","title":"getFFI()"},{"location":"api/RdKafka/FFI/Library/#getlibrary","text":"public static getLibrary ( ) : string Returns string","title":"getLibrary()"},{"location":"api/RdKafka/FFI/Library/#getlibraryversion","text":"public static getLibraryVersion ( ) : string The version of librdkafka Returns string","title":"getLibraryVersion()"},{"location":"api/RdKafka/FFI/Library/#getversion","text":"public static getVersion ( ) : string The version of the current binding with librdkafka Returns string","title":"getVersion()"},{"location":"api/RdKafka/FFI/Library/#hasmethod","text":"public static hasMethod ( string $name ) : bool Whether method is supported by current binding version. Parameters name string Returns bool","title":"hasMethod()"},{"location":"api/RdKafka/FFI/Library/#init","text":"public static init ( string $version = self :: VERSION_AUTODETECT , string $scope = 'RdKafka' , ? string $library = null , ? string $cdef = null ) : void Parameters version string scope string library ?string cdef ?string","title":"init()"},{"location":"api/RdKafka/FFI/Library/#new","text":"public static new ( string | \\FFI\\CData | mixed $type , bool $owned = true , bool $persistent = false ) : \\FFI\\CData Parameters type string|\\FFI\\CData|mixed owned bool persistent bool Returns \\FFI\\CData","title":"new()"},{"location":"api/RdKafka/FFI/Library/#preload","text":"public static preload ( string $version = self :: VERSION_AUTODETECT , string $scope = 'RdKafka' , ? string $library = null , ? string $cdef = null ) : \\FFI Parameters version string scope string library ?string cdef ?string Returns \\FFI","title":"preload()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_destroy","text":"public static rd_kafka_AdminOptions_destroy ( \\FFI\\CData | null $options ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t*","title":"rd_kafka_AdminOptions_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_new","text":"public static rd_kafka_AdminOptions_new ( \\FFI\\CData | null $rk , int $for_api ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* for_api int rd_kafka_admin_op_t Returns \\FFI\\CData|null rd_kafka_AdminOptions_t*","title":"rd_kafka_AdminOptions_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_broker","text":"public static rd_kafka_AdminOptions_set_broker ( \\FFI\\CData | null $options , int | null $broker_id , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* broker_id int|null int32_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_broker()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_opaque","text":"public static rd_kafka_AdminOptions_set_opaque ( \\FFI\\CData | null $options , \\FFI\\CData | object | string | null $opaque ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_AdminOptions_set_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_operation_timeout","text":"public static rd_kafka_AdminOptions_set_operation_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_operation_timeout()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_request_timeout","text":"public static rd_kafka_AdminOptions_set_request_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_request_timeout()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_adminoptions_set_validate_only","text":"public static rd_kafka_AdminOptions_set_validate_only ( \\FFI\\CData | null $options , int | null $true_or_false , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* true_or_false int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_validate_only()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconfigs","text":"public static rd_kafka_AlterConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_AlterConfigs()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_alterconfigs_result_resources","text":"public static rd_kafka_AlterConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t**","title":"rd_kafka_AlterConfigs_result_resources()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_default","text":"public static rd_kafka_ConfigEntry_is_default ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_default()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_read_only","text":"public static rd_kafka_ConfigEntry_is_read_only ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_read_only()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_sensitive","text":"public static rd_kafka_ConfigEntry_is_sensitive ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_sensitive()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_is_synonym","text":"public static rd_kafka_ConfigEntry_is_synonym ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_synonym()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_name","text":"public static rd_kafka_ConfigEntry_name ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char*","title":"rd_kafka_ConfigEntry_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_source","text":"public static rd_kafka_ConfigEntry_source ( \\FFI\\CData | null $entry ) : int Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int rd_kafka_ConfigSource_t","title":"rd_kafka_ConfigEntry_source()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_synonyms","text":"public static rd_kafka_ConfigEntry_synonyms ( \\FFI\\CData | null $entry , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t**","title":"rd_kafka_ConfigEntry_synonyms()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configentry_value","text":"public static rd_kafka_ConfigEntry_value ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char*","title":"rd_kafka_ConfigEntry_value()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_configs","text":"public static rd_kafka_ConfigResource_configs ( \\FFI\\CData | null $config , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t**","title":"rd_kafka_ConfigResource_configs()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_destroy","text":"public static rd_kafka_ConfigResource_destroy ( \\FFI\\CData | null $config ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t*","title":"rd_kafka_ConfigResource_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_destroy_array","text":"public static rd_kafka_ConfigResource_destroy_array ( \\FFI\\CData | null $config , int | null $config_cnt ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t","title":"rd_kafka_ConfigResource_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_error","text":"public static rd_kafka_ConfigResource_error ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_ConfigResource_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_error_string","text":"public static rd_kafka_ConfigResource_error_string ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char*","title":"rd_kafka_ConfigResource_error_string()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_name","text":"public static rd_kafka_ConfigResource_name ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char*","title":"rd_kafka_ConfigResource_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_new","text":"public static rd_kafka_ConfigResource_new ( int $restype , string | null $resname ) : \\FFI\\CData | null Parameters restype int rd_kafka_ResourceType_t resname string|null const char* Returns \\FFI\\CData|null rd_kafka_ConfigResource_t*","title":"rd_kafka_ConfigResource_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_set_config","text":"public static rd_kafka_ConfigResource_set_config ( \\FFI\\CData | null $config , string | null $name , string | null $value ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_ConfigResource_set_config()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configresource_type","text":"public static rd_kafka_ConfigResource_type ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_ResourceType_t","title":"rd_kafka_ConfigResource_type()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_configsource_name","text":"public static rd_kafka_ConfigSource_name ( int $confsource ) : string | null Parameters confsource int rd_kafka_ConfigSource_t Returns string|null const char*","title":"rd_kafka_ConfigSource_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createpartitions","text":"public static rd_kafka_CreatePartitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_parts , int | null $new_parts_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_CreatePartitions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createpartitions_result_topics","text":"public static rd_kafka_CreatePartitions_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_CreatePartitions_result_topics()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createtopics","text":"public static rd_kafka_CreateTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_topics , int | null $new_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_CreateTopics()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_createtopics_result_topics","text":"public static rd_kafka_CreateTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_CreateTopics_result_topics()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets","text":"public static rd_kafka_DeleteConsumerGroupOffsets ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffsets_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffsets_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteConsumerGroupOffsets()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_destroy","text":"public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \\FFI\\CData | null $del_grpoffsets ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t*","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_destroy_array","text":"public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffset_cnt ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt int|null size_t","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_new","text":"public static rd_kafka_DeleteConsumerGroupOffsets_new ( string | null $group , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters group string|null const char* partitions \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t*","title":"rd_kafka_DeleteConsumerGroupOffsets_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleteconsumergroupoffsets_result_groups","text":"public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t**","title":"rd_kafka_DeleteConsumerGroupOffsets_result_groups()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_destroy","text":"public static rd_kafka_DeleteGroup_destroy ( \\FFI\\CData | null $del_group ) : void Parameters del_group \\FFI\\CData|null rd_kafka_DeleteGroup_t*","title":"rd_kafka_DeleteGroup_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_destroy_array","text":"public static rd_kafka_DeleteGroup_destroy_array ( \\FFI\\CData | null $del_groups , int | null $del_group_cnt ) : void Parameters del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t","title":"rd_kafka_DeleteGroup_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroup_new","text":"public static rd_kafka_DeleteGroup_new ( string | null $group ) : \\FFI\\CData | null Parameters group string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteGroup_t*","title":"rd_kafka_DeleteGroup_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroups","text":"public static rd_kafka_DeleteGroups ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_groups , int | null $del_group_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteGroups()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletegroups_result_groups","text":"public static rd_kafka_DeleteGroups_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t**","title":"rd_kafka_DeleteGroups_result_groups()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords","text":"public static rd_kafka_DeleteRecords ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_records , int | null $del_record_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteRecords()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_destroy","text":"public static rd_kafka_DeleteRecords_destroy ( \\FFI\\CData | null $del_records ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t*","title":"rd_kafka_DeleteRecords_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_destroy_array","text":"public static rd_kafka_DeleteRecords_destroy_array ( \\FFI\\CData | null $del_records , int | null $del_record_cnt ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t","title":"rd_kafka_DeleteRecords_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_new","text":"public static rd_kafka_DeleteRecords_new ( \\FFI\\CData | null $before_offsets ) : \\FFI\\CData | null Parameters before_offsets \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteRecords_t*","title":"rd_kafka_DeleteRecords_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deleterecords_result_offsets","text":"public static rd_kafka_DeleteRecords_result_offsets ( \\FFI\\CData | null $result ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t*","title":"rd_kafka_DeleteRecords_result_offsets()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_destroy","text":"public static rd_kafka_DeleteTopic_destroy ( \\FFI\\CData | null $del_topic ) : void Parameters del_topic \\FFI\\CData|null rd_kafka_DeleteTopic_t*","title":"rd_kafka_DeleteTopic_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_destroy_array","text":"public static rd_kafka_DeleteTopic_destroy_array ( \\FFI\\CData | null $del_topics , int | null $del_topic_cnt ) : void Parameters del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t","title":"rd_kafka_DeleteTopic_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopic_new","text":"public static rd_kafka_DeleteTopic_new ( string | null $topic ) : \\FFI\\CData | null Parameters topic string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteTopic_t*","title":"rd_kafka_DeleteTopic_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopics","text":"public static rd_kafka_DeleteTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_topics , int | null $del_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteTopics()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_deletetopics_result_topics","text":"public static rd_kafka_DeleteTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_DeleteTopics_result_topics()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconfigs","text":"public static rd_kafka_DescribeConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null const rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DescribeConfigs()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_describeconfigs_result_resources","text":"public static rd_kafka_DescribeConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t**","title":"rd_kafka_DescribeConfigs_result_resources()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_destroy","text":"public static rd_kafka_NewPartitions_destroy ( \\FFI\\CData | null $new_parts ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t*","title":"rd_kafka_NewPartitions_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_destroy_array","text":"public static rd_kafka_NewPartitions_destroy_array ( \\FFI\\CData | null $new_parts , int | null $new_parts_cnt ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t","title":"rd_kafka_NewPartitions_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_new","text":"public static rd_kafka_NewPartitions_new ( string | null $topic , int | null $new_total_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* new_total_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewPartitions_t*","title":"rd_kafka_NewPartitions_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newpartitions_set_replica_assignment","text":"public static rd_kafka_NewPartitions_set_replica_assignment ( \\FFI\\CData | null $new_parts , int | null $new_partition_idx , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* new_partition_idx int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewPartitions_set_replica_assignment()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_destroy","text":"public static rd_kafka_NewTopic_destroy ( \\FFI\\CData | null $new_topic ) : void Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t*","title":"rd_kafka_NewTopic_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_destroy_array","text":"public static rd_kafka_NewTopic_destroy_array ( \\FFI\\CData | null $new_topics , int | null $new_topic_cnt ) : void Parameters new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t","title":"rd_kafka_NewTopic_destroy_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_new","text":"public static rd_kafka_NewTopic_new ( string | null $topic , int | null $num_partitions , int | null $replication_factor , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* num_partitions int|null int replication_factor int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewTopic_t*","title":"rd_kafka_NewTopic_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_set_config","text":"public static rd_kafka_NewTopic_set_config ( \\FFI\\CData | null $new_topic , string | null $name , string | null $value ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewTopic_set_config()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_newtopic_set_replica_assignment","text":"public static rd_kafka_NewTopic_set_replica_assignment ( \\FFI\\CData | null $new_topic , int | null $partition , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* partition int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewTopic_set_replica_assignment()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_resourcetype_name","text":"public static rd_kafka_ResourceType_name ( int $restype ) : string | null Parameters restype int rd_kafka_ResourceType_t Returns string|null const char*","title":"rd_kafka_ResourceType_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_abort_transaction","text":"public static rd_kafka_abort_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_abort_transaction()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assign","text":"public static rd_kafka_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Atomic assignment of partitions to consume. The new partitions will replace the existing assignment. When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state. A zero-length partitions will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a NULL value for partitions will reset and clear the internal state. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9","title":"rd_kafka_assign()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assignment","text":"public static rd_kafka_assignment ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Returns the current partition assignment. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise partitions is updated to point to a newly allocated partition list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59","title":"rd_kafka_assignment()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_assignment_lost","text":"public static rd_kafka_assignment_lost ( \\FFI\\CData | null $rk ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int|null int","title":"rd_kafka_assignment_lost()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_begin_transaction","text":"public static rd_kafka_begin_transaction ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_begin_transaction()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_brokers_add","text":"public static rd_kafka_brokers_add ( \\FFI\\CData | null $rk , string | null $brokerlist ) : int | null Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata. If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion. brokerlist is a ,-separated list of brokers in the format: <broker1> ,<broker2>,.. Where each broker is in either the host or URL based format: <host> [:<port>] <proto> ://<host>[:port] <proto> is either PLAINTEXT , SSL , SASL , SASL_PLAINTEXT The two formats can be mixed but ultimately the value of the security.protocol config property decides what brokers are allowed. Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\" Remarks Brokers may also be defined with the metadata.broker.list or bootstrap.servers configuration property (preferred method). Parameters rk \\FFI\\CData|null rd_kafka_t* brokerlist string|null const char* Returns int|null int - the number of brokers successfully added. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7","title":"rd_kafka_brokers_add()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_clusterid","text":"public static rd_kafka_clusterid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null char*","title":"rd_kafka_clusterid()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit","text":"public static rd_kafka_commit ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $async ) : int Commit offsets on broker for the provided list of partitions. offsets should contain topic , partition , offset and possibly metadata . If offsets is NULL the current partition assignment will be used instead. If async is false this operation will block until the broker offset commit is done, returning the resulting success or error code. If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar. Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87","title":"rd_kafka_commit()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_message","text":"public static rd_kafka_commit_message ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , int | null $async ) : int Commit message's offset on broker for the message's partition. See also rd_kafka_commit Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null rd_kafka_message_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883","title":"rd_kafka_commit_message()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_queue","text":"public static rd_kafka_commit_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $cb , \\FFI\\CData | object | string | null $opaque ) : int Commit offsets on broker for the provided list of partitions. See rd_kafka_commit for offsets semantics. The result of the offset commit will be posted on the provided rkqu queue. If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the cb callback is required. opaque is passed to the callback. If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The opaque value will be available with rd_kafka_event_opaque() If rkqu is NULL a temporary queue will be created and the callback will be served by this call. See also rd_kafka_commit() rd_kafka_conf_set_offset_commit_cb() Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47","title":"rd_kafka_commit_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_commit_transaction","text":"public static rd_kafka_commit_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_commit_transaction()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_committed","text":"public static rd_kafka_committed ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : int Retrieve committed offsets for topics+partitions. The offset field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13","title":"rd_kafka_committed()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf","text":"public static rd_kafka_conf ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null const rd_kafka_conf_t*","title":"rd_kafka_conf()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_destroy","text":"public static rd_kafka_conf_destroy ( \\FFI\\CData | null $conf ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dump","text":"public static rd_kafka_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c","title":"rd_kafka_conf_dump()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dump_free","text":"public static rd_kafka_conf_dump_free ( \\FFI\\CData | null $arr , int | null $cnt ) : void Parameters arr \\FFI\\CData|null char** cnt int|null size_t","title":"rd_kafka_conf_dump_free()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dup","text":"public static rd_kafka_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_dup()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_dup_filter","text":"public static rd_kafka_conf_dup_filter ( \\FFI\\CData | null $conf , int | null $filter_cnt , \\FFI\\CData | null $filter ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** Returns \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_dup_filter()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_get","text":"public static rd_kafka_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve configuration value for property name . If dest is non-NULL the value will be written to dest with at most dest_size . *dest_size is updated to the full length of the value, thus if *dest_size initially is smaller than the full length the application may reallocate dest to fit the returned *dest_size and try again. If dest is NULL only the full length of the value is returned. Fallthrough: Topic-level configuration properties from the default_topic_conf may be retrieved using this interface. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property name matched, else RD_KAFKA_CONF_UNKNOWN . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97","title":"rd_kafka_conf_get()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_get_default_topic_conf","text":"public static rd_kafka_conf_get_default_topic_conf ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_conf_get_default_topic_conf()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_destroy","text":"public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_dup","text":"public static rd_kafka_conf_interceptor_add_on_conf_dup ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_dup , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_dup \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, rd_kafka_conf_t*, size_t, char**, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_dup()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_conf_set","text":"public static rd_kafka_conf_interceptor_add_on_conf_set ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_set , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_set \\FFI\\CData|\\Closure rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_set()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_interceptor_add_on_new","text":"public static rd_kafka_conf_interceptor_add_on_new ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_new , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_new \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, rd_kafka_conf_t*, void*, char*, size_t) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_new","text":"public static rd_kafka_conf_new ( ) : \\FFI\\CData | null Create configuration object. When providing your own configuration to the rd_kafka_*_new_* () calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: 1 rd_kafka_conf_t *myconf; 2 rd_kafka_conf_res_t res; 3 4 myconf = rd_kafka_conf_new(); 5 res = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\", 6 errstr, sizeof(errstr)); 7 if (res != RD_KAFKA_CONF_OK) 8 die(\"%s\\n\", errstr); 9 10 rk = rd_kafka_new(..., myconf); Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime. The properties are identical to the Apache Kafka configuration properties whenever possible. See also rd_kafka_conf_set(), rd_kafka_conf_destroy() Returns \\FFI\\CData|null rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c","title":"rd_kafka_conf_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_properties_show","text":"public static rd_kafka_conf_properties_show ( \\FFI\\CData | null $fp ) : void Parameters fp \\FFI\\CData|null FILE*","title":"rd_kafka_conf_properties_show()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set","text":"public static rd_kafka_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a configuration property. conf must have been previously created with rd_kafka_conf_new(). Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the default_topic_conf . If no default_topic_conf has been set one will be created. Any sub-sequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. In case of failure errstr is updated to contain a human readable error string. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8","title":"rd_kafka_conf_set()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_background_event_cb","text":"public static rd_kafka_conf_set_background_event_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $event_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_event_t*, void*)","title":"rd_kafka_conf_set_background_event_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_closesocket_cb","text":"public static rd_kafka_conf_set_closesocket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $closesocket_cb ) : void Set close socket callback. Close a socket (optionally opened with socket_cb()). Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* closesocket_cb \\FFI\\CData|\\Closure int( )(int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7","title":"rd_kafka_conf_set_closesocket_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_connect_cb","text":"public static rd_kafka_conf_set_connect_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $connect_cb ) : void Set connect callback. The connect callback is responsible for connecting socket sockfd to peer address addr . The id field contains the broker identifier. connect_cb shall return 0 on success (socket connected) or an error number (errno) on error. Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* connect_cb \\FFI\\CData|\\Closure int( )(int, struct sockaddr , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040","title":"rd_kafka_conf_set_connect_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_consume_cb","text":"public static rd_kafka_conf_set_consume_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $consume_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*)","title":"rd_kafka_conf_set_consume_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_default_topic_conf","text":"public static rd_kafka_conf_set_default_topic_conf ( \\FFI\\CData | null $conf , \\FFI\\CData | null $tconf ) : void Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* tconf \\FFI\\CData|null rd_kafka_topic_conf_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63","title":"rd_kafka_conf_set_default_topic_conf()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_dr_cb","text":"public static rd_kafka_conf_set_dr_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_cb ) : void Deprecated: See rd_kafka_conf_set_dr_msg_cb() Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*, size_t, rd_kafka_resp_err_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f","title":"rd_kafka_conf_set_dr_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_dr_msg_cb","text":"public static rd_kafka_conf_set_dr_msg_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_msg_cb ) : void Producer: Set delivery report callback in provided conf object. The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with err set to indicate the result of the produce request. The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted. An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_msg_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_message_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a","title":"rd_kafka_conf_set_dr_msg_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_engine_callback_data","text":"public static rd_kafka_conf_set_engine_callback_data ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $callback_data ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* callback_data \\FFI\\CData|object|string|null void*","title":"rd_kafka_conf_set_engine_callback_data()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_error_cb","text":"public static rd_kafka_conf_set_error_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $error_cb ) : void Set error callback in provided conf object. The error callback is used by librdkafka to signal critical errors back to the application. If no error_cb is registered then the errors will be logged instead. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* error_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90","title":"rd_kafka_conf_set_error_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_events","text":"public static rd_kafka_conf_set_events ( \\FFI\\CData | null $conf , int | null $events ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* events int|null int","title":"rd_kafka_conf_set_events()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_log_cb","text":"public static rd_kafka_conf_set_log_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $log_cb ) : void Set logger callback. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass func as NULL to disable logging. This is the configuration alternative to the deprecated rd_kafka_set_logger() Remarks The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through rd_kafka_set_log_queue() . An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded log_cb . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* log_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f","title":"rd_kafka_conf_set_log_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_oauthbearer_token_refresh_cb","text":"public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $oauthbearer_token_refresh_cb ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* oauthbearer_token_refresh_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, void*)","title":"rd_kafka_conf_set_oauthbearer_token_refresh_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_offset_commit_cb","text":"public static rd_kafka_conf_set_offset_commit_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $offset_commit_cb ) : void Consumer: Set offset commit callback for use with consumer groups. The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll(). If no partitions had valid offsets to commit this callback will be called with err == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error. The offsets list contains per-partition information: offset: committed offset (attempted) err: commit error Parameters conf \\FFI\\CData|null rd_kafka_conf_t* offset_commit_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb","title":"rd_kafka_conf_set_offset_commit_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_opaque","text":"public static rd_kafka_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_conf_set_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_rebalance_cb","text":"public static rd_kafka_conf_set_rebalance_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $rebalance_cb ) : void Consumer: Set rebalance callback for use with coordinated consumer group balancing. The err field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked. Registering a rebalance_cb turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's rebalance_cb . The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where err is neither of those. Remarks In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke). Remarks The partitions list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application. The following example shows the application's responsibilities: 1 static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err, 2 rd_kafka_topic_partition_list_t *partitions, 3 void *opaque) { 4 5 switch (err) 6 { 7 case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS: 8 // application may load offets from arbitrary external 9 // storage here and update \\p partitions 10 11 rd_kafka_assign(rk, partitions); 12 break; 13 14 case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS: 15 if (manual_commits) // Optional explicit manual commit 16 rd_kafka_commit(rk, partitions, 0); // sync commit 17 18 rd_kafka_assign(rk, NULL); 19 break; 20 21 default: 22 handle_unlikely_error(err); 23 rd_kafka_assign(rk, NULL); // sync state 24 break; 25 } 26 } Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rebalance_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311","title":"rd_kafka_conf_set_rebalance_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_socket_cb","text":"public static rd_kafka_conf_set_socket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $socket_cb ) : void Set socket callback. The socket callback is responsible for opening a socket according to the supplied domain , type and protocol . The socket shall be created with CLOEXEC set in a racefree fashion, if possible. Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* socket_cb \\FFI\\CData|\\Closure int( )(int, int, int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf","title":"rd_kafka_conf_set_socket_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_ssl_cert","text":"public static rd_kafka_conf_set_ssl_cert ( \\FFI\\CData | null $conf , int $cert_type , int $cert_enc , \\FFI\\CData | object | string | null $buffer , int | null $size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* cert_type int rd_kafka_cert_type_t cert_enc int rd_kafka_cert_enc_t buffer \\FFI\\CData|object|string|null void* size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t","title":"rd_kafka_conf_set_ssl_cert()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_ssl_cert_verify_cb","text":"public static rd_kafka_conf_set_ssl_cert_verify_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $ssl_cert_verify_cb ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* ssl_cert_verify_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns int rd_kafka_conf_res_t","title":"rd_kafka_conf_set_ssl_cert_verify_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_stats_cb","text":"public static rd_kafka_conf_set_stats_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $stats_cb ) : void Set statistics callback in provided conf object. The statistics callback is triggered from rd_kafka_poll() every statistics.interval.ms (needs to be configured separately). Function arguments: rk - Kafka handle json - String containing the statistics data in JSON format json_len - Length of json string. opaque - Application-provided opaque. If the application wishes to hold on to the json pointer and free it at a later time it must return 1 from the stats_cb . If the application returns 0 from the stats_cb then librdkafka will immediately free the json pointer. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* stats_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , char*, size_t, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766","title":"rd_kafka_conf_set_stats_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_conf_set_throttle_cb","text":"public static rd_kafka_conf_set_throttle_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $throttle_cb ) : void Set throttle callback. The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests. Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero. An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks. Remarks Requires broker version 0.9.0 or later. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* throttle_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, int32_t, int, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7","title":"rd_kafka_conf_set_throttle_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume","text":"public static rd_kafka_consume ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms ) : \\FFI\\CData | null Consume a single message from topic rkt and partition . timeout_ms is maximum amount of time to wait for a message to be received. Consumer must have been previously started with rd_kafka_consume_start() . Returns a message object on success or NULL on error. The message object must be destroyed with rd_kafka_message_destroy() when the application is done with it. Errors (when returning NULL): ETIMEDOUT - timeout_ms was reached with no new messages fetched. ENOENT - rkt + partition is unknown. (no prior rd_kafka_consume_start() call) NOTE: The returned message's ..->err must be checked for errors. NOTE: ..->err == RD_KAFKA_RESP_ERR__PARTITION_EOF signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore). Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e","title":"rd_kafka_consume()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_batch","text":"public static rd_kafka_consume_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the application provided array rkmessages (of size rkmessages_size entries). rd_kafka_consume_batch() provides higher throughput performance than rd_kafka_consume() . timeout_ms is the maximum amount of time to wait for all of rkmessages_size messages to be put into rkmessages . If no messages were available within the timeout period this function returns 0 and rkmessages remains untouched. This differs somewhat from rd_kafka_consume() . The message objects must be destroyed with rd_kafka_message_destroy() when the application is done with it. See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t - the number of rkmessages added in rkmessages , or -1 on error (same error codes as for rd_kafka_consume() . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce","title":"rd_kafka_consume_batch()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_batch_queue","text":"public static rd_kafka_consume_batch_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume batch of messages from queue. See also rd_kafka_consume_batch() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3d949238471993b18537855aad28fa23","title":"rd_kafka_consume_batch_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_callback","text":"public static rd_kafka_consume_callback ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consumes messages from topic rkt and partition , calling the provided callback for each consumed messsage. rd_kafka_consume_callback() provides higher throughput performance than both rd_kafka_consume() and rd_kafka_consume_batch() . timeout_ms is the maximum amount of time to wait for one or more messages to arrive. The provided consume_cb function is called for each message, the application MUST NOT call rd_kafka_message_destroy() on the provided rkmessage . The opaque argument is passed to the 'consume_cb' as opaque . See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int - the number of messages processed or -1 on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6","title":"rd_kafka_consume_callback()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_callback_queue","text":"public static rd_kafka_consume_callback_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consume multiple messages from queue with callback. See also rd_kafka_consume_callback() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532","title":"rd_kafka_consume_callback_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_queue","text":"public static rd_kafka_consume_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Consume from queue. See also rd_kafka_consume() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16","title":"rd_kafka_consume_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_start","text":"public static rd_kafka_consume_start ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int | null Start consuming messages for topic rkt and partition at offset offset which may either be an absolute (0..N) or one of the logical offsets: RD_KAFKA_OFFSET_BEGINNING RD_KAFKA_OFFSET_END RD_KAFKA_OFFSET_STORED RD_KAFKA_OFFSET_TAIL rdkafka will attempt to keep queued.min.messages (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached. The application shall use one of the rd_kafka_consume*() functions to consume messages from the local queue, each kafka message being represented as a rd_kafka_message_t * object. rd_kafka_consume_start() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . Use rd_kafka_errno2err() to convert sytem errno to rd_kafka_resp_err_t Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int|null int - 0 on success or -1 on error in which case errno is set accordingly: EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT) EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG) ESRCH - requested partition is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4","title":"rd_kafka_consume_start()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_start_queue","text":"public static rd_kafka_consume_start_queue ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , \\FFI\\CData | null $rkqu ) : int | null Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which must have been previously allocated with rd_kafka_queue_new() . The application must use one of the rd_kafka_consume_*_queue() functions to receive fetched messages. rd_kafka_consume_start_queue() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . rd_kafka_consume_start() and rd_kafka_consume_start_queue() must not be combined for the same topic and partition. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t rkqu \\FFI\\CData|null rd_kafka_queue_t* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258","title":"rd_kafka_consume_start_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consume_stop","text":"public static rd_kafka_consume_stop ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Stop consuming messages for topic rkt and partition , purging all messages currently in the local queue. NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method. The application needs to be stop all consumers before calling rd_kafka_destroy() on the main object handle. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 0 on success or -1 on error (see errno ). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4","title":"rd_kafka_consume_stop()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_close","text":"public static rd_kafka_consumer_close ( \\FFI\\CData | null $rk ) : int Close down the KafkaConsumer. Remarks This call will block until the consumer has revoked its assignment, calling the rebalance_cb if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms. Remarks The application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d","title":"rd_kafka_consumer_close()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata","text":"public static rd_kafka_consumer_group_metadata ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_destroy","text":"public static rd_kafka_consumer_group_metadata_destroy ( \\FFI\\CData | null $arg0 ) : void Parameters arg0 \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_new","text":"public static rd_kafka_consumer_group_metadata_new ( string | null $group_id ) : \\FFI\\CData | null Parameters group_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_new_with_genid","text":"public static rd_kafka_consumer_group_metadata_new_with_genid ( string | null $group_id , int | null $generation_id , string | null $member_id , string | null $group_instance_id ) : \\FFI\\CData | null Parameters group_id string|null const char* generation_id int|null int32_t member_id string|null const char* group_instance_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_new_with_genid()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_read","text":"public static rd_kafka_consumer_group_metadata_read ( \\FFI\\CData | null $cgmdp , \\FFI\\CData | object | string | null $buffer , int | null $size ) : \\FFI\\CData | null Parameters cgmdp \\FFI\\CData|null rd_kafka_consumer_group_metadata_t** buffer \\FFI\\CData|object|string|null void* size int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_consumer_group_metadata_read()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_group_metadata_write","text":"public static rd_kafka_consumer_group_metadata_write ( \\FFI\\CData | null $cgmd , \\FFI\\CData | object | string | null $bufferp , \\FFI\\CData | null $sizep ) : \\FFI\\CData | null Parameters cgmd \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* bufferp \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_consumer_group_metadata_write()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_consumer_poll","text":"public static rd_kafka_consumer_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Poll the consumer for messages or events. Will block for at most timeout_ms milliseconds. Remarks An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. See also rd_kafka_message_t Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* - A message object which is a proper message if ->err is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf","title":"rd_kafka_consumer_poll()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_controllerid","text":"public static rd_kafka_controllerid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int32_t","title":"rd_kafka_controllerid()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_default_topic_conf_dup","text":"public static rd_kafka_default_topic_conf_dup ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_default_topic_conf_dup()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_destroy","text":"public static rd_kafka_destroy ( \\FFI\\CData | null $rk ) : void Destroy Kafka handle. Remarks This is a blocking operation. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794","title":"rd_kafka_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_destroy_flags","text":"public static rd_kafka_destroy_flags ( \\FFI\\CData | null $rk , int | null $flags ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* flags int|null int","title":"rd_kafka_destroy_flags()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_dump","text":"public static rd_kafka_dump ( \\FFI\\CData | null $fp , \\FFI\\CData | null $rk ) : void Dumps rdkafka's internal state for handle rk to stream fp . This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. Parameters fp \\FFI\\CData|null FILE* rk \\FFI\\CData|null rd_kafka_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1","title":"rd_kafka_dump()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_err2name","text":"public static rd_kafka_err2name ( int $err ) : string | null Returns the error code name (enum name). Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77","title":"rd_kafka_err2name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_err2str","text":"public static rd_kafka_err2str ( int $err ) : string | null Returns a human readable representation of a kafka error. Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d","title":"rd_kafka_err2str()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_errno","text":"public static rd_kafka_errno ( ) : int | null Returns the thread-local system errno. On most platforms this is the same as errno but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for expsing the errno librdkafka uses. Remarks The value is local to the current calling thread. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aef27224d8c638e51f3ee29bb25f65f1f","title":"rd_kafka_errno()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_errno2err","text":"public static rd_kafka_errno2err ( int | null $errnox ) : int Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the following functions: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() Remarks A better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. See also rd_kafka_last_error() Parameters errnox int|null int - ) - System errno value to convert Returns int rd_kafka_resp_err_t - Appropriate error code for errnox See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f","title":"rd_kafka_errno2err()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_code","text":"public static rd_kafka_error_code ( \\FFI\\CData | null $error ) : int Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_error_code()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_destroy","text":"public static rd_kafka_error_destroy ( \\FFI\\CData | null $error ) : void Parameters error \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_error_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_is_fatal","text":"public static rd_kafka_error_is_fatal ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_is_fatal()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_is_retriable","text":"public static rd_kafka_error_is_retriable ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_is_retriable()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_name","text":"public static rd_kafka_error_name ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char*","title":"rd_kafka_error_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_new","text":"public static rd_kafka_error_new ( int $code , string | null $fmt , mixed $args ) : \\FFI\\CData | null Parameters code int rd_kafka_resp_err_t fmt string|null const char* args mixed Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_error_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_string","text":"public static rd_kafka_error_string ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char*","title":"rd_kafka_error_string()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_error_txn_requires_abort","text":"public static rd_kafka_error_txn_requires_abort ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_txn_requires_abort()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_alterconfigs_result","text":"public static rd_kafka_event_AlterConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t*","title":"rd_kafka_event_AlterConfigs_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_createpartitions_result","text":"public static rd_kafka_event_CreatePartitions_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t*","title":"rd_kafka_event_CreatePartitions_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_createtopics_result","text":"public static rd_kafka_event_CreateTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreateTopics_result_t*","title":"rd_kafka_event_CreateTopics_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deleteconsumergroupoffsets_result","text":"public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t*","title":"rd_kafka_event_DeleteConsumerGroupOffsets_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deletegroups_result","text":"public static rd_kafka_event_DeleteGroups_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t*","title":"rd_kafka_event_DeleteGroups_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deleterecords_result","text":"public static rd_kafka_event_DeleteRecords_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t*","title":"rd_kafka_event_DeleteRecords_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_deletetopics_result","text":"public static rd_kafka_event_DeleteTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t*","title":"rd_kafka_event_DeleteTopics_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_describeconfigs_result","text":"public static rd_kafka_event_DescribeConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t*","title":"rd_kafka_event_DescribeConfigs_result()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_config_string","text":"public static rd_kafka_event_config_string ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char*","title":"rd_kafka_event_config_string()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_debug_contexts","text":"public static rd_kafka_event_debug_contexts ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $dst , int | null $dstsize ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* dst \\FFI\\CData|null char* dstsize int|null size_t Returns int|null int","title":"rd_kafka_event_debug_contexts()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_destroy","text":"public static rd_kafka_event_destroy ( \\FFI\\CData | null $rkev ) : void Destroy an event. Remarks Any references to this event, such as extracted messages, will not be usable after this call. As a convenience it is okay to pass rkev as NULL in which case no action is performed. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af1835c85aa202caf629861f29f475099","title":"rd_kafka_event_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error","text":"public static rd_kafka_event_error ( \\FFI\\CData | null $rkev ) : int Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int rd_kafka_resp_err_t - the error code for the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5","title":"rd_kafka_event_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error_is_fatal","text":"public static rd_kafka_event_error_is_fatal ( \\FFI\\CData | null $rkev ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns int|null int","title":"rd_kafka_event_error_is_fatal()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_error_string","text":"public static rd_kafka_event_error_string ( \\FFI\\CData | null $rkev ) : string | null Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793","title":"rd_kafka_event_error_string()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_log","text":"public static rd_kafka_event_log ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $fac , \\FFI\\CData | null $str , \\FFI\\CData | null $level ) : int | null Extract log message from the event. Event types: RD_KAFKA_EVENT_LOG Parameters rkev \\FFI\\CData|null rd_kafka_event_t* fac \\FFI\\CData|null char** str \\FFI\\CData|null char** level \\FFI\\CData|null int* Returns int|null int - 0 on success or -1 if unsupported event type. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7","title":"rd_kafka_event_log()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_array","text":"public static rd_kafka_event_message_array ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $rkmessages , int | null $size ) : int | null Extacts size message(s) from the event into the pre-allocated array rkmessages . Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* rkmessages \\FFI\\CData|null const rd_kafka_message_t** size int|null size_t Returns int|null size_t - the number of messages extracted. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8","title":"rd_kafka_event_message_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_count","text":"public static rd_kafka_event_message_count ( \\FFI\\CData | null $rkev ) : int | null Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null size_t - the number of remaining messages in the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90","title":"rd_kafka_event_message_count()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_message_next","text":"public static rd_kafka_event_message_next ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Call repeatedly until it returns NULL. Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Remarks The returned message(s) MUST NOT be freed with rd_kafka_message_destroy(). Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null const rd_kafka_message_t* - the next message from an event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c","title":"rd_kafka_event_message_next()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_name","text":"public static rd_kafka_event_name ( \\FFI\\CData | null $rkev ) : string | null Remarks As a convenience it is okay to pass rkev as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the event type\u2019s name for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866","title":"rd_kafka_event_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_opaque","text":"public static rd_kafka_event_opaque ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | object | string | null Event types: RD_KAFKA_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|object|string|null void* - the user opaque (if any) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525","title":"rd_kafka_event_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_stats","text":"public static rd_kafka_event_stats ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char*","title":"rd_kafka_event_stats()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_topic_partition","text":"public static rd_kafka_event_topic_partition ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe","title":"rd_kafka_event_topic_partition()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_topic_partition_list","text":"public static rd_kafka_event_topic_partition_list ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() Event types: RD_KAFKA_EVENT_REBALANCE RD_KAFKA_EVENT_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - the topic partition list from the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633","title":"rd_kafka_event_topic_partition_list()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_event_type","text":"public static rd_kafka_event_type ( \\FFI\\CData | null $rkev ) : int | null Remarks As a convenience it is okay to pass rkev as NULL in which case RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null rd_kafka_event_type_t - the event type for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d","title":"rd_kafka_event_type()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_fatal_error","text":"public static rd_kafka_fatal_error ( \\FFI\\CData | null $rk , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_fatal_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_flush","text":"public static rd_kafka_flush ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. Remarks This function will call rd_kafka_poll() and thus trigger callbacks. Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if timeout_ms was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d","title":"rd_kafka_flush()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_debug_contexts","text":"public static rd_kafka_get_debug_contexts ( ) : string | null Retrieve supported debug contexts for use with the \"debug\" configuration property. (runtime) Returns string|null const char* - ) - Comma-separated list of available debugging contexts. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45","title":"rd_kafka_get_debug_contexts()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_err_descs","text":"public static rd_kafka_get_err_descs ( \\FFI\\CData | null $errdescs , \\FFI\\CData | null $cntp ) : void Parameters errdescs \\FFI\\CData|null struct rd_kafka_err_desc** cntp \\FFI\\CData|null size_t*","title":"rd_kafka_get_err_descs()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_get_watermark_offsets","text":"public static rd_kafka_get_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high ) : int Get last known low (oldest/beginning) and high (newest/end) offsets for partition. The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker. If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset. Offsets are returned in *low and *high respectively. Remarks Shall only be used with an active consumer instance. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82","title":"rd_kafka_get_watermark_offsets()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_list_destroy","text":"public static rd_kafka_group_list_destroy ( \\FFI\\CData | null $grplist ) : void Parameters grplist \\FFI\\CData|null struct rd_kafka_group_list*","title":"rd_kafka_group_list_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_error","text":"public static rd_kafka_group_result_error ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_error_t*","title":"rd_kafka_group_result_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_name","text":"public static rd_kafka_group_result_name ( \\FFI\\CData | null $groupres ) : string | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns string|null const char*","title":"rd_kafka_group_result_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_group_result_partitions","text":"public static rd_kafka_group_result_partitions ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t*","title":"rd_kafka_group_result_partitions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_handle_mock_cluster","text":"public static rd_kafka_handle_mock_cluster ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_handle_mock_cluster()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_add","text":"public static rd_kafka_header_add ( \\FFI\\CData | null $hdrs , string | null $name , int | null $name_size , \\FFI\\CData | object | string | null $value , int | null $value_size ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* name_size int|null ssize_t value \\FFI\\CData|object|string|null void* value_size int|null ssize_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_add()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_cnt","text":"public static rd_kafka_header_cnt ( \\FFI\\CData | null $hdrs ) : int | null Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* Returns int|null size_t","title":"rd_kafka_header_cnt()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get","text":"public static rd_kafka_header_get ( \\FFI\\CData | null $hdrs , int | null $idx , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get_all","text":"public static rd_kafka_header_get_all ( \\FFI\\CData | null $hdrs , int | null $idx , \\FFI\\CData | null $namep , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t namep \\FFI\\CData|null char** valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get_all()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_get_last","text":"public static rd_kafka_header_get_last ( \\FFI\\CData | null $hdrs , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get_last()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_header_remove","text":"public static rd_kafka_header_remove ( \\FFI\\CData | null $hdrs , string | null $name ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_remove()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_copy","text":"public static rd_kafka_headers_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Parameters src \\FFI\\CData|null rd_kafka_headers_t* Returns \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_copy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_destroy","text":"public static rd_kafka_headers_destroy ( \\FFI\\CData | null $hdrs ) : void Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_headers_new","text":"public static rd_kafka_headers_new ( int | null $initial_count ) : \\FFI\\CData | null Parameters initial_count int|null size_t Returns \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incremental_assign","text":"public static rd_kafka_incremental_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_incremental_assign()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_incremental_unassign","text":"public static rd_kafka_incremental_unassign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_incremental_unassign()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_init_transactions","text":"public static rd_kafka_init_transactions ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_init_transactions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_acknowledgement","text":"public static rd_kafka_interceptor_add_on_acknowledgement ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_acknowledgement , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_acknowledgement \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_acknowledgement()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_commit","text":"public static rd_kafka_interceptor_add_on_commit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_commit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_commit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_commit()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_consume","text":"public static rd_kafka_interceptor_add_on_consume ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_consume , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_consume \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_consume()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_destroy","text":"public static rd_kafka_interceptor_add_on_destroy ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_request_sent","text":"public static rd_kafka_interceptor_add_on_request_sent ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_request_sent , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_request_sent \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_request_sent()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_response_received","text":"public static rd_kafka_interceptor_add_on_response_received ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_response_received , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_response_received \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_response_received()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_send","text":"public static rd_kafka_interceptor_add_on_send ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_send , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_send \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_send()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_thread_exit","text":"public static rd_kafka_interceptor_add_on_thread_exit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_exit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_exit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_thread_exit()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_add_on_thread_start","text":"public static rd_kafka_interceptor_add_on_thread_start ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_start , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_start \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_thread_start()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_acknowledgement_t","text":"public static rd_kafka_interceptor_f_on_acknowledgement_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_acknowledgement_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_commit_t","text":"public static rd_kafka_interceptor_f_on_commit_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_commit_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_destroy_t","text":"public static rd_kafka_interceptor_f_on_conf_destroy_t ( \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_conf_destroy_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_dup_t","text":"public static rd_kafka_interceptor_f_on_conf_dup_t ( \\FFI\\CData | null $new_conf , \\FFI\\CData | null $old_conf , int | null $filter_cnt , \\FFI\\CData | null $filter , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters new_conf \\FFI\\CData|null rd_kafka_conf_t* old_conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_conf_dup_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_conf_set_t","text":"public static rd_kafka_interceptor_f_on_conf_set_t ( \\FFI\\CData | null $conf , string | null $name , string | null $val , \\FFI\\CData | null $errstr , int | null $errstr_size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* val string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_conf_res_t","title":"rd_kafka_interceptor_f_on_conf_set_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_consume_t","text":"public static rd_kafka_interceptor_f_on_consume_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_consume_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_destroy_t","text":"public static rd_kafka_interceptor_f_on_destroy_t ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_destroy_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_new_t","text":"public static rd_kafka_interceptor_f_on_new_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $ic_opaque , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* conf \\FFI\\CData|null rd_kafka_conf_t* ic_opaque \\FFI\\CData|object|string|null void* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_new_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_request_sent_t","text":"public static rd_kafka_interceptor_f_on_request_sent_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_request_sent_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_response_received_t","text":"public static rd_kafka_interceptor_f_on_response_received_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , int | null $rtt , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t rtt int|null int64_t err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_response_received_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_send_t","text":"public static rd_kafka_interceptor_f_on_send_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_send_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_thread_exit_t","text":"public static rd_kafka_interceptor_f_on_thread_exit_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_thread_exit_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_interceptor_f_on_thread_start_t","text":"public static rd_kafka_interceptor_f_on_thread_start_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_thread_start_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_last_error","text":"public static rd_kafka_last_error ( ) : int Returns the last error code generated by a legacy API call in the current thread. The legacy APIs are the ones using errno to propagate error value, namely: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() The main use for this function is to avoid converting system errno values to rd_kafka_resp_err_t codes for legacy APIs. Remarks The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call. Returns int rd_kafka_resp_err_t - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7","title":"rd_kafka_last_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_list_groups","text":"public static rd_kafka_list_groups ( \\FFI\\CData | null $rk , string | null $group , \\FFI\\CData | null $grplistp , int | null $timeout_ms ) : int List and describe client groups in cluster. group is an optional group name to describe, otherwise ( NULL ) all groups are returned. timeout_ms is the (approximate) maximum time to wait for response from brokers and must be a positive value. See also Use rd_kafka_group_list_destroy() to release list memory. Parameters rk \\FFI\\CData|null rd_kafka_t* group string|null const char* grplistp \\FFI\\CData|null struct rd_kafka_group_list** timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success and grplistp is updated to point to a newly allocated list of groups. Else returns an error code on failure and grplistp remains untouched. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a","title":"rd_kafka_list_groups()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_log_print","text":"public static rd_kafka_log_print ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char*","title":"rd_kafka_log_print()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_log_syslog","text":"public static rd_kafka_log_syslog ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char*","title":"rd_kafka_log_syslog()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_calloc","text":"public static rd_kafka_mem_calloc ( \\FFI\\CData | null $rk , int | null $num , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* num int|null size_t size int|null size_t Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_mem_calloc()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_free","text":"public static rd_kafka_mem_free ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ptr ) : void Free pointer returned by librdkafka. This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka. In standard setups it is usually not necessary to use this interface rather than the free(3) functione. Remarks rd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing. Parameters rk \\FFI\\CData|null rd_kafka_t* ptr \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572","title":"rd_kafka_mem_free()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mem_malloc","text":"public static rd_kafka_mem_malloc ( \\FFI\\CData | null $rk , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* size int|null size_t Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_mem_malloc()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_memberid","text":"public static rd_kafka_memberid ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Returns this client's broker-assigned group member id. Remarks This currently requires the high-level KafkaConsumer Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with free() or rd_kafka_mem_free() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6","title":"rd_kafka_memberid()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_broker_id","text":"public static rd_kafka_message_broker_id ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int32_t","title":"rd_kafka_message_broker_id()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_destroy","text":"public static rd_kafka_message_destroy ( \\FFI\\CData | null $rkmessage ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t*","title":"rd_kafka_message_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_detach_headers","text":"public static rd_kafka_message_detach_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t","title":"rd_kafka_message_detach_headers()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_errstr","text":"public static rd_kafka_message_errstr ( \\FFI\\CData | null $rkmessage ) : string | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns string|null const char*","title":"rd_kafka_message_errstr()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_headers","text":"public static rd_kafka_message_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t","title":"rd_kafka_message_headers()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_latency","text":"public static rd_kafka_message_latency ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int64_t","title":"rd_kafka_message_latency()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_set_headers","text":"public static rd_kafka_message_set_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrs ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrs \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_message_set_headers()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_status","text":"public static rd_kafka_message_status ( \\FFI\\CData | null $rkmessage ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int rd_kafka_msg_status_t","title":"rd_kafka_message_status()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_message_timestamp","text":"public static rd_kafka_message_timestamp ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $tstype ) : int | null Returns the message timestamp for a consumed message. The timestamp is the number of milliseconds since the epoch (UTC). tstype (if not NULL) is updated to indicate the type of timestamp. Remarks Message timestamps require broker version 0.10.0 or later. Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* tstype \\FFI\\CData|null rd_kafka_timestamp_type_t* Returns int|null int64_t - message timestamp, or -1 if not available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7","title":"rd_kafka_message_timestamp()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_metadata","text":"public static rd_kafka_metadata ( \\FFI\\CData | null $rk , int | null $all_topics , \\FFI\\CData | null $only_rkt , \\FFI\\CData | null $metadatap , int | null $timeout_ms ) : int Request Metadata from broker. Parameters: all_topics if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics. only_rkt only request info about this topic metadatap pointer to hold metadata result. The *metadatap pointer must be released with rd_kafka_metadata_destroy(). timeout_ms maximum response time before failing. Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. Parameters rk \\FFI\\CData|null rd_kafka_t* all_topics int|null int only_rkt \\FFI\\CData|null rd_kafka_topic_t* metadatap \\FFI\\CData|null struct rd_kafka_metadata** timeout_ms int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344","title":"rd_kafka_metadata()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_metadata_destroy","text":"public static rd_kafka_metadata_destroy ( \\FFI\\CData | \\Closure $metadata ) : void Parameters metadata \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, struct rd_kafka_metadata**, int)","title":"rd_kafka_metadata_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_push_request_error_rtts","text":"public static rd_kafka_mock_broker_push_request_error_rtts ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_push_request_error_rtts()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_push_request_errors","text":"public static rd_kafka_mock_broker_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_push_request_errors()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_down","text":"public static rd_kafka_mock_broker_set_down ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_down()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_rack","text":"public static rd_kafka_mock_broker_set_rack ( \\FFI\\CData | null $mcluster , int | null $broker_id , string | null $rack ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rack string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_rack()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_rtt","text":"public static rd_kafka_mock_broker_set_rtt ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $rtt_ms ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rtt_ms int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_rtt()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_broker_set_up","text":"public static rd_kafka_mock_broker_set_up ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_up()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_clear_request_errors","text":"public static rd_kafka_mock_clear_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t","title":"rd_kafka_mock_clear_request_errors()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_bootstraps","text":"public static rd_kafka_mock_cluster_bootstraps ( \\FFI\\CData | null $mcluster ) : string | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns string|null const char*","title":"rd_kafka_mock_cluster_bootstraps()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_destroy","text":"public static rd_kafka_mock_cluster_destroy ( \\FFI\\CData | null $mcluster ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_mock_cluster_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_handle","text":"public static rd_kafka_mock_cluster_handle ( \\FFI\\CData | null $mcluster ) : \\FFI\\CData | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns \\FFI\\CData|null rd_kafka_t*","title":"rd_kafka_mock_cluster_handle()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_cluster_new","text":"public static rd_kafka_mock_cluster_new ( \\FFI\\CData | null $rk , int | null $broker_cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* broker_cnt int|null int Returns \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_mock_cluster_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_coordinator_set","text":"public static rd_kafka_mock_coordinator_set ( \\FFI\\CData | null $mcluster , string | null $key_type , string | null $key , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* key_type string|null const char* key string|null const char* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_coordinator_set()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_follower","text":"public static rd_kafka_mock_partition_set_follower ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_follower()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_follower_wmarks","text":"public static rd_kafka_mock_partition_set_follower_wmarks ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $lo , int | null $hi ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t lo int|null int64_t hi int|null int64_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_follower_wmarks()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_partition_set_leader","text":"public static rd_kafka_mock_partition_set_leader ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_leader()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_push_request_errors","text":"public static rd_kafka_mock_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , mixed $args ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t args mixed","title":"rd_kafka_mock_push_request_errors()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_push_request_errors_array","text":"public static rd_kafka_mock_push_request_errors_array ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , \\FFI\\CData | null $errors ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t errors \\FFI\\CData|null rd_kafka_resp_err_t*","title":"rd_kafka_mock_push_request_errors_array()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_set_apiversion","text":"public static rd_kafka_mock_set_apiversion ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $MinVersion , int | null $MaxVersion ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t MinVersion int|null int16_t MaxVersion int|null int16_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_set_apiversion()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_topic_create","text":"public static rd_kafka_mock_topic_create ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition_cnt , int | null $replication_factor ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition_cnt int|null int replication_factor int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_topic_create()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_mock_topic_set_error","text":"public static rd_kafka_mock_topic_set_error ( \\FFI\\CData | null $mcluster , string | null $topic , int $err ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* err int rd_kafka_resp_err_t","title":"rd_kafka_mock_topic_set_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_consistent","text":"public static rd_kafka_msg_partitioner_consistent ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent partitioner. Uses consistent hashing to map identical keys onto identical partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef","title":"rd_kafka_msg_partitioner_consistent()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_consistent_random","text":"public static rd_kafka_msg_partitioner_consistent_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent-Random partitioner. This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key (if provided) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb","title":"rd_kafka_msg_partitioner_consistent_random()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_fnv1a","text":"public static rd_kafka_msg_partitioner_fnv1a ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_fnv1a()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_fnv1a_random","text":"public static rd_kafka_msg_partitioner_fnv1a_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_fnv1a_random()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_murmur2","text":"public static rd_kafka_msg_partitioner_murmur2 ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_murmur2()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_murmur2_random","text":"public static rd_kafka_msg_partitioner_murmur2_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_murmur2_random()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_msg_partitioner_random","text":"public static rd_kafka_msg_partitioner_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Random partitioner. Will try not to return unavailable partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a random partition between 0 and partition_cnt - 1. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8","title":"rd_kafka_msg_partitioner_random()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_name","text":"public static rd_kafka_name ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char*","title":"rd_kafka_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_new","text":"public static rd_kafka_new ( int $type , \\FFI\\CData | null $conf , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Creates a new Kafka handle and starts its operation according to the specified type ( RD_KAFKA_CONSUMER or RD_KAFKA_PRODUCER ). conf is an optional struct created with rd_kafka_conf_new() that will be used instead of the default configuration. The conf object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See rd_kafka_conf_set() et.al for more information. errstr must be a pointer to memory of at least size errstr_size where rd_kafka_new() may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL. Remarks RD_KAFKA_CONSUMER: When a new RD_KAFKA_CONSUMER rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API. An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See also To destroy the Kafka handle, use rd_kafka_destroy(). Parameters type int rd_kafka_type_t conf \\FFI\\CData|null rd_kafka_conf_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_t* - The Kafka handle on success or NULL on error (see errstr ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24","title":"rd_kafka_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_oauthbearer_set_token","text":"public static rd_kafka_oauthbearer_set_token ( \\FFI\\CData | null $rk , string | null $token_value , int | null $md_lifetime_ms , string | null $md_principal_name , \\FFI\\CData | null $extensions , int | null $extension_size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* token_value string|null const char* md_lifetime_ms int|null int64_t md_principal_name string|null const char* extensions \\FFI\\CData|null char** extension_size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_oauthbearer_set_token()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_oauthbearer_set_token_failure","text":"public static rd_kafka_oauthbearer_set_token_failure ( \\FFI\\CData | null $rk , string | null $errstr ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_oauthbearer_set_token_failure()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offset_store","text":"public static rd_kafka_offset_store ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int Store offset offset for topic rkt partition partition . The offset will be committed (written) to the offset store according to auto.commit.interval.ms . Remarks auto.commit.enable must be set to \"false\" when using this API. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4","title":"rd_kafka_offset_store()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offsets_for_times","text":"public static rd_kafka_offsets_for_times ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $timeout_ms ) : int Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition. The timestamps to query are represented as offset in offsets on input, and offset will contain the offset on output. The function will block for at most timeout_ms milliseconds. Remarks Duplicate Topic+Partitions are not supported. Per-partition errors may be returned in rd_kafka_topic_partition_t.err Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - an error code for general errors, else RD_KAFKA_RESP_ERR_NO_ERROR in which case per-partition errors might be set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929","title":"rd_kafka_offsets_for_times()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_offsets_store","text":"public static rd_kafka_offsets_store ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_offsets_store()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_opaque","text":"public static rd_kafka_opaque ( \\FFI\\CData | null $rk ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_outq_len","text":"public static rd_kafka_outq_len ( \\FFI\\CData | null $rk ) : int | null Returns the current out queue length. The out queue contains messages waiting to be sent to, or acknowledged by, the broker. An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int|null int - number of messages in the out queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7","title":"rd_kafka_outq_len()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_pause_partitions","text":"public static rd_kafka_pause_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Pause producing or consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce","title":"rd_kafka_pause_partitions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_plugin_f_conf_init_t","text":"public static rd_kafka_plugin_f_conf_init_t ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $plug_opaquep , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* plug_opaquep \\FFI\\CData|object|string|null void** errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_plugin_f_conf_init_t()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_poll","text":"public static rd_kafka_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Polls the provided kafka handle for events. Events will cause application provided callbacks to be called. The timeout_ms argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as timeout_ms . To wait indefinately for an event, provide -1. Remarks An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called. Events: delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer] error callbacks (rd_kafka_conf_set_error_cb()) [all] stats callbacks (rd_kafka_conf_set_stats_cb()) [all] throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all] Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4","title":"rd_kafka_poll()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_poll_set_consumer","text":"public static rd_kafka_poll_set_consumer ( \\FFI\\CData | null $rk ) : int Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). Warning It is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904","title":"rd_kafka_poll_set_consumer()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_position","text":"public static rd_kafka_position ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Retrieve current positions (offsets) for topics+partitions. The offset field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac","title":"rd_kafka_position()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produce","text":"public static rd_kafka_produce ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | object | string | null $payload , int | null $len , \\FFI\\CData | object | string | null $key , int | null $keylen , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Produce and send a single message to broker. rkt is the target topic which must have been previously created with rd_kafka_topic_new() . rd_kafka_produce() is an asynch non-blocking API. partition is the target partition, either: RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or a fixed partition (0..N) msgflags is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block produce* () call if queue.buffering.max.messages or queue.buffering.max.kbytes are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on RD_KAFKA_MSG_F_BLOCK above. RD_KAFKA_MSG_F_FREE - rdkafka will free(3) payload when it is done with it. RD_KAFKA_MSG_F_COPY - the payload data will be copied and the payload pointer will not be used by rdkafka after the call returns. .._F_FREE and .._F_COPY are mutually exclusive. If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility. payload is the message payload of size len bytes. key is an optional message key of size keylen bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer. msg_opaque is an optional application-provided per-message opaque pointer that will provided in the delivery report callback ( dr_cb ) for referencing this message. Returns 0 on success or -1 on error in which case errno is set accordingly: ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL) EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE) ESRCH - requested partition is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also Use rd_kafka_errno2err() to convert errno to rdkafka error code. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int payload \\FFI\\CData|object|string|null void* len int|null size_t key \\FFI\\CData|object|string|null void* keylen int|null size_t msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736","title":"rd_kafka_produce()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produce_batch","text":"public static rd_kafka_produce_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | null $rkmessages , int | null $message_cnt ) : int | null Produce multiple messages. If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster). The messages are provided in the array rkmessages of count message_cnt elements. The partition and msgflags are used for all provided messages. Honoured rkmessages [] fields are: payload,len Message payload and length key,key_len Optional message key _private Message opaque pointer (msg_opaque) err Will be set according to success or failure. Application only needs to check for errors if return value != message_cnt . Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t* message_cnt int|null int Returns int|null int - the number of messages succesfully enqueued for producing. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed","title":"rd_kafka_produce_batch()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_producev","text":"public static rd_kafka_producev ( \\FFI\\CData | null $rk , mixed $args ) : int Produce and send a single message to broker. The message is defined by a va-arg list using rd_kafka_vtype_t tag tuples which must be terminated with a single RD_KAFKA_V_END . See also rd_kafka_produce, RD_KAFKA_V_END Parameters rk \\FFI\\CData|null rd_kafka_t* args mixed Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc","title":"rd_kafka_producev()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_produceva","text":"public static rd_kafka_produceva ( \\FFI\\CData | null $rk , \\FFI\\CData | null $vus , int | null $cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* vus \\FFI\\CData|null rd_kafka_vu_t* cnt int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_produceva()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_purge","text":"public static rd_kafka_purge ( \\FFI\\CData | null $rk , int | null $purge_flags ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* purge_flags int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_purge()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_query_watermark_offsets","text":"public static rd_kafka_query_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high , int | null $timeout_ms ) : int Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. Offsets are returned in *low and *high respectively. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4550ff7d014f08406666124573f70495","title":"rd_kafka_query_watermark_offsets()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_cb_event_enable","text":"public static rd_kafka_queue_cb_event_enable ( \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $event_cb , \\FFI\\CData | object | string | null $opaque ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*) opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_queue_cb_event_enable()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_destroy","text":"public static rd_kafka_queue_destroy ( \\FFI\\CData | null $rkqu ) : void Destroy a queue, purging all of its enqueued messages. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e","title":"rd_kafka_queue_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_forward","text":"public static rd_kafka_queue_forward ( \\FFI\\CData | null $src , \\FFI\\CData | null $dst ) : void Forward/re-route queue src to dst . If dst is NULL the forwarding is removed. The internal refcounts for both queues are increased. Remarks Regardless of whether dst is NULL or not, after calling this function, src will not forward it's fetch queue to the consumer queue. Parameters src \\FFI\\CData|null rd_kafka_queue_t* dst \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338","title":"rd_kafka_queue_forward()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_background","text":"public static rd_kafka_queue_get_background ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_queue_get_background()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_consumer","text":"public static rd_kafka_queue_get_consumer ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078","title":"rd_kafka_queue_get_consumer()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_main","text":"public static rd_kafka_queue_get_main ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863","title":"rd_kafka_queue_get_main()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_get_partition","text":"public static rd_kafka_queue_get_partition ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue This function only works on consumers. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d","title":"rd_kafka_queue_get_partition()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_io_event_enable","text":"public static rd_kafka_queue_io_event_enable ( \\FFI\\CData | null $rkqu , int | null $fd , \\FFI\\CData | object | string | null $payload , int | null $size ) : void Enable IO event triggering for queue. To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write payload (of size size ) to whenever a new element is enqueued on a previously empty queue. To remove event triggering call with fd = -1. librdkafka will maintain a copy of the payload . Remarks When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* fd int|null int payload \\FFI\\CData|object|string|null void* size int|null size_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784","title":"rd_kafka_queue_io_event_enable()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_length","text":"public static rd_kafka_queue_length ( \\FFI\\CData | null $rkqu ) : int | null Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) Returns int|null size_t - the current number of elements in queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57","title":"rd_kafka_queue_length()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_new","text":"public static rd_kafka_queue_new ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Create a new message queue. See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44","title":"rd_kafka_queue_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_poll","text":"public static rd_kafka_queue_poll ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Poll a queue for an event for max timeout_ms . Remarks Use rd_kafka_event_destroy() to free the event. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_event_t* - an event, or NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa","title":"rd_kafka_queue_poll()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_poll_callback","text":"public static rd_kafka_queue_poll_callback ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : int | null Poll a queue for events served through callbacks for max timeout_ms . Remarks This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e","title":"rd_kafka_queue_poll_callback()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_queue_yield","text":"public static rd_kafka_queue_yield ( \\FFI\\CData | null $rkqu ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_queue_yield()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_rebalance_protocol","text":"public static rd_kafka_rebalance_protocol ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char*","title":"rd_kafka_rebalance_protocol()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_resume_partitions","text":"public static rd_kafka_resume_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Resume producing consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2","title":"rd_kafka_resume_partitions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_seek","text":"public static rd_kafka_seek ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , int | null $timeout_ms ) : int Seek consumer for topic+partition to offset which is either an absolute or logical offset. If timeout_ms is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns RD_KAFKA_RESP_ERR__TIMED_OUT . If timeout_ms is 0 it will initiate the seek but return immediately without any error reporting (e.g., async). This call triggers a fetch queue barrier flush. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d","title":"rd_kafka_seek()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_seek_partitions","text":"public static rd_kafka_seek_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_seek_partitions()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_send_offsets_to_transaction","text":"public static rd_kafka_send_offsets_to_transaction ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $cgmetadata , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* cgmetadata \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_send_offsets_to_transaction()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_log_level","text":"public static rd_kafka_set_log_level ( \\FFI\\CData | null $rk , int | null $level ) : void Specifies the maximum logging level produced by internal kafka logging and debugging. If the \"debug\" configuration property is set the level is automatically adjusted to LOG_DEBUG (7). Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4","title":"rd_kafka_set_log_level()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_log_queue","text":"public static rd_kafka_set_log_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkqu ) : int Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. This allows an application to serve log callbacks ( log_cb ) in its thread of choice. Remarks The configuration property log.queue MUST also be set to true. librdkafka maintains its own reference to the provided queue. Parameters rk \\FFI\\CData|null rd_kafka_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d","title":"rd_kafka_set_log_queue()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_set_logger","text":"public static rd_kafka_set_logger ( \\FFI\\CData | null $rk , \\FFI\\CData | \\Closure $func ) : void Set logger function. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging. Deprecated: Use rd_kafka_conf_set_log_cb() Remarks rk may be passed as NULL in the callback. Parameters rk \\FFI\\CData|null rd_kafka_t* func \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53","title":"rd_kafka_set_logger()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_subscribe","text":"public static rd_kafka_subscribe ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Subscribe to topic set using balanced consumer groups. Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the topics list that is prefixed with \"^\" will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1","title":"rd_kafka_subscribe()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_subscription","text":"public static rd_kafka_subscription ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Returns the current topic subscription. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise topic is updated to point to a newly allocated topic list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200","title":"rd_kafka_subscription()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_test_fatal_error","text":"public static rd_kafka_test_fatal_error ( \\FFI\\CData | null $rk , int $err , string | null $reason ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* err int rd_kafka_resp_err_t reason string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_test_fatal_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_thread_cnt","text":"public static rd_kafka_thread_cnt ( ) : int | null Retrieve the current number of threads in use by librdkafka. Used by regression tests. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0901699375c972b807ba5255773f017f","title":"rd_kafka_thread_cnt()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_destroy","text":"public static rd_kafka_topic_conf_destroy ( \\FFI\\CData | null $topic_conf ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_topic_conf_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_dump","text":"public static rd_kafka_topic_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the topic configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696","title":"rd_kafka_topic_conf_dump()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_dup","text":"public static rd_kafka_topic_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_topic_conf_dup()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_get","text":"public static rd_kafka_topic_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve topic configuration value for property name . See also rd_kafka_conf_get() Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d","title":"rd_kafka_topic_conf_get()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_new","text":"public static rd_kafka_topic_conf_new ( ) : \\FFI\\CData | null Create topic configuration object. See also Same semantics as for rd_kafka_conf_new(). Returns \\FFI\\CData|null rd_kafka_topic_conf_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e","title":"rd_kafka_topic_conf_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set","text":"public static rd_kafka_topic_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a single rd_kafka_topic_conf_t value by property name. topic_conf should have been previously set up with rd_kafka_topic_conf_new() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01","title":"rd_kafka_topic_conf_set()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_msg_order_cmp","text":"public static rd_kafka_topic_conf_set_msg_order_cmp ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $msg_order_cmp ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* msg_order_cmp \\FFI\\CData|\\Closure int( )(rd_kafka_message_t , rd_kafka_message_t*)","title":"rd_kafka_topic_conf_set_msg_order_cmp()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_opaque","text":"public static rd_kafka_topic_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_topic_conf_set_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_conf_set_partitioner_cb","text":"public static rd_kafka_topic_conf_set_partitioner_cb ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $partitioner ) : void Producer: Set partitioner callback in provided topic conf object. The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key. Partitioner function constraints: MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available() MUST NOT block or execute for prolonged periods of time. MUST return a value between 0 and partition_cnt-1, or the special RD_KAFKA_PARTITION_UA value if partitioning could not be performed. Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* partitioner \\FFI\\CData|\\Closure int32_t( )(rd_kafka_topic_t , void*, size_t, int32_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf","title":"rd_kafka_topic_conf_set_partitioner_cb()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_destroy","text":"public static rd_kafka_topic_destroy ( \\FFI\\CData | null $rkt ) : void Loose application's topic handle refcount as previously created with rd_kafka_topic_new() . Remarks Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff","title":"rd_kafka_topic_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_name","text":"public static rd_kafka_topic_name ( \\FFI\\CData | null $rkt ) : string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns string|null const char*","title":"rd_kafka_topic_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_new","text":"public static rd_kafka_topic_new ( \\FFI\\CData | null $rk , string | null $topic , \\FFI\\CData | null $conf ) : \\FFI\\CData | null Creates a new topic handle for topic named topic . conf is an optional configuration for the topic created with rd_kafka_topic_conf_new() that will be used instead of the default topic configuration. The conf object is freed by this function and must not be used or destroyed by the application sub-sequently. See rd_kafka_topic_conf_set() et.al for more information. Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources. See also rd_kafka_topic_destroy() Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system errno to an rd_kafka_resp_err_t error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8","title":"rd_kafka_topic_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_opaque","text":"public static rd_kafka_topic_opaque ( \\FFI\\CData | null $rkt ) : \\FFI\\CData | object | string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_topic_opaque()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_available","text":"public static rd_kafka_topic_partition_available ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Check if partition is available (has a leader broker). Warning This function must only be called from inside a partitioner function Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 1 if the partition is available, else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758","title":"rd_kafka_topic_partition_available()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_destroy","text":"public static rd_kafka_topic_partition_destroy ( \\FFI\\CData | null $rktpar ) : void Destroy a rd_kafka_topic_partition_t. Remarks This must not be called for elements in a topic partition list. Parameters rktpar \\FFI\\CData|null rd_kafka_topic_partition_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a","title":"rd_kafka_topic_partition_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_add","text":"public static rd_kafka_topic_partition_list_add ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Add topic+partition to list. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) partition int|null int32_t - Partition id Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d","title":"rd_kafka_topic_partition_list_add()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_add_range","text":"public static rd_kafka_topic_partition_list_add_range ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $start , int | null $stop ) : void Add range of partitions from start to stop inclusive. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) start int|null int32_t - Start partition of range stop int|null int32_t - Last partition of range (inclusive) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b","title":"rd_kafka_topic_partition_list_add_range()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_copy","text":"public static rd_kafka_topic_partition_list_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Make a copy of an existing list. Parameters src \\FFI\\CData|null rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to src See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7","title":"rd_kafka_topic_partition_list_copy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_del","text":"public static rd_kafka_topic_partition_list_del ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : int | null Delete partition from list. Remarks Any held indices to elems[] are unusable after this call returns 1. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to modify topic string|null const char* - Topic name to match partition int|null int32_t - Partition to match Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97","title":"rd_kafka_topic_partition_list_del()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_del_by_idx","text":"public static rd_kafka_topic_partition_list_del_by_idx ( \\FFI\\CData | null $rktparlist , int | null $idx ) : int | null Delete partition from list by elems[] index. See also rd_kafka_topic_partition_list_del() Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* idx int|null int Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463","title":"rd_kafka_topic_partition_list_del_by_idx()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_destroy","text":"public static rd_kafka_topic_partition_list_destroy ( \\FFI\\CData | null $rkparlist ) : void Parameters rkparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t*","title":"rd_kafka_topic_partition_list_destroy()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_find","text":"public static rd_kafka_topic_partition_list_find ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Find element by topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa","title":"rd_kafka_topic_partition_list_find()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_new","text":"public static rd_kafka_topic_partition_list_new ( int | null $size ) : \\FFI\\CData | null Create a new list/vector Topic+Partition container. Remarks Use rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself. See also rd_kafka_topic_partition_list_add() Parameters size int|null int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a","title":"rd_kafka_topic_partition_list_new()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_set_offset","text":"public static rd_kafka_topic_partition_list_set_offset ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition , int | null $offset ) : int Set offset to offset for topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if partition was not found in the list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d","title":"rd_kafka_topic_partition_list_set_offset()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_partition_list_sort","text":"public static rd_kafka_topic_partition_list_sort ( \\FFI\\CData | null $rktparlist , \\FFI\\CData | \\Closure $cmp , \\FFI\\CData | object | string | null $opaque ) : void Sort list using comparator cmp . If cmp is NULL the default comparator will be used that sorts by ascending topic name and partition. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* cmp \\FFI\\CData|\\Closure int( )(void , void*, void*) opaque \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f","title":"rd_kafka_topic_partition_list_sort()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_error","text":"public static rd_kafka_topic_result_error ( \\FFI\\CData | null $topicres ) : int Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_topic_result_error()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_error_string","text":"public static rd_kafka_topic_result_error_string ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char*","title":"rd_kafka_topic_result_error_string()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_topic_result_name","text":"public static rd_kafka_topic_result_name ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char*","title":"rd_kafka_topic_result_name()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_type","text":"public static rd_kafka_type ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_type_t","title":"rd_kafka_type()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_unittest","text":"public static rd_kafka_unittest ( ) : int | null Returns int|null int","title":"rd_kafka_unittest()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_unsubscribe","text":"public static rd_kafka_unsubscribe ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_unsubscribe()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_version","text":"public static rd_kafka_version ( ) : int | null Returns the librdkafka version as integer. See also See RD_KAFKA_VERSION for how to parse the integer format. Use rd_kafka_version_str() to retreive the version as a string. Returns int|null int - ) - Version integer. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e","title":"rd_kafka_version()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_version_str","text":"public static rd_kafka_version_str ( ) : string | null Returns the librdkafka version as string. Returns string|null const char* - ) - Version string See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a","title":"rd_kafka_version_str()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_wait_destroyed","text":"public static rd_kafka_wait_destroyed ( int | null $timeout_ms ) : int | null Wait for all rd_kafka_t objects to be destroyed. Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached. Since rd_kafka_destroy() is an asynch operation the rd_kafka_wait_destroyed() function can be used for applications where a clean shutdown is required. Parameters timeout_ms int|null int - ) Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d","title":"rd_kafka_wait_destroyed()"},{"location":"api/RdKafka/FFI/Library/#rd_kafka_yield","text":"public static rd_kafka_yield ( \\FFI\\CData | null $rk ) : void Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events. Remarks This function MUST ONLY be called from within a librdkafka callback. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d","title":"rd_kafka_yield()"},{"location":"api/RdKafka/FFI/Library/#requiremethod","text":"public static requireMethod ( string $name ) : void Method must be supported by current binding version otherwise an exception is thrown. Parameters name string","title":"requireMethod()"},{"location":"api/RdKafka/FFI/Library/#requireversion","text":"public static requireVersion ( string $operator , string $version ) : void Version must match the current binding otherwise an exception is thrown. Parameters operator string version string","title":"requireVersion()"},{"location":"api/RdKafka/FFI/Library/#type","text":"public static type ( string | \\FFI\\CType $type ) : \\FFI\\CType Parameters type string|\\FFI\\CType Returns \\FFI\\CType","title":"type()"},{"location":"api/RdKafka/FFI/Library/#versionmatches","text":"public static versionMatches ( string $operator , string $version ) : bool Whether version matches the current binding version Parameters operator string version string Returns bool","title":"versionMatches()"},{"location":"api/RdKafka/FFI/Library/#test-coverage","text":"\ud83d\udc9b Lines: 83.13% (69 / 83) \u2764\ufe0f Methods: 50% (9 / 18)","title":"Test Coverage \ud83d\udc9b"},{"location":"api/RdKafka/FFI/LogCallbackProxy/","text":"Class LogCallbackProxy \u00b6 Class \\RdKafka\\FFI\\LogCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $rdkafka , int $level , string $facility , string $message ) : void Parameters rdkafka \\FFI\\CData level int facility string message string Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (3 / 3) \ud83d\udc9a Methods: 100% (1 / 1)","title":"LogCallbackProxy"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#class-logcallbackproxy","text":"Class \\RdKafka\\FFI\\LogCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class LogCallbackProxy"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $rdkafka , int $level , string $facility , string $message ) : void Parameters rdkafka \\FFI\\CData level int facility string message string","title":"__invoke()"},{"location":"api/RdKafka/FFI/LogCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (3 / 3) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/Methods/","text":"Trait Methods \u00b6 Trait \\RdKafka\\FFI\\Methods Description of librdkafka methods and constants is extracted from the official documentation. See also https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html Methods \u00b6 getFFI() \u00b6 public static getFFI ( ) : \\FFI Returns \\FFI rd_kafka_version() \u00b6 public static rd_kafka_version ( ) : int | null Returns the librdkafka version as integer. See also See RD_KAFKA_VERSION for how to parse the integer format. Use rd_kafka_version_str() to retreive the version as a string. Returns int|null int - ) - Version integer. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e rd_kafka_version_str() \u00b6 public static rd_kafka_version_str ( ) : string | null Returns the librdkafka version as string. Returns string|null const char* - ) - Version string See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a rd_kafka_get_debug_contexts() \u00b6 public static rd_kafka_get_debug_contexts ( ) : string | null Retrieve supported debug contexts for use with the \"debug\" configuration property. (runtime) Returns string|null const char* - ) - Comma-separated list of available debugging contexts. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45 rd_kafka_get_err_descs() \u00b6 public static rd_kafka_get_err_descs ( \\FFI\\CData | null $errdescs , \\FFI\\CData | null $cntp ) : void Parameters errdescs \\FFI\\CData|null struct rd_kafka_err_desc** cntp \\FFI\\CData|null size_t* rd_kafka_err2str() \u00b6 public static rd_kafka_err2str ( int $err ) : string | null Returns a human readable representation of a kafka error. Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d rd_kafka_err2name() \u00b6 public static rd_kafka_err2name ( int $err ) : string | null Returns the error code name (enum name). Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77 rd_kafka_last_error() \u00b6 public static rd_kafka_last_error ( ) : int Returns the last error code generated by a legacy API call in the current thread. The legacy APIs are the ones using errno to propagate error value, namely: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() The main use for this function is to avoid converting system errno values to rd_kafka_resp_err_t codes for legacy APIs. Remarks The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call. Returns int rd_kafka_resp_err_t - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7 rd_kafka_errno2err() \u00b6 public static rd_kafka_errno2err ( int | null $errnox ) : int Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the following functions: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() Remarks A better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. See also rd_kafka_last_error() Parameters errnox int|null int - ) - System errno value to convert Returns int rd_kafka_resp_err_t - Appropriate error code for errnox See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f rd_kafka_errno() \u00b6 public static rd_kafka_errno ( ) : int | null Returns the thread-local system errno. On most platforms this is the same as errno but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for expsing the errno librdkafka uses. Remarks The value is local to the current calling thread. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aef27224d8c638e51f3ee29bb25f65f1f rd_kafka_fatal_error() \u00b6 public static rd_kafka_fatal_error ( \\FFI\\CData | null $rk , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_test_fatal_error() \u00b6 public static rd_kafka_test_fatal_error ( \\FFI\\CData | null $rk , int $err , string | null $reason ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* err int rd_kafka_resp_err_t reason string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_topic_partition_destroy() \u00b6 public static rd_kafka_topic_partition_destroy ( \\FFI\\CData | null $rktpar ) : void Destroy a rd_kafka_topic_partition_t. Remarks This must not be called for elements in a topic partition list. Parameters rktpar \\FFI\\CData|null rd_kafka_topic_partition_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a rd_kafka_topic_partition_list_new() \u00b6 public static rd_kafka_topic_partition_list_new ( int | null $size ) : \\FFI\\CData | null Create a new list/vector Topic+Partition container. Remarks Use rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself. See also rd_kafka_topic_partition_list_add() Parameters size int|null int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a rd_kafka_topic_partition_list_destroy() \u00b6 public static rd_kafka_topic_partition_list_destroy ( \\FFI\\CData | null $rkparlist ) : void Parameters rkparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* rd_kafka_topic_partition_list_add() \u00b6 public static rd_kafka_topic_partition_list_add ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Add topic+partition to list. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) partition int|null int32_t - Partition id Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d rd_kafka_topic_partition_list_add_range() \u00b6 public static rd_kafka_topic_partition_list_add_range ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $start , int | null $stop ) : void Add range of partitions from start to stop inclusive. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) start int|null int32_t - Start partition of range stop int|null int32_t - Last partition of range (inclusive) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b rd_kafka_topic_partition_list_del() \u00b6 public static rd_kafka_topic_partition_list_del ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : int | null Delete partition from list. Remarks Any held indices to elems[] are unusable after this call returns 1. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to modify topic string|null const char* - Topic name to match partition int|null int32_t - Partition to match Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97 rd_kafka_topic_partition_list_del_by_idx() \u00b6 public static rd_kafka_topic_partition_list_del_by_idx ( \\FFI\\CData | null $rktparlist , int | null $idx ) : int | null Delete partition from list by elems[] index. See also rd_kafka_topic_partition_list_del() Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* idx int|null int Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463 rd_kafka_topic_partition_list_copy() \u00b6 public static rd_kafka_topic_partition_list_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Make a copy of an existing list. Parameters src \\FFI\\CData|null rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to src See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7 rd_kafka_topic_partition_list_set_offset() \u00b6 public static rd_kafka_topic_partition_list_set_offset ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition , int | null $offset ) : int Set offset to offset for topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if partition was not found in the list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d rd_kafka_topic_partition_list_find() \u00b6 public static rd_kafka_topic_partition_list_find ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Find element by topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa rd_kafka_topic_partition_list_sort() \u00b6 public static rd_kafka_topic_partition_list_sort ( \\FFI\\CData | null $rktparlist , \\FFI\\CData | \\Closure $cmp , \\FFI\\CData | object | string | null $opaque ) : void Sort list using comparator cmp . If cmp is NULL the default comparator will be used that sorts by ascending topic name and partition. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* cmp \\FFI\\CData|\\Closure int( )(void , void*, void*) opaque \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f rd_kafka_headers_new() \u00b6 public static rd_kafka_headers_new ( int | null $initial_count ) : \\FFI\\CData | null Parameters initial_count int|null size_t Returns \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_headers_destroy() \u00b6 public static rd_kafka_headers_destroy ( \\FFI\\CData | null $hdrs ) : void Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_headers_copy() \u00b6 public static rd_kafka_headers_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Parameters src \\FFI\\CData|null rd_kafka_headers_t* Returns \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_header_add() \u00b6 public static rd_kafka_header_add ( \\FFI\\CData | null $hdrs , string | null $name , int | null $name_size , \\FFI\\CData | object | string | null $value , int | null $value_size ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* name_size int|null ssize_t value \\FFI\\CData|object|string|null void* value_size int|null ssize_t Returns int rd_kafka_resp_err_t rd_kafka_header_remove() \u00b6 public static rd_kafka_header_remove ( \\FFI\\CData | null $hdrs , string | null $name ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_header_get_last() \u00b6 public static rd_kafka_header_get_last ( \\FFI\\CData | null $hdrs , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_header_get() \u00b6 public static rd_kafka_header_get ( \\FFI\\CData | null $hdrs , int | null $idx , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_header_get_all() \u00b6 public static rd_kafka_header_get_all ( \\FFI\\CData | null $hdrs , int | null $idx , \\FFI\\CData | null $namep , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t namep \\FFI\\CData|null char** valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t rd_kafka_message_destroy() \u00b6 public static rd_kafka_message_destroy ( \\FFI\\CData | null $rkmessage ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* rd_kafka_message_timestamp() \u00b6 public static rd_kafka_message_timestamp ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $tstype ) : int | null Returns the message timestamp for a consumed message. The timestamp is the number of milliseconds since the epoch (UTC). tstype (if not NULL) is updated to indicate the type of timestamp. Remarks Message timestamps require broker version 0.10.0 or later. Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* tstype \\FFI\\CData|null rd_kafka_timestamp_type_t* Returns int|null int64_t - message timestamp, or -1 if not available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7 rd_kafka_message_latency() \u00b6 public static rd_kafka_message_latency ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int64_t rd_kafka_message_headers() \u00b6 public static rd_kafka_message_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t rd_kafka_message_detach_headers() \u00b6 public static rd_kafka_message_detach_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t rd_kafka_message_set_headers() \u00b6 public static rd_kafka_message_set_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrs ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrs \\FFI\\CData|null rd_kafka_headers_t* rd_kafka_header_cnt() \u00b6 public static rd_kafka_header_cnt ( \\FFI\\CData | null $hdrs ) : int | null Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* Returns int|null size_t rd_kafka_message_status() \u00b6 public static rd_kafka_message_status ( \\FFI\\CData | null $rkmessage ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int rd_kafka_msg_status_t rd_kafka_conf_new() \u00b6 public static rd_kafka_conf_new ( ) : \\FFI\\CData | null Create configuration object. When providing your own configuration to the rd_kafka_*_new_* () calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: 1 rd_kafka_conf_t *myconf; 2 rd_kafka_conf_res_t res; 3 4 myconf = rd_kafka_conf_new(); 5 res = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\", 6 errstr, sizeof(errstr)); 7 if (res != RD_KAFKA_CONF_OK) 8 die(\"%s\\n\", errstr); 9 10 rk = rd_kafka_new(..., myconf); Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime. The properties are identical to the Apache Kafka configuration properties whenever possible. See also rd_kafka_conf_set(), rd_kafka_conf_destroy() Returns \\FFI\\CData|null rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c rd_kafka_conf_destroy() \u00b6 public static rd_kafka_conf_destroy ( \\FFI\\CData | null $conf ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_dup() \u00b6 public static rd_kafka_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_dup_filter() \u00b6 public static rd_kafka_conf_dup_filter ( \\FFI\\CData | null $conf , int | null $filter_cnt , \\FFI\\CData | null $filter ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** Returns \\FFI\\CData|null rd_kafka_conf_t* rd_kafka_conf_set() \u00b6 public static rd_kafka_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a configuration property. conf must have been previously created with rd_kafka_conf_new(). Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the default_topic_conf . If no default_topic_conf has been set one will be created. Any sub-sequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. In case of failure errstr is updated to contain a human readable error string. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8 rd_kafka_conf_set_events() \u00b6 public static rd_kafka_conf_set_events ( \\FFI\\CData | null $conf , int | null $events ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* events int|null int rd_kafka_conf_set_background_event_cb() \u00b6 public static rd_kafka_conf_set_background_event_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $event_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_event_t*, void*) rd_kafka_conf_set_dr_cb() \u00b6 public static rd_kafka_conf_set_dr_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_cb ) : void Deprecated: See rd_kafka_conf_set_dr_msg_cb() Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*, size_t, rd_kafka_resp_err_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f rd_kafka_conf_set_dr_msg_cb() \u00b6 public static rd_kafka_conf_set_dr_msg_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_msg_cb ) : void Producer: Set delivery report callback in provided conf object. The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with err set to indicate the result of the produce request. The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted. An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_msg_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_message_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a rd_kafka_conf_set_consume_cb() \u00b6 public static rd_kafka_conf_set_consume_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $consume_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) rd_kafka_conf_set_rebalance_cb() \u00b6 public static rd_kafka_conf_set_rebalance_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $rebalance_cb ) : void Consumer: Set rebalance callback for use with coordinated consumer group balancing. The err field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked. Registering a rebalance_cb turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's rebalance_cb . The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where err is neither of those. Remarks In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke). Remarks The partitions list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application. The following example shows the application's responsibilities: 1 static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err, 2 rd_kafka_topic_partition_list_t *partitions, 3 void *opaque) { 4 5 switch (err) 6 { 7 case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS: 8 // application may load offets from arbitrary external 9 // storage here and update \\p partitions 10 11 rd_kafka_assign(rk, partitions); 12 break; 13 14 case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS: 15 if (manual_commits) // Optional explicit manual commit 16 rd_kafka_commit(rk, partitions, 0); // sync commit 17 18 rd_kafka_assign(rk, NULL); 19 break; 20 21 default: 22 handle_unlikely_error(err); 23 rd_kafka_assign(rk, NULL); // sync state 24 break; 25 } 26 } Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rebalance_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311 rd_kafka_conf_set_offset_commit_cb() \u00b6 public static rd_kafka_conf_set_offset_commit_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $offset_commit_cb ) : void Consumer: Set offset commit callback for use with consumer groups. The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll(). If no partitions had valid offsets to commit this callback will be called with err == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error. The offsets list contains per-partition information: offset: committed offset (attempted) err: commit error Parameters conf \\FFI\\CData|null rd_kafka_conf_t* offset_commit_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb rd_kafka_conf_set_error_cb() \u00b6 public static rd_kafka_conf_set_error_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $error_cb ) : void Set error callback in provided conf object. The error callback is used by librdkafka to signal critical errors back to the application. If no error_cb is registered then the errors will be logged instead. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* error_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90 rd_kafka_conf_set_throttle_cb() \u00b6 public static rd_kafka_conf_set_throttle_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $throttle_cb ) : void Set throttle callback. The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests. Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero. An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks. Remarks Requires broker version 0.9.0 or later. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* throttle_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, int32_t, int, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7 rd_kafka_conf_set_log_cb() \u00b6 public static rd_kafka_conf_set_log_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $log_cb ) : void Set logger callback. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass func as NULL to disable logging. This is the configuration alternative to the deprecated rd_kafka_set_logger() Remarks The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through rd_kafka_set_log_queue() . An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded log_cb . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* log_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f rd_kafka_conf_set_stats_cb() \u00b6 public static rd_kafka_conf_set_stats_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $stats_cb ) : void Set statistics callback in provided conf object. The statistics callback is triggered from rd_kafka_poll() every statistics.interval.ms (needs to be configured separately). Function arguments: rk - Kafka handle json - String containing the statistics data in JSON format json_len - Length of json string. opaque - Application-provided opaque. If the application wishes to hold on to the json pointer and free it at a later time it must return 1 from the stats_cb . If the application returns 0 from the stats_cb then librdkafka will immediately free the json pointer. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* stats_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , char*, size_t, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766 rd_kafka_conf_set_socket_cb() \u00b6 public static rd_kafka_conf_set_socket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $socket_cb ) : void Set socket callback. The socket callback is responsible for opening a socket according to the supplied domain , type and protocol . The socket shall be created with CLOEXEC set in a racefree fashion, if possible. Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* socket_cb \\FFI\\CData|\\Closure int( )(int, int, int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf rd_kafka_conf_set_connect_cb() \u00b6 public static rd_kafka_conf_set_connect_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $connect_cb ) : void Set connect callback. The connect callback is responsible for connecting socket sockfd to peer address addr . The id field contains the broker identifier. connect_cb shall return 0 on success (socket connected) or an error number (errno) on error. Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* connect_cb \\FFI\\CData|\\Closure int( )(int, struct sockaddr , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040 rd_kafka_conf_set_closesocket_cb() \u00b6 public static rd_kafka_conf_set_closesocket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $closesocket_cb ) : void Set close socket callback. Close a socket (optionally opened with socket_cb()). Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* closesocket_cb \\FFI\\CData|\\Closure int( )(int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7 rd_kafka_conf_set_opaque() \u00b6 public static rd_kafka_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_opaque() \u00b6 public static rd_kafka_opaque ( \\FFI\\CData | null $rk ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|object|string|null void* rd_kafka_conf_set_default_topic_conf() \u00b6 public static rd_kafka_conf_set_default_topic_conf ( \\FFI\\CData | null $conf , \\FFI\\CData | null $tconf ) : void Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* tconf \\FFI\\CData|null rd_kafka_topic_conf_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63 rd_kafka_conf_get() \u00b6 public static rd_kafka_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve configuration value for property name . If dest is non-NULL the value will be written to dest with at most dest_size . *dest_size is updated to the full length of the value, thus if *dest_size initially is smaller than the full length the application may reallocate dest to fit the returned *dest_size and try again. If dest is NULL only the full length of the value is returned. Fallthrough: Topic-level configuration properties from the default_topic_conf may be retrieved using this interface. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property name matched, else RD_KAFKA_CONF_UNKNOWN . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97 rd_kafka_topic_conf_get() \u00b6 public static rd_kafka_topic_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve topic configuration value for property name . See also rd_kafka_conf_get() Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d rd_kafka_conf_dump() \u00b6 public static rd_kafka_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c rd_kafka_topic_conf_dump() \u00b6 public static rd_kafka_topic_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the topic configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696 rd_kafka_conf_dump_free() \u00b6 public static rd_kafka_conf_dump_free ( \\FFI\\CData | null $arr , int | null $cnt ) : void Parameters arr \\FFI\\CData|null char** cnt int|null size_t rd_kafka_conf_properties_show() \u00b6 public static rd_kafka_conf_properties_show ( \\FFI\\CData | null $fp ) : void Parameters fp \\FFI\\CData|null FILE* rd_kafka_topic_conf_new() \u00b6 public static rd_kafka_topic_conf_new ( ) : \\FFI\\CData | null Create topic configuration object. See also Same semantics as for rd_kafka_conf_new(). Returns \\FFI\\CData|null rd_kafka_topic_conf_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e rd_kafka_topic_conf_dup() \u00b6 public static rd_kafka_topic_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_default_topic_conf_dup() \u00b6 public static rd_kafka_default_topic_conf_dup ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_topic_conf_destroy() \u00b6 public static rd_kafka_topic_conf_destroy ( \\FFI\\CData | null $topic_conf ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_topic_conf_set() \u00b6 public static rd_kafka_topic_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a single rd_kafka_topic_conf_t value by property name. topic_conf should have been previously set up with rd_kafka_topic_conf_new() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01 rd_kafka_topic_conf_set_opaque() \u00b6 public static rd_kafka_topic_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_topic_conf_set_partitioner_cb() \u00b6 public static rd_kafka_topic_conf_set_partitioner_cb ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $partitioner ) : void Producer: Set partitioner callback in provided topic conf object. The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key. Partitioner function constraints: MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available() MUST NOT block or execute for prolonged periods of time. MUST return a value between 0 and partition_cnt-1, or the special RD_KAFKA_PARTITION_UA value if partitioning could not be performed. Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* partitioner \\FFI\\CData|\\Closure int32_t( )(rd_kafka_topic_t , void*, size_t, int32_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf rd_kafka_topic_conf_set_msg_order_cmp() \u00b6 public static rd_kafka_topic_conf_set_msg_order_cmp ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $msg_order_cmp ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* msg_order_cmp \\FFI\\CData|\\Closure int( )(rd_kafka_message_t , rd_kafka_message_t*) rd_kafka_topic_partition_available() \u00b6 public static rd_kafka_topic_partition_available ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Check if partition is available (has a leader broker). Warning This function must only be called from inside a partitioner function Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 1 if the partition is available, else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758 rd_kafka_msg_partitioner_random() \u00b6 public static rd_kafka_msg_partitioner_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Random partitioner. Will try not to return unavailable partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a random partition between 0 and partition_cnt - 1. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8 rd_kafka_msg_partitioner_consistent() \u00b6 public static rd_kafka_msg_partitioner_consistent ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent partitioner. Uses consistent hashing to map identical keys onto identical partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef rd_kafka_msg_partitioner_consistent_random() \u00b6 public static rd_kafka_msg_partitioner_consistent_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent-Random partitioner. This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key (if provided) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb rd_kafka_msg_partitioner_murmur2() \u00b6 public static rd_kafka_msg_partitioner_murmur2 ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_murmur2_random() \u00b6 public static rd_kafka_msg_partitioner_murmur2_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_new() \u00b6 public static rd_kafka_new ( int $type , \\FFI\\CData | null $conf , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Creates a new Kafka handle and starts its operation according to the specified type ( RD_KAFKA_CONSUMER or RD_KAFKA_PRODUCER ). conf is an optional struct created with rd_kafka_conf_new() that will be used instead of the default configuration. The conf object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See rd_kafka_conf_set() et.al for more information. errstr must be a pointer to memory of at least size errstr_size where rd_kafka_new() may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL. Remarks RD_KAFKA_CONSUMER: When a new RD_KAFKA_CONSUMER rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API. An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See also To destroy the Kafka handle, use rd_kafka_destroy(). Parameters type int rd_kafka_type_t conf \\FFI\\CData|null rd_kafka_conf_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_t* - The Kafka handle on success or NULL on error (see errstr ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24 rd_kafka_destroy() \u00b6 public static rd_kafka_destroy ( \\FFI\\CData | null $rk ) : void Destroy Kafka handle. Remarks This is a blocking operation. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794 rd_kafka_destroy_flags() \u00b6 public static rd_kafka_destroy_flags ( \\FFI\\CData | null $rk , int | null $flags ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* flags int|null int rd_kafka_name() \u00b6 public static rd_kafka_name ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char* rd_kafka_type() \u00b6 public static rd_kafka_type ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_type_t rd_kafka_memberid() \u00b6 public static rd_kafka_memberid ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Returns this client's broker-assigned group member id. Remarks This currently requires the high-level KafkaConsumer Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with free() or rd_kafka_mem_free() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6 rd_kafka_clusterid() \u00b6 public static rd_kafka_clusterid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null char* rd_kafka_controllerid() \u00b6 public static rd_kafka_controllerid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int32_t rd_kafka_topic_new() \u00b6 public static rd_kafka_topic_new ( \\FFI\\CData | null $rk , string | null $topic , \\FFI\\CData | null $conf ) : \\FFI\\CData | null Creates a new topic handle for topic named topic . conf is an optional configuration for the topic created with rd_kafka_topic_conf_new() that will be used instead of the default topic configuration. The conf object is freed by this function and must not be used or destroyed by the application sub-sequently. See rd_kafka_topic_conf_set() et.al for more information. Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources. See also rd_kafka_topic_destroy() Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system errno to an rd_kafka_resp_err_t error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8 rd_kafka_topic_destroy() \u00b6 public static rd_kafka_topic_destroy ( \\FFI\\CData | null $rkt ) : void Loose application's topic handle refcount as previously created with rd_kafka_topic_new() . Remarks Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff rd_kafka_topic_name() \u00b6 public static rd_kafka_topic_name ( \\FFI\\CData | null $rkt ) : string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns string|null const char* rd_kafka_topic_opaque() \u00b6 public static rd_kafka_topic_opaque ( \\FFI\\CData | null $rkt ) : \\FFI\\CData | object | string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns \\FFI\\CData|object|string|null void* rd_kafka_poll() \u00b6 public static rd_kafka_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Polls the provided kafka handle for events. Events will cause application provided callbacks to be called. The timeout_ms argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as timeout_ms . To wait indefinately for an event, provide -1. Remarks An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called. Events: delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer] error callbacks (rd_kafka_conf_set_error_cb()) [all] stats callbacks (rd_kafka_conf_set_stats_cb()) [all] throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all] Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4 rd_kafka_yield() \u00b6 public static rd_kafka_yield ( \\FFI\\CData | null $rk ) : void Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events. Remarks This function MUST ONLY be called from within a librdkafka callback. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d rd_kafka_pause_partitions() \u00b6 public static rd_kafka_pause_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Pause producing or consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce rd_kafka_resume_partitions() \u00b6 public static rd_kafka_resume_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Resume producing consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2 rd_kafka_query_watermark_offsets() \u00b6 public static rd_kafka_query_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high , int | null $timeout_ms ) : int Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. Offsets are returned in *low and *high respectively. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4550ff7d014f08406666124573f70495 rd_kafka_get_watermark_offsets() \u00b6 public static rd_kafka_get_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high ) : int Get last known low (oldest/beginning) and high (newest/end) offsets for partition. The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker. If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset. Offsets are returned in *low and *high respectively. Remarks Shall only be used with an active consumer instance. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82 rd_kafka_offsets_for_times() \u00b6 public static rd_kafka_offsets_for_times ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $timeout_ms ) : int Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition. The timestamps to query are represented as offset in offsets on input, and offset will contain the offset on output. The function will block for at most timeout_ms milliseconds. Remarks Duplicate Topic+Partitions are not supported. Per-partition errors may be returned in rd_kafka_topic_partition_t.err Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - an error code for general errors, else RD_KAFKA_RESP_ERR_NO_ERROR in which case per-partition errors might be set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929 rd_kafka_mem_free() \u00b6 public static rd_kafka_mem_free ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ptr ) : void Free pointer returned by librdkafka. This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka. In standard setups it is usually not necessary to use this interface rather than the free(3) functione. Remarks rd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing. Parameters rk \\FFI\\CData|null rd_kafka_t* ptr \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572 rd_kafka_queue_new() \u00b6 public static rd_kafka_queue_new ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Create a new message queue. See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44 rd_kafka_queue_destroy() \u00b6 public static rd_kafka_queue_destroy ( \\FFI\\CData | null $rkqu ) : void Destroy a queue, purging all of its enqueued messages. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e rd_kafka_queue_get_main() \u00b6 public static rd_kafka_queue_get_main ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863 rd_kafka_queue_get_consumer() \u00b6 public static rd_kafka_queue_get_consumer ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078 rd_kafka_queue_get_partition() \u00b6 public static rd_kafka_queue_get_partition ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue This function only works on consumers. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d rd_kafka_queue_get_background() \u00b6 public static rd_kafka_queue_get_background ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_queue_forward() \u00b6 public static rd_kafka_queue_forward ( \\FFI\\CData | null $src , \\FFI\\CData | null $dst ) : void Forward/re-route queue src to dst . If dst is NULL the forwarding is removed. The internal refcounts for both queues are increased. Remarks Regardless of whether dst is NULL or not, after calling this function, src will not forward it's fetch queue to the consumer queue. Parameters src \\FFI\\CData|null rd_kafka_queue_t* dst \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338 rd_kafka_set_log_queue() \u00b6 public static rd_kafka_set_log_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkqu ) : int Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. This allows an application to serve log callbacks ( log_cb ) in its thread of choice. Remarks The configuration property log.queue MUST also be set to true. librdkafka maintains its own reference to the provided queue. Parameters rk \\FFI\\CData|null rd_kafka_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d rd_kafka_queue_length() \u00b6 public static rd_kafka_queue_length ( \\FFI\\CData | null $rkqu ) : int | null Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) Returns int|null size_t - the current number of elements in queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57 rd_kafka_queue_io_event_enable() \u00b6 public static rd_kafka_queue_io_event_enable ( \\FFI\\CData | null $rkqu , int | null $fd , \\FFI\\CData | object | string | null $payload , int | null $size ) : void Enable IO event triggering for queue. To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write payload (of size size ) to whenever a new element is enqueued on a previously empty queue. To remove event triggering call with fd = -1. librdkafka will maintain a copy of the payload . Remarks When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* fd int|null int payload \\FFI\\CData|object|string|null void* size int|null size_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784 rd_kafka_queue_cb_event_enable() \u00b6 public static rd_kafka_queue_cb_event_enable ( \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $event_cb , \\FFI\\CData | object | string | null $opaque ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*) opaque \\FFI\\CData|object|string|null void* rd_kafka_consume_start() \u00b6 public static rd_kafka_consume_start ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int | null Start consuming messages for topic rkt and partition at offset offset which may either be an absolute (0..N) or one of the logical offsets: RD_KAFKA_OFFSET_BEGINNING RD_KAFKA_OFFSET_END RD_KAFKA_OFFSET_STORED RD_KAFKA_OFFSET_TAIL rdkafka will attempt to keep queued.min.messages (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached. The application shall use one of the rd_kafka_consume*() functions to consume messages from the local queue, each kafka message being represented as a rd_kafka_message_t * object. rd_kafka_consume_start() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . Use rd_kafka_errno2err() to convert sytem errno to rd_kafka_resp_err_t Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int|null int - 0 on success or -1 on error in which case errno is set accordingly: EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT) EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG) ESRCH - requested partition is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4 rd_kafka_consume_start_queue() \u00b6 public static rd_kafka_consume_start_queue ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , \\FFI\\CData | null $rkqu ) : int | null Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which must have been previously allocated with rd_kafka_queue_new() . The application must use one of the rd_kafka_consume_*_queue() functions to receive fetched messages. rd_kafka_consume_start_queue() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . rd_kafka_consume_start() and rd_kafka_consume_start_queue() must not be combined for the same topic and partition. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t rkqu \\FFI\\CData|null rd_kafka_queue_t* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258 rd_kafka_consume_stop() \u00b6 public static rd_kafka_consume_stop ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Stop consuming messages for topic rkt and partition , purging all messages currently in the local queue. NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method. The application needs to be stop all consumers before calling rd_kafka_destroy() on the main object handle. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 0 on success or -1 on error (see errno ). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4 rd_kafka_seek() \u00b6 public static rd_kafka_seek ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , int | null $timeout_ms ) : int Seek consumer for topic+partition to offset which is either an absolute or logical offset. If timeout_ms is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns RD_KAFKA_RESP_ERR__TIMED_OUT . If timeout_ms is 0 it will initiate the seek but return immediately without any error reporting (e.g., async). This call triggers a fetch queue barrier flush. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d rd_kafka_consume() \u00b6 public static rd_kafka_consume ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms ) : \\FFI\\CData | null Consume a single message from topic rkt and partition . timeout_ms is maximum amount of time to wait for a message to be received. Consumer must have been previously started with rd_kafka_consume_start() . Returns a message object on success or NULL on error. The message object must be destroyed with rd_kafka_message_destroy() when the application is done with it. Errors (when returning NULL): ETIMEDOUT - timeout_ms was reached with no new messages fetched. ENOENT - rkt + partition is unknown. (no prior rd_kafka_consume_start() call) NOTE: The returned message's ..->err must be checked for errors. NOTE: ..->err == RD_KAFKA_RESP_ERR__PARTITION_EOF signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore). Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e rd_kafka_consume_batch() \u00b6 public static rd_kafka_consume_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the application provided array rkmessages (of size rkmessages_size entries). rd_kafka_consume_batch() provides higher throughput performance than rd_kafka_consume() . timeout_ms is the maximum amount of time to wait for all of rkmessages_size messages to be put into rkmessages . If no messages were available within the timeout period this function returns 0 and rkmessages remains untouched. This differs somewhat from rd_kafka_consume() . The message objects must be destroyed with rd_kafka_message_destroy() when the application is done with it. See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t - the number of rkmessages added in rkmessages , or -1 on error (same error codes as for rd_kafka_consume() . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce rd_kafka_consume_callback() \u00b6 public static rd_kafka_consume_callback ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consumes messages from topic rkt and partition , calling the provided callback for each consumed messsage. rd_kafka_consume_callback() provides higher throughput performance than both rd_kafka_consume() and rd_kafka_consume_batch() . timeout_ms is the maximum amount of time to wait for one or more messages to arrive. The provided consume_cb function is called for each message, the application MUST NOT call rd_kafka_message_destroy() on the provided rkmessage . The opaque argument is passed to the 'consume_cb' as opaque . See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int - the number of messages processed or -1 on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6 rd_kafka_consume_queue() \u00b6 public static rd_kafka_consume_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Consume from queue. See also rd_kafka_consume() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16 rd_kafka_consume_batch_queue() \u00b6 public static rd_kafka_consume_batch_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume batch of messages from queue. See also rd_kafka_consume_batch() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3d949238471993b18537855aad28fa23 rd_kafka_consume_callback_queue() \u00b6 public static rd_kafka_consume_callback_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consume multiple messages from queue with callback. See also rd_kafka_consume_callback() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532 rd_kafka_offset_store() \u00b6 public static rd_kafka_offset_store ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int Store offset offset for topic rkt partition partition . The offset will be committed (written) to the offset store according to auto.commit.interval.ms . Remarks auto.commit.enable must be set to \"false\" when using this API. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4 rd_kafka_offsets_store() \u00b6 public static rd_kafka_offsets_store ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t rd_kafka_subscribe() \u00b6 public static rd_kafka_subscribe ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Subscribe to topic set using balanced consumer groups. Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the topics list that is prefixed with \"^\" will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1 rd_kafka_unsubscribe() \u00b6 public static rd_kafka_unsubscribe ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_resp_err_t rd_kafka_subscription() \u00b6 public static rd_kafka_subscription ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Returns the current topic subscription. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise topic is updated to point to a newly allocated topic list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200 rd_kafka_consumer_poll() \u00b6 public static rd_kafka_consumer_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Poll the consumer for messages or events. Will block for at most timeout_ms milliseconds. Remarks An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. See also rd_kafka_message_t Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* - A message object which is a proper message if ->err is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf rd_kafka_consumer_close() \u00b6 public static rd_kafka_consumer_close ( \\FFI\\CData | null $rk ) : int Close down the KafkaConsumer. Remarks This call will block until the consumer has revoked its assignment, calling the rebalance_cb if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms. Remarks The application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d rd_kafka_assign() \u00b6 public static rd_kafka_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Atomic assignment of partitions to consume. The new partitions will replace the existing assignment. When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state. A zero-length partitions will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a NULL value for partitions will reset and clear the internal state. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9 rd_kafka_assignment() \u00b6 public static rd_kafka_assignment ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Returns the current partition assignment. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise partitions is updated to point to a newly allocated partition list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59 rd_kafka_commit() \u00b6 public static rd_kafka_commit ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $async ) : int Commit offsets on broker for the provided list of partitions. offsets should contain topic , partition , offset and possibly metadata . If offsets is NULL the current partition assignment will be used instead. If async is false this operation will block until the broker offset commit is done, returning the resulting success or error code. If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar. Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87 rd_kafka_commit_message() \u00b6 public static rd_kafka_commit_message ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , int | null $async ) : int Commit message's offset on broker for the message's partition. See also rd_kafka_commit Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null rd_kafka_message_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883 rd_kafka_commit_queue() \u00b6 public static rd_kafka_commit_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $cb , \\FFI\\CData | object | string | null $opaque ) : int Commit offsets on broker for the provided list of partitions. See rd_kafka_commit for offsets semantics. The result of the offset commit will be posted on the provided rkqu queue. If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the cb callback is required. opaque is passed to the callback. If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The opaque value will be available with rd_kafka_event_opaque() If rkqu is NULL a temporary queue will be created and the callback will be served by this call. See also rd_kafka_commit() rd_kafka_conf_set_offset_commit_cb() Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47 rd_kafka_committed() \u00b6 public static rd_kafka_committed ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : int Retrieve committed offsets for topics+partitions. The offset field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13 rd_kafka_position() \u00b6 public static rd_kafka_position ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Retrieve current positions (offsets) for topics+partitions. The offset field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac rd_kafka_produce() \u00b6 public static rd_kafka_produce ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | object | string | null $payload , int | null $len , \\FFI\\CData | object | string | null $key , int | null $keylen , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Produce and send a single message to broker. rkt is the target topic which must have been previously created with rd_kafka_topic_new() . rd_kafka_produce() is an asynch non-blocking API. partition is the target partition, either: RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or a fixed partition (0..N) msgflags is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block produce* () call if queue.buffering.max.messages or queue.buffering.max.kbytes are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on RD_KAFKA_MSG_F_BLOCK above. RD_KAFKA_MSG_F_FREE - rdkafka will free(3) payload when it is done with it. RD_KAFKA_MSG_F_COPY - the payload data will be copied and the payload pointer will not be used by rdkafka after the call returns. .._F_FREE and .._F_COPY are mutually exclusive. If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility. payload is the message payload of size len bytes. key is an optional message key of size keylen bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer. msg_opaque is an optional application-provided per-message opaque pointer that will provided in the delivery report callback ( dr_cb ) for referencing this message. Returns 0 on success or -1 on error in which case errno is set accordingly: ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL) EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE) ESRCH - requested partition is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also Use rd_kafka_errno2err() to convert errno to rdkafka error code. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int payload \\FFI\\CData|object|string|null void* len int|null size_t key \\FFI\\CData|object|string|null void* keylen int|null size_t msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736 rd_kafka_producev() \u00b6 public static rd_kafka_producev ( \\FFI\\CData | null $rk , mixed $args ) : int Produce and send a single message to broker. The message is defined by a va-arg list using rd_kafka_vtype_t tag tuples which must be terminated with a single RD_KAFKA_V_END . See also rd_kafka_produce, RD_KAFKA_V_END Parameters rk \\FFI\\CData|null rd_kafka_t* args mixed Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc rd_kafka_produce_batch() \u00b6 public static rd_kafka_produce_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | null $rkmessages , int | null $message_cnt ) : int | null Produce multiple messages. If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster). The messages are provided in the array rkmessages of count message_cnt elements. The partition and msgflags are used for all provided messages. Honoured rkmessages [] fields are: payload,len Message payload and length key,key_len Optional message key _private Message opaque pointer (msg_opaque) err Will be set according to success or failure. Application only needs to check for errors if return value != message_cnt . Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t* message_cnt int|null int Returns int|null int - the number of messages succesfully enqueued for producing. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed rd_kafka_flush() \u00b6 public static rd_kafka_flush ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. Remarks This function will call rd_kafka_poll() and thus trigger callbacks. Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if timeout_ms was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d rd_kafka_purge() \u00b6 public static rd_kafka_purge ( \\FFI\\CData | null $rk , int | null $purge_flags ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* purge_flags int|null int Returns int rd_kafka_resp_err_t rd_kafka_metadata() \u00b6 public static rd_kafka_metadata ( \\FFI\\CData | null $rk , int | null $all_topics , \\FFI\\CData | null $only_rkt , \\FFI\\CData | null $metadatap , int | null $timeout_ms ) : int Request Metadata from broker. Parameters: all_topics if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics. only_rkt only request info about this topic metadatap pointer to hold metadata result. The *metadatap pointer must be released with rd_kafka_metadata_destroy(). timeout_ms maximum response time before failing. Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. Parameters rk \\FFI\\CData|null rd_kafka_t* all_topics int|null int only_rkt \\FFI\\CData|null rd_kafka_topic_t* metadatap \\FFI\\CData|null struct rd_kafka_metadata** timeout_ms int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344 rd_kafka_metadata_destroy() \u00b6 public static rd_kafka_metadata_destroy ( \\FFI\\CData | \\Closure $metadata ) : void Parameters metadata \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, struct rd_kafka_metadata**, int) rd_kafka_list_groups() \u00b6 public static rd_kafka_list_groups ( \\FFI\\CData | null $rk , string | null $group , \\FFI\\CData | null $grplistp , int | null $timeout_ms ) : int List and describe client groups in cluster. group is an optional group name to describe, otherwise ( NULL ) all groups are returned. timeout_ms is the (approximate) maximum time to wait for response from brokers and must be a positive value. See also Use rd_kafka_group_list_destroy() to release list memory. Parameters rk \\FFI\\CData|null rd_kafka_t* group string|null const char* grplistp \\FFI\\CData|null struct rd_kafka_group_list** timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success and grplistp is updated to point to a newly allocated list of groups. Else returns an error code on failure and grplistp remains untouched. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a rd_kafka_group_list_destroy() \u00b6 public static rd_kafka_group_list_destroy ( \\FFI\\CData | null $grplist ) : void Parameters grplist \\FFI\\CData|null struct rd_kafka_group_list* rd_kafka_brokers_add() \u00b6 public static rd_kafka_brokers_add ( \\FFI\\CData | null $rk , string | null $brokerlist ) : int | null Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata. If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion. brokerlist is a ,-separated list of brokers in the format: <broker1> ,<broker2>,.. Where each broker is in either the host or URL based format: <host> [:<port>] <proto> ://<host>[:port] <proto> is either PLAINTEXT , SSL , SASL , SASL_PLAINTEXT The two formats can be mixed but ultimately the value of the security.protocol config property decides what brokers are allowed. Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\" Remarks Brokers may also be defined with the metadata.broker.list or bootstrap.servers configuration property (preferred method). Parameters rk \\FFI\\CData|null rd_kafka_t* brokerlist string|null const char* Returns int|null int - the number of brokers successfully added. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7 rd_kafka_set_logger() \u00b6 public static rd_kafka_set_logger ( \\FFI\\CData | null $rk , \\FFI\\CData | \\Closure $func ) : void Set logger function. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging. Deprecated: Use rd_kafka_conf_set_log_cb() Remarks rk may be passed as NULL in the callback. Parameters rk \\FFI\\CData|null rd_kafka_t* func \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53 rd_kafka_set_log_level() \u00b6 public static rd_kafka_set_log_level ( \\FFI\\CData | null $rk , int | null $level ) : void Specifies the maximum logging level produced by internal kafka logging and debugging. If the \"debug\" configuration property is set the level is automatically adjusted to LOG_DEBUG (7). Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4 rd_kafka_log_print() \u00b6 public static rd_kafka_log_print ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char* rd_kafka_log_syslog() \u00b6 public static rd_kafka_log_syslog ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char* rd_kafka_outq_len() \u00b6 public static rd_kafka_outq_len ( \\FFI\\CData | null $rk ) : int | null Returns the current out queue length. The out queue contains messages waiting to be sent to, or acknowledged by, the broker. An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int|null int - number of messages in the out queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7 rd_kafka_dump() \u00b6 public static rd_kafka_dump ( \\FFI\\CData | null $fp , \\FFI\\CData | null $rk ) : void Dumps rdkafka's internal state for handle rk to stream fp . This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. Parameters fp \\FFI\\CData|null FILE* rk \\FFI\\CData|null rd_kafka_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1 rd_kafka_thread_cnt() \u00b6 public static rd_kafka_thread_cnt ( ) : int | null Retrieve the current number of threads in use by librdkafka. Used by regression tests. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0901699375c972b807ba5255773f017f rd_kafka_wait_destroyed() \u00b6 public static rd_kafka_wait_destroyed ( int | null $timeout_ms ) : int | null Wait for all rd_kafka_t objects to be destroyed. Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached. Since rd_kafka_destroy() is an asynch operation the rd_kafka_wait_destroyed() function can be used for applications where a clean shutdown is required. Parameters timeout_ms int|null int - ) Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d rd_kafka_unittest() \u00b6 public static rd_kafka_unittest ( ) : int | null Returns int|null int rd_kafka_poll_set_consumer() \u00b6 public static rd_kafka_poll_set_consumer ( \\FFI\\CData | null $rk ) : int Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). Warning It is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904 rd_kafka_event_type() \u00b6 public static rd_kafka_event_type ( \\FFI\\CData | null $rkev ) : int | null Remarks As a convenience it is okay to pass rkev as NULL in which case RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null rd_kafka_event_type_t - the event type for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d rd_kafka_event_name() \u00b6 public static rd_kafka_event_name ( \\FFI\\CData | null $rkev ) : string | null Remarks As a convenience it is okay to pass rkev as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the event type\u2019s name for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866 rd_kafka_event_destroy() \u00b6 public static rd_kafka_event_destroy ( \\FFI\\CData | null $rkev ) : void Destroy an event. Remarks Any references to this event, such as extracted messages, will not be usable after this call. As a convenience it is okay to pass rkev as NULL in which case no action is performed. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af1835c85aa202caf629861f29f475099 rd_kafka_event_message_next() \u00b6 public static rd_kafka_event_message_next ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Call repeatedly until it returns NULL. Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Remarks The returned message(s) MUST NOT be freed with rd_kafka_message_destroy(). Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null const rd_kafka_message_t* - the next message from an event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c rd_kafka_event_message_array() \u00b6 public static rd_kafka_event_message_array ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $rkmessages , int | null $size ) : int | null Extacts size message(s) from the event into the pre-allocated array rkmessages . Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* rkmessages \\FFI\\CData|null const rd_kafka_message_t** size int|null size_t Returns int|null size_t - the number of messages extracted. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8 rd_kafka_event_message_count() \u00b6 public static rd_kafka_event_message_count ( \\FFI\\CData | null $rkev ) : int | null Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null size_t - the number of remaining messages in the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90 rd_kafka_event_error() \u00b6 public static rd_kafka_event_error ( \\FFI\\CData | null $rkev ) : int Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int rd_kafka_resp_err_t - the error code for the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5 rd_kafka_event_error_string() \u00b6 public static rd_kafka_event_error_string ( \\FFI\\CData | null $rkev ) : string | null Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793 rd_kafka_event_error_is_fatal() \u00b6 public static rd_kafka_event_error_is_fatal ( \\FFI\\CData | null $rkev ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns int|null int rd_kafka_event_opaque() \u00b6 public static rd_kafka_event_opaque ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | object | string | null Event types: RD_KAFKA_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|object|string|null void* - the user opaque (if any) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525 rd_kafka_event_log() \u00b6 public static rd_kafka_event_log ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $fac , \\FFI\\CData | null $str , \\FFI\\CData | null $level ) : int | null Extract log message from the event. Event types: RD_KAFKA_EVENT_LOG Parameters rkev \\FFI\\CData|null rd_kafka_event_t* fac \\FFI\\CData|null char** str \\FFI\\CData|null char** level \\FFI\\CData|null int* Returns int|null int - 0 on success or -1 if unsupported event type. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7 rd_kafka_event_stats() \u00b6 public static rd_kafka_event_stats ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char* rd_kafka_event_topic_partition_list() \u00b6 public static rd_kafka_event_topic_partition_list ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() Event types: RD_KAFKA_EVENT_REBALANCE RD_KAFKA_EVENT_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - the topic partition list from the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633 rd_kafka_event_topic_partition() \u00b6 public static rd_kafka_event_topic_partition ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe rd_kafka_event_CreateTopics_result() \u00b6 public static rd_kafka_event_CreateTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* rd_kafka_event_DeleteTopics_result() \u00b6 public static rd_kafka_event_DeleteTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* rd_kafka_event_CreatePartitions_result() \u00b6 public static rd_kafka_event_CreatePartitions_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* rd_kafka_event_AlterConfigs_result() \u00b6 public static rd_kafka_event_AlterConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* rd_kafka_event_DescribeConfigs_result() \u00b6 public static rd_kafka_event_DescribeConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* rd_kafka_queue_poll() \u00b6 public static rd_kafka_queue_poll ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Poll a queue for an event for max timeout_ms . Remarks Use rd_kafka_event_destroy() to free the event. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_event_t* - an event, or NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa rd_kafka_queue_poll_callback() \u00b6 public static rd_kafka_queue_poll_callback ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : int | null Poll a queue for events served through callbacks for max timeout_ms . Remarks This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e rd_kafka_plugin_f_conf_init_t() \u00b6 public static rd_kafka_plugin_f_conf_init_t ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $plug_opaquep , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* plug_opaquep \\FFI\\CData|object|string|null void** errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_conf_set_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_set_t ( \\FFI\\CData | null $conf , string | null $name , string | null $val , \\FFI\\CData | null $errstr , int | null $errstr_size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* val string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_conf_res_t rd_kafka_interceptor_f_on_conf_dup_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_dup_t ( \\FFI\\CData | null $new_conf , \\FFI\\CData | null $old_conf , int | null $filter_cnt , \\FFI\\CData | null $filter , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters new_conf \\FFI\\CData|null rd_kafka_conf_t* old_conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_conf_destroy_t() \u00b6 public static rd_kafka_interceptor_f_on_conf_destroy_t ( \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_new_t() \u00b6 public static rd_kafka_interceptor_f_on_new_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $ic_opaque , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* conf \\FFI\\CData|null rd_kafka_conf_t* ic_opaque \\FFI\\CData|object|string|null void* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_destroy_t() \u00b6 public static rd_kafka_interceptor_f_on_destroy_t ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_send_t() \u00b6 public static rd_kafka_interceptor_f_on_send_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_acknowledgement_t() \u00b6 public static rd_kafka_interceptor_f_on_acknowledgement_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_consume_t() \u00b6 public static rd_kafka_interceptor_f_on_consume_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_commit_t() \u00b6 public static rd_kafka_interceptor_f_on_commit_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_request_sent_t() \u00b6 public static rd_kafka_interceptor_f_on_request_sent_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_set() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_set ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_set , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_set \\FFI\\CData|\\Closure rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_dup() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_dup ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_dup , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_dup \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, rd_kafka_conf_t*, size_t, char**, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_conf_destroy() \u00b6 public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_interceptor_add_on_new() \u00b6 public static rd_kafka_conf_interceptor_add_on_new ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_new , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_new \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, rd_kafka_conf_t*, void*, char*, size_t) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_destroy() \u00b6 public static rd_kafka_interceptor_add_on_destroy ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_send() \u00b6 public static rd_kafka_interceptor_add_on_send ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_send , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_send \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_acknowledgement() \u00b6 public static rd_kafka_interceptor_add_on_acknowledgement ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_acknowledgement , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_acknowledgement \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_consume() \u00b6 public static rd_kafka_interceptor_add_on_consume ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_consume , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_consume \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_commit() \u00b6 public static rd_kafka_interceptor_add_on_commit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_commit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_commit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_request_sent() \u00b6 public static rd_kafka_interceptor_add_on_request_sent ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_request_sent , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_request_sent \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_topic_result_error() \u00b6 public static rd_kafka_topic_result_error ( \\FFI\\CData | null $topicres ) : int Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns int rd_kafka_resp_err_t rd_kafka_topic_result_error_string() \u00b6 public static rd_kafka_topic_result_error_string ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char* rd_kafka_topic_result_name() \u00b6 public static rd_kafka_topic_result_name ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char* rd_kafka_AdminOptions_new() \u00b6 public static rd_kafka_AdminOptions_new ( \\FFI\\CData | null $rk , int $for_api ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* for_api int rd_kafka_admin_op_t Returns \\FFI\\CData|null rd_kafka_AdminOptions_t* rd_kafka_AdminOptions_destroy() \u00b6 public static rd_kafka_AdminOptions_destroy ( \\FFI\\CData | null $options ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* rd_kafka_AdminOptions_set_request_timeout() \u00b6 public static rd_kafka_AdminOptions_set_request_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_operation_timeout() \u00b6 public static rd_kafka_AdminOptions_set_operation_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_validate_only() \u00b6 public static rd_kafka_AdminOptions_set_validate_only ( \\FFI\\CData | null $options , int | null $true_or_false , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* true_or_false int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_broker() \u00b6 public static rd_kafka_AdminOptions_set_broker ( \\FFI\\CData | null $options , int | null $broker_id , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* broker_id int|null int32_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_AdminOptions_set_opaque() \u00b6 public static rd_kafka_AdminOptions_set_opaque ( \\FFI\\CData | null $options , \\FFI\\CData | object | string | null $opaque ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* opaque \\FFI\\CData|object|string|null void* rd_kafka_NewTopic_new() \u00b6 public static rd_kafka_NewTopic_new ( string | null $topic , int | null $num_partitions , int | null $replication_factor , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* num_partitions int|null int replication_factor int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewTopic_t* rd_kafka_NewTopic_destroy() \u00b6 public static rd_kafka_NewTopic_destroy ( \\FFI\\CData | null $new_topic ) : void Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* rd_kafka_NewTopic_destroy_array() \u00b6 public static rd_kafka_NewTopic_destroy_array ( \\FFI\\CData | null $new_topics , int | null $new_topic_cnt ) : void Parameters new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t rd_kafka_NewTopic_set_replica_assignment() \u00b6 public static rd_kafka_NewTopic_set_replica_assignment ( \\FFI\\CData | null $new_topic , int | null $partition , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* partition int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_NewTopic_set_config() \u00b6 public static rd_kafka_NewTopic_set_config ( \\FFI\\CData | null $new_topic , string | null $name , string | null $value ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_CreateTopics() \u00b6 public static rd_kafka_CreateTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_topics , int | null $new_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_CreateTopics_result_topics() \u00b6 public static rd_kafka_CreateTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_DeleteTopic_new() \u00b6 public static rd_kafka_DeleteTopic_new ( string | null $topic ) : \\FFI\\CData | null Parameters topic string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteTopic_t* rd_kafka_DeleteTopic_destroy() \u00b6 public static rd_kafka_DeleteTopic_destroy ( \\FFI\\CData | null $del_topic ) : void Parameters del_topic \\FFI\\CData|null rd_kafka_DeleteTopic_t* rd_kafka_DeleteTopic_destroy_array() \u00b6 public static rd_kafka_DeleteTopic_destroy_array ( \\FFI\\CData | null $del_topics , int | null $del_topic_cnt ) : void Parameters del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t rd_kafka_DeleteTopics() \u00b6 public static rd_kafka_DeleteTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_topics , int | null $del_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteTopics_result_topics() \u00b6 public static rd_kafka_DeleteTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_NewPartitions_new() \u00b6 public static rd_kafka_NewPartitions_new ( string | null $topic , int | null $new_total_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* new_total_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewPartitions_t* rd_kafka_NewPartitions_destroy() \u00b6 public static rd_kafka_NewPartitions_destroy ( \\FFI\\CData | null $new_parts ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* rd_kafka_NewPartitions_destroy_array() \u00b6 public static rd_kafka_NewPartitions_destroy_array ( \\FFI\\CData | null $new_parts , int | null $new_parts_cnt ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t rd_kafka_NewPartitions_set_replica_assignment() \u00b6 public static rd_kafka_NewPartitions_set_replica_assignment ( \\FFI\\CData | null $new_parts , int | null $new_partition_idx , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* new_partition_idx int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_CreatePartitions() \u00b6 public static rd_kafka_CreatePartitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_parts , int | null $new_parts_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_CreatePartitions_result_topics() \u00b6 public static rd_kafka_CreatePartitions_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t** rd_kafka_ConfigSource_name() \u00b6 public static rd_kafka_ConfigSource_name ( int $confsource ) : string | null Parameters confsource int rd_kafka_ConfigSource_t Returns string|null const char* rd_kafka_ConfigEntry_name() \u00b6 public static rd_kafka_ConfigEntry_name ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char* rd_kafka_ConfigEntry_value() \u00b6 public static rd_kafka_ConfigEntry_value ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char* rd_kafka_ConfigEntry_source() \u00b6 public static rd_kafka_ConfigEntry_source ( \\FFI\\CData | null $entry ) : int Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int rd_kafka_ConfigSource_t rd_kafka_ConfigEntry_is_read_only() \u00b6 public static rd_kafka_ConfigEntry_is_read_only ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_default() \u00b6 public static rd_kafka_ConfigEntry_is_default ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_sensitive() \u00b6 public static rd_kafka_ConfigEntry_is_sensitive ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_is_synonym() \u00b6 public static rd_kafka_ConfigEntry_is_synonym ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int rd_kafka_ConfigEntry_synonyms() \u00b6 public static rd_kafka_ConfigEntry_synonyms ( \\FFI\\CData | null $entry , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t** rd_kafka_ResourceType_name() \u00b6 public static rd_kafka_ResourceType_name ( int $restype ) : string | null Parameters restype int rd_kafka_ResourceType_t Returns string|null const char* rd_kafka_ConfigResource_new() \u00b6 public static rd_kafka_ConfigResource_new ( int $restype , string | null $resname ) : \\FFI\\CData | null Parameters restype int rd_kafka_ResourceType_t resname string|null const char* Returns \\FFI\\CData|null rd_kafka_ConfigResource_t* rd_kafka_ConfigResource_destroy() \u00b6 public static rd_kafka_ConfigResource_destroy ( \\FFI\\CData | null $config ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* rd_kafka_ConfigResource_destroy_array() \u00b6 public static rd_kafka_ConfigResource_destroy_array ( \\FFI\\CData | null $config , int | null $config_cnt ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t rd_kafka_ConfigResource_set_config() \u00b6 public static rd_kafka_ConfigResource_set_config ( \\FFI\\CData | null $config , string | null $name , string | null $value ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_ConfigResource_configs() \u00b6 public static rd_kafka_ConfigResource_configs ( \\FFI\\CData | null $config , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t** rd_kafka_ConfigResource_type() \u00b6 public static rd_kafka_ConfigResource_type ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_ResourceType_t rd_kafka_ConfigResource_name() \u00b6 public static rd_kafka_ConfigResource_name ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char* rd_kafka_ConfigResource_error() \u00b6 public static rd_kafka_ConfigResource_error ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_resp_err_t rd_kafka_ConfigResource_error_string() \u00b6 public static rd_kafka_ConfigResource_error_string ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char* rd_kafka_AlterConfigs() \u00b6 public static rd_kafka_AlterConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_AlterConfigs_result_resources() \u00b6 public static rd_kafka_AlterConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t** rd_kafka_DescribeConfigs() \u00b6 public static rd_kafka_DescribeConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null const rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DescribeConfigs_result_resources() \u00b6 public static rd_kafka_DescribeConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t** rd_kafka_conf() \u00b6 public static rd_kafka_conf ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null const rd_kafka_conf_t* rd_kafka_conf_set_oauthbearer_token_refresh_cb() \u00b6 public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $oauthbearer_token_refresh_cb ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* oauthbearer_token_refresh_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, void*) rd_kafka_conf_set_ssl_cert_verify_cb() \u00b6 public static rd_kafka_conf_set_ssl_cert_verify_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $ssl_cert_verify_cb ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* ssl_cert_verify_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns int rd_kafka_conf_res_t rd_kafka_conf_set_ssl_cert() \u00b6 public static rd_kafka_conf_set_ssl_cert ( \\FFI\\CData | null $conf , int $cert_type , int $cert_enc , \\FFI\\CData | object | string | null $buffer , int | null $size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* cert_type int rd_kafka_cert_type_t cert_enc int rd_kafka_cert_enc_t buffer \\FFI\\CData|object|string|null void* size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t rd_kafka_event_config_string() \u00b6 public static rd_kafka_event_config_string ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char* rd_kafka_oauthbearer_set_token() \u00b6 public static rd_kafka_oauthbearer_set_token ( \\FFI\\CData | null $rk , string | null $token_value , int | null $md_lifetime_ms , string | null $md_principal_name , \\FFI\\CData | null $extensions , int | null $extension_size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* token_value string|null const char* md_lifetime_ms int|null int64_t md_principal_name string|null const char* extensions \\FFI\\CData|null char** extension_size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t rd_kafka_oauthbearer_set_token_failure() \u00b6 public static rd_kafka_oauthbearer_set_token_failure ( \\FFI\\CData | null $rk , string | null $errstr ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_thread_start_t() \u00b6 public static rd_kafka_interceptor_f_on_thread_start_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_f_on_thread_exit_t() \u00b6 public static rd_kafka_interceptor_f_on_thread_exit_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_start() \u00b6 public static rd_kafka_interceptor_add_on_thread_start ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_start , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_start \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_thread_exit() \u00b6 public static rd_kafka_interceptor_add_on_thread_exit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_exit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_exit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_mock_cluster_new() \u00b6 public static rd_kafka_mock_cluster_new ( \\FFI\\CData | null $rk , int | null $broker_cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* broker_cnt int|null int Returns \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_mock_cluster_destroy() \u00b6 public static rd_kafka_mock_cluster_destroy ( \\FFI\\CData | null $mcluster ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_mock_cluster_handle() \u00b6 public static rd_kafka_mock_cluster_handle ( \\FFI\\CData | null $mcluster ) : \\FFI\\CData | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns \\FFI\\CData|null rd_kafka_t* rd_kafka_mock_cluster_bootstraps() \u00b6 public static rd_kafka_mock_cluster_bootstraps ( \\FFI\\CData | null $mcluster ) : string | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns string|null const char* rd_kafka_mock_push_request_errors() \u00b6 public static rd_kafka_mock_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , mixed $args ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t args mixed rd_kafka_mock_topic_set_error() \u00b6 public static rd_kafka_mock_topic_set_error ( \\FFI\\CData | null $mcluster , string | null $topic , int $err ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* err int rd_kafka_resp_err_t rd_kafka_mock_partition_set_leader() \u00b6 public static rd_kafka_mock_partition_set_leader ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower() \u00b6 public static rd_kafka_mock_partition_set_follower ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_partition_set_follower_wmarks() \u00b6 public static rd_kafka_mock_partition_set_follower_wmarks ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $lo , int | null $hi ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t lo int|null int64_t hi int|null int64_t Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_rack() \u00b6 public static rd_kafka_mock_broker_set_rack ( \\FFI\\CData | null $mcluster , int | null $broker_id , string | null $rack ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rack string|null const char* Returns int rd_kafka_resp_err_t rd_kafka_error_code() \u00b6 public static rd_kafka_error_code ( \\FFI\\CData | null $error ) : int Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int rd_kafka_resp_err_t rd_kafka_error_name() \u00b6 public static rd_kafka_error_name ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char* rd_kafka_error_string() \u00b6 public static rd_kafka_error_string ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char* rd_kafka_error_is_fatal() \u00b6 public static rd_kafka_error_is_fatal ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_error_is_retriable() \u00b6 public static rd_kafka_error_is_retriable ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_error_txn_requires_abort() \u00b6 public static rd_kafka_error_txn_requires_abort ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int rd_kafka_error_destroy() \u00b6 public static rd_kafka_error_destroy ( \\FFI\\CData | null $error ) : void Parameters error \\FFI\\CData|null rd_kafka_error_t* rd_kafka_error_new() \u00b6 public static rd_kafka_error_new ( int $code , string | null $fmt , mixed $args ) : \\FFI\\CData | null Parameters code int rd_kafka_resp_err_t fmt string|null const char* args mixed Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_msg_partitioner_fnv1a() \u00b6 public static rd_kafka_msg_partitioner_fnv1a ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_msg_partitioner_fnv1a_random() \u00b6 public static rd_kafka_msg_partitioner_fnv1a_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t rd_kafka_consumer_group_metadata() \u00b6 public static rd_kafka_consumer_group_metadata ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_new() \u00b6 public static rd_kafka_consumer_group_metadata_new ( string | null $group_id ) : \\FFI\\CData | null Parameters group_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_destroy() \u00b6 public static rd_kafka_consumer_group_metadata_destroy ( \\FFI\\CData | null $arg0 ) : void Parameters arg0 \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_consumer_group_metadata_write() \u00b6 public static rd_kafka_consumer_group_metadata_write ( \\FFI\\CData | null $cgmd , \\FFI\\CData | object | string | null $bufferp , \\FFI\\CData | null $sizep ) : \\FFI\\CData | null Parameters cgmd \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* bufferp \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_consumer_group_metadata_read() \u00b6 public static rd_kafka_consumer_group_metadata_read ( \\FFI\\CData | null $cgmdp , \\FFI\\CData | object | string | null $buffer , int | null $size ) : \\FFI\\CData | null Parameters cgmdp \\FFI\\CData|null rd_kafka_consumer_group_metadata_t** buffer \\FFI\\CData|object|string|null void* size int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_init_transactions() \u00b6 public static rd_kafka_init_transactions ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_begin_transaction() \u00b6 public static rd_kafka_begin_transaction ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_send_offsets_to_transaction() \u00b6 public static rd_kafka_send_offsets_to_transaction ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $cgmetadata , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* cgmetadata \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_commit_transaction() \u00b6 public static rd_kafka_commit_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_abort_transaction() \u00b6 public static rd_kafka_abort_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_handle_mock_cluster() \u00b6 public static rd_kafka_handle_mock_cluster ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_mock_cluster_t* rd_kafka_mock_topic_create() \u00b6 public static rd_kafka_mock_topic_create ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition_cnt , int | null $replication_factor ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition_cnt int|null int replication_factor int|null int Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_down() \u00b6 public static rd_kafka_mock_broker_set_down ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_up() \u00b6 public static rd_kafka_mock_broker_set_up ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_coordinator_set() \u00b6 public static rd_kafka_mock_coordinator_set ( \\FFI\\CData | null $mcluster , string | null $key_type , string | null $key , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* key_type string|null const char* key string|null const char* broker_id int|null int32_t Returns int rd_kafka_resp_err_t rd_kafka_mock_set_apiversion() \u00b6 public static rd_kafka_mock_set_apiversion ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $MinVersion , int | null $MaxVersion ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t MinVersion int|null int16_t MaxVersion int|null int16_t Returns int rd_kafka_resp_err_t rd_kafka_mock_broker_set_rtt() \u00b6 public static rd_kafka_mock_broker_set_rtt ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $rtt_ms ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rtt_ms int|null int Returns int rd_kafka_resp_err_t rd_kafka_message_errstr() \u00b6 public static rd_kafka_message_errstr ( \\FFI\\CData | null $rkmessage ) : string | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns string|null const char* rd_kafka_message_broker_id() \u00b6 public static rd_kafka_message_broker_id ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int32_t rd_kafka_produceva() \u00b6 public static rd_kafka_produceva ( \\FFI\\CData | null $rk , \\FFI\\CData | null $vus , int | null $cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* vus \\FFI\\CData|null rd_kafka_vu_t* cnt int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_event_debug_contexts() \u00b6 public static rd_kafka_event_debug_contexts ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $dst , int | null $dstsize ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* dst \\FFI\\CData|null char* dstsize int|null size_t Returns int|null int rd_kafka_mock_broker_push_request_errors() \u00b6 public static rd_kafka_mock_broker_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t rd_kafka_conf_get_default_topic_conf() \u00b6 public static rd_kafka_conf_get_default_topic_conf ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t* rd_kafka_queue_yield() \u00b6 public static rd_kafka_queue_yield ( \\FFI\\CData | null $rkqu ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_seek_partitions() \u00b6 public static rd_kafka_seek_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_incremental_assign() \u00b6 public static rd_kafka_incremental_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_incremental_unassign() \u00b6 public static rd_kafka_incremental_unassign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t* rd_kafka_rebalance_protocol() \u00b6 public static rd_kafka_rebalance_protocol ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char* rd_kafka_assignment_lost() \u00b6 public static rd_kafka_assignment_lost ( \\FFI\\CData | null $rk ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int|null int rd_kafka_consumer_group_metadata_new_with_genid() \u00b6 public static rd_kafka_consumer_group_metadata_new_with_genid ( string | null $group_id , int | null $generation_id , string | null $member_id , string | null $group_instance_id ) : \\FFI\\CData | null Parameters group_id string|null const char* generation_id int|null int32_t member_id string|null const char* group_instance_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* rd_kafka_event_DeleteRecords_result() \u00b6 public static rd_kafka_event_DeleteRecords_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* rd_kafka_event_DeleteGroups_result() \u00b6 public static rd_kafka_event_DeleteGroups_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* rd_kafka_event_DeleteConsumerGroupOffsets_result() \u00b6 public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* rd_kafka_group_result_error() \u00b6 public static rd_kafka_group_result_error ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_error_t* rd_kafka_group_result_name() \u00b6 public static rd_kafka_group_result_name ( \\FFI\\CData | null $groupres ) : string | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns string|null const char* rd_kafka_group_result_partitions() \u00b6 public static rd_kafka_group_result_partitions ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t* rd_kafka_DeleteRecords_new() \u00b6 public static rd_kafka_DeleteRecords_new ( \\FFI\\CData | null $before_offsets ) : \\FFI\\CData | null Parameters before_offsets \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteRecords_t* rd_kafka_DeleteRecords_destroy() \u00b6 public static rd_kafka_DeleteRecords_destroy ( \\FFI\\CData | null $del_records ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t* rd_kafka_DeleteRecords_destroy_array() \u00b6 public static rd_kafka_DeleteRecords_destroy_array ( \\FFI\\CData | null $del_records , int | null $del_record_cnt ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t rd_kafka_DeleteRecords() \u00b6 public static rd_kafka_DeleteRecords ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_records , int | null $del_record_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteRecords_result_offsets() \u00b6 public static rd_kafka_DeleteRecords_result_offsets ( \\FFI\\CData | null $result ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t* rd_kafka_DeleteGroup_new() \u00b6 public static rd_kafka_DeleteGroup_new ( string | null $group ) : \\FFI\\CData | null Parameters group string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteGroup_t* rd_kafka_DeleteGroup_destroy() \u00b6 public static rd_kafka_DeleteGroup_destroy ( \\FFI\\CData | null $del_group ) : void Parameters del_group \\FFI\\CData|null rd_kafka_DeleteGroup_t* rd_kafka_DeleteGroup_destroy_array() \u00b6 public static rd_kafka_DeleteGroup_destroy_array ( \\FFI\\CData | null $del_groups , int | null $del_group_cnt ) : void Parameters del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t rd_kafka_DeleteGroups() \u00b6 public static rd_kafka_DeleteGroups ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_groups , int | null $del_group_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteGroups_result_groups() \u00b6 public static rd_kafka_DeleteGroups_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t** rd_kafka_DeleteConsumerGroupOffsets_new() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_new ( string | null $group , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters group string|null const char* partitions \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t* rd_kafka_DeleteConsumerGroupOffsets_destroy() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \\FFI\\CData | null $del_grpoffsets ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t* rd_kafka_DeleteConsumerGroupOffsets_destroy_array() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffset_cnt ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt int|null size_t rd_kafka_DeleteConsumerGroupOffsets() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffsets_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffsets_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* rd_kafka_DeleteConsumerGroupOffsets_result_groups() \u00b6 public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t** rd_kafka_mock_clear_request_errors() \u00b6 public static rd_kafka_mock_clear_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t rd_kafka_mock_push_request_errors_array() \u00b6 public static rd_kafka_mock_push_request_errors_array ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , \\FFI\\CData | null $errors ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t errors \\FFI\\CData|null rd_kafka_resp_err_t* rd_kafka_interceptor_f_on_response_received_t() \u00b6 public static rd_kafka_interceptor_f_on_response_received_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , int | null $rtt , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t rtt int|null int64_t err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_interceptor_add_on_response_received() \u00b6 public static rd_kafka_interceptor_add_on_response_received ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_response_received , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_response_received \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t rd_kafka_conf_set_engine_callback_data() \u00b6 public static rd_kafka_conf_set_engine_callback_data ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $callback_data ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* callback_data \\FFI\\CData|object|string|null void* rd_kafka_mem_calloc() \u00b6 public static rd_kafka_mem_calloc ( \\FFI\\CData | null $rk , int | null $num , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* num int|null size_t size int|null size_t Returns \\FFI\\CData|object|string|null void* rd_kafka_mem_malloc() \u00b6 public static rd_kafka_mem_malloc ( \\FFI\\CData | null $rk , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* size int|null size_t Returns \\FFI\\CData|object|string|null void* rd_kafka_mock_broker_push_request_error_rtts() \u00b6 public static rd_kafka_mock_broker_push_request_error_rtts ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t Used by \u00b6 \\RdKafka\\FFI\\Library","title":"Methods"},{"location":"api/RdKafka/FFI/Methods/#trait-methods","text":"Trait \\RdKafka\\FFI\\Methods Description of librdkafka methods and constants is extracted from the official documentation. See also https://docs.confluent.io/current/clients/librdkafka/rdkafka_8h.html","title":"Trait Methods"},{"location":"api/RdKafka/FFI/Methods/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/Methods/#getffi","text":"public static getFFI ( ) : \\FFI Returns \\FFI","title":"getFFI()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_version","text":"public static rd_kafka_version ( ) : int | null Returns the librdkafka version as integer. See also See RD_KAFKA_VERSION for how to parse the integer format. Use rd_kafka_version_str() to retreive the version as a string. Returns int|null int - ) - Version integer. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e","title":"rd_kafka_version()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_version_str","text":"public static rd_kafka_version_str ( ) : string | null Returns the librdkafka version as string. Returns string|null const char* - ) - Version string See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a","title":"rd_kafka_version_str()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_debug_contexts","text":"public static rd_kafka_get_debug_contexts ( ) : string | null Retrieve supported debug contexts for use with the \"debug\" configuration property. (runtime) Returns string|null const char* - ) - Comma-separated list of available debugging contexts. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45","title":"rd_kafka_get_debug_contexts()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_err_descs","text":"public static rd_kafka_get_err_descs ( \\FFI\\CData | null $errdescs , \\FFI\\CData | null $cntp ) : void Parameters errdescs \\FFI\\CData|null struct rd_kafka_err_desc** cntp \\FFI\\CData|null size_t*","title":"rd_kafka_get_err_descs()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_err2str","text":"public static rd_kafka_err2str ( int $err ) : string | null Returns a human readable representation of a kafka error. Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d","title":"rd_kafka_err2str()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_err2name","text":"public static rd_kafka_err2name ( int $err ) : string | null Returns the error code name (enum name). Parameters err int rd_kafka_resp_err_t - ) - Error code to translate Returns string|null const char* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77","title":"rd_kafka_err2name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_last_error","text":"public static rd_kafka_last_error ( ) : int Returns the last error code generated by a legacy API call in the current thread. The legacy APIs are the ones using errno to propagate error value, namely: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() The main use for this function is to avoid converting system errno values to rd_kafka_resp_err_t codes for legacy APIs. Remarks The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure rd_kafka_last_error() is called immediately after a failed API call. Returns int rd_kafka_resp_err_t - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7","title":"rd_kafka_last_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_errno2err","text":"public static rd_kafka_errno2err ( int | null $errnox ) : int Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the following functions: rd_kafka_topic_new() rd_kafka_consume_start() rd_kafka_consume_stop() rd_kafka_consume() rd_kafka_consume_batch() rd_kafka_consume_callback() rd_kafka_consume_queue() rd_kafka_produce() Remarks A better alternative is to call rd_kafka_last_error() immediately after any of the above functions return -1 or NULL. See also rd_kafka_last_error() Parameters errnox int|null int - ) - System errno value to convert Returns int rd_kafka_resp_err_t - Appropriate error code for errnox See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99c7d1faaa534befeedf23b55a88a40f","title":"rd_kafka_errno2err()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_errno","text":"public static rd_kafka_errno ( ) : int | null Returns the thread-local system errno. On most platforms this is the same as errno but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for expsing the errno librdkafka uses. Remarks The value is local to the current calling thread. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aef27224d8c638e51f3ee29bb25f65f1f","title":"rd_kafka_errno()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_fatal_error","text":"public static rd_kafka_fatal_error ( \\FFI\\CData | null $rk , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_fatal_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_test_fatal_error","text":"public static rd_kafka_test_fatal_error ( \\FFI\\CData | null $rk , int $err , string | null $reason ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* err int rd_kafka_resp_err_t reason string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_test_fatal_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_destroy","text":"public static rd_kafka_topic_partition_destroy ( \\FFI\\CData | null $rktpar ) : void Destroy a rd_kafka_topic_partition_t. Remarks This must not be called for elements in a topic partition list. Parameters rktpar \\FFI\\CData|null rd_kafka_topic_partition_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a","title":"rd_kafka_topic_partition_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_new","text":"public static rd_kafka_topic_partition_list_new ( int | null $size ) : \\FFI\\CData | null Create a new list/vector Topic+Partition container. Remarks Use rd_kafka_topic_partition_list_destroy() to free all resources in use by a list and the list itself. See also rd_kafka_topic_partition_list_add() Parameters size int|null int - ) - Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A newly allocated Topic+Partition list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a","title":"rd_kafka_topic_partition_list_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_destroy","text":"public static rd_kafka_topic_partition_list_destroy ( \\FFI\\CData | null $rkparlist ) : void Parameters rkparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t*","title":"rd_kafka_topic_partition_list_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_add","text":"public static rd_kafka_topic_partition_list_add ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Add topic+partition to list. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) partition int|null int32_t - Partition id Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - The object which can be used to fill in additionals fields. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d","title":"rd_kafka_topic_partition_list_add()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_add_range","text":"public static rd_kafka_topic_partition_list_add_range ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $start , int | null $stop ) : void Add range of partitions from start to stop inclusive. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to extend topic string|null const char* - Topic name (copied) start int|null int32_t - Start partition of range stop int|null int32_t - Last partition of range (inclusive) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b","title":"rd_kafka_topic_partition_list_add_range()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_del","text":"public static rd_kafka_topic_partition_list_del ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : int | null Delete partition from list. Remarks Any held indices to elems[] are unusable after this call returns 1. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* - List to modify topic string|null const char* - Topic name to match partition int|null int32_t - Partition to match Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97","title":"rd_kafka_topic_partition_list_del()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_del_by_idx","text":"public static rd_kafka_topic_partition_list_del_by_idx ( \\FFI\\CData | null $rktparlist , int | null $idx ) : int | null Delete partition from list by elems[] index. See also rd_kafka_topic_partition_list_del() Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* idx int|null int Returns int|null int - 1 if partition was found (and removed), else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463","title":"rd_kafka_topic_partition_list_del_by_idx()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_copy","text":"public static rd_kafka_topic_partition_list_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Make a copy of an existing list. Parameters src \\FFI\\CData|null rd_kafka_topic_partition_list_t* - ) - The existing list to copy. Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - A new list fully populated to be identical to src See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7","title":"rd_kafka_topic_partition_list_copy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_set_offset","text":"public static rd_kafka_topic_partition_list_set_offset ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition , int | null $offset ) : int Set offset to offset for topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if partition was not found in the list. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d","title":"rd_kafka_topic_partition_list_set_offset()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_find","text":"public static rd_kafka_topic_partition_list_find ( \\FFI\\CData | null $rktparlist , string | null $topic , int | null $partition ) : \\FFI\\CData | null Find element by topic and partition . Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a pointer to the first matching element, or NULL if not found. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa","title":"rd_kafka_topic_partition_list_find()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_list_sort","text":"public static rd_kafka_topic_partition_list_sort ( \\FFI\\CData | null $rktparlist , \\FFI\\CData | \\Closure $cmp , \\FFI\\CData | object | string | null $opaque ) : void Sort list using comparator cmp . If cmp is NULL the default comparator will be used that sorts by ascending topic name and partition. Parameters rktparlist \\FFI\\CData|null rd_kafka_topic_partition_list_t* cmp \\FFI\\CData|\\Closure int( )(void , void*, void*) opaque \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f","title":"rd_kafka_topic_partition_list_sort()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_new","text":"public static rd_kafka_headers_new ( int | null $initial_count ) : \\FFI\\CData | null Parameters initial_count int|null size_t Returns \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_destroy","text":"public static rd_kafka_headers_destroy ( \\FFI\\CData | null $hdrs ) : void Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_headers_copy","text":"public static rd_kafka_headers_copy ( \\FFI\\CData | null $src ) : \\FFI\\CData | null Parameters src \\FFI\\CData|null rd_kafka_headers_t* Returns \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_headers_copy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_add","text":"public static rd_kafka_header_add ( \\FFI\\CData | null $hdrs , string | null $name , int | null $name_size , \\FFI\\CData | object | string | null $value , int | null $value_size ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* name_size int|null ssize_t value \\FFI\\CData|object|string|null void* value_size int|null ssize_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_add()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_remove","text":"public static rd_kafka_header_remove ( \\FFI\\CData | null $hdrs , string | null $name ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_remove()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get_last","text":"public static rd_kafka_header_get_last ( \\FFI\\CData | null $hdrs , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get_last()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get","text":"public static rd_kafka_header_get ( \\FFI\\CData | null $hdrs , int | null $idx , string | null $name , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t name string|null const char* valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_get_all","text":"public static rd_kafka_header_get_all ( \\FFI\\CData | null $hdrs , int | null $idx , \\FFI\\CData | null $namep , \\FFI\\CData | object | string | null $valuep , \\FFI\\CData | null $sizep ) : int Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* idx int|null size_t namep \\FFI\\CData|null char** valuep \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_header_get_all()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_destroy","text":"public static rd_kafka_message_destroy ( \\FFI\\CData | null $rkmessage ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t*","title":"rd_kafka_message_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_timestamp","text":"public static rd_kafka_message_timestamp ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $tstype ) : int | null Returns the message timestamp for a consumed message. The timestamp is the number of milliseconds since the epoch (UTC). tstype (if not NULL) is updated to indicate the type of timestamp. Remarks Message timestamps require broker version 0.10.0 or later. Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* tstype \\FFI\\CData|null rd_kafka_timestamp_type_t* Returns int|null int64_t - message timestamp, or -1 if not available. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7","title":"rd_kafka_message_timestamp()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_latency","text":"public static rd_kafka_message_latency ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int64_t","title":"rd_kafka_message_latency()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_headers","text":"public static rd_kafka_message_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t","title":"rd_kafka_message_headers()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_detach_headers","text":"public static rd_kafka_message_detach_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrsp ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrsp \\FFI\\CData|null rd_kafka_headers_t** Returns int rd_kafka_resp_err_t","title":"rd_kafka_message_detach_headers()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_set_headers","text":"public static rd_kafka_message_set_headers ( \\FFI\\CData | null $rkmessage , \\FFI\\CData | null $hdrs ) : void Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* hdrs \\FFI\\CData|null rd_kafka_headers_t*","title":"rd_kafka_message_set_headers()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_header_cnt","text":"public static rd_kafka_header_cnt ( \\FFI\\CData | null $hdrs ) : int | null Parameters hdrs \\FFI\\CData|null rd_kafka_headers_t* Returns int|null size_t","title":"rd_kafka_header_cnt()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_status","text":"public static rd_kafka_message_status ( \\FFI\\CData | null $rkmessage ) : int Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int rd_kafka_msg_status_t","title":"rd_kafka_message_status()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_new","text":"public static rd_kafka_conf_new ( ) : \\FFI\\CData | null Create configuration object. When providing your own configuration to the rd_kafka_*_new_* () calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: 1 rd_kafka_conf_t *myconf; 2 rd_kafka_conf_res_t res; 3 4 myconf = rd_kafka_conf_new(); 5 res = rd_kafka_conf_set(myconf, \"socket.timeout.ms\", \"600\", 6 errstr, sizeof(errstr)); 7 if (res != RD_KAFKA_CONF_OK) 8 die(\"%s\\n\", errstr); 9 10 rk = rd_kafka_new(..., myconf); Please see CONFIGURATION.md for the default settings or use rd_kafka_conf_properties_show() to provide the information at runtime. The properties are identical to the Apache Kafka configuration properties whenever possible. See also rd_kafka_conf_set(), rd_kafka_conf_destroy() Returns \\FFI\\CData|null rd_kafka_conf_t* - ) - A new rd_kafka_conf_t object with defaults set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c","title":"rd_kafka_conf_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_destroy","text":"public static rd_kafka_conf_destroy ( \\FFI\\CData | null $conf ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dup","text":"public static rd_kafka_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_dup()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dup_filter","text":"public static rd_kafka_conf_dup_filter ( \\FFI\\CData | null $conf , int | null $filter_cnt , \\FFI\\CData | null $filter ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** Returns \\FFI\\CData|null rd_kafka_conf_t*","title":"rd_kafka_conf_dup_filter()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set","text":"public static rd_kafka_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a configuration property. conf must have been previously created with rd_kafka_conf_new(). Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the default_topic_conf . If no default_topic_conf has been set one will be created. Any sub-sequent rd_kafka_conf_set_default_topic_conf() calls will replace the current default topic configuration. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. In case of failure errstr is updated to contain a human readable error string. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8","title":"rd_kafka_conf_set()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_events","text":"public static rd_kafka_conf_set_events ( \\FFI\\CData | null $conf , int | null $events ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* events int|null int","title":"rd_kafka_conf_set_events()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_background_event_cb","text":"public static rd_kafka_conf_set_background_event_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $event_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_event_t*, void*)","title":"rd_kafka_conf_set_background_event_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_dr_cb","text":"public static rd_kafka_conf_set_dr_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_cb ) : void Deprecated: See rd_kafka_conf_set_dr_msg_cb() Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*, size_t, rd_kafka_resp_err_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a075b15c4141784fdc271de217005a41f","title":"rd_kafka_conf_set_dr_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_dr_msg_cb","text":"public static rd_kafka_conf_set_dr_msg_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $dr_msg_cb ) : void Producer: Set delivery report callback in provided conf object. The delivery report callback will be called once for each message accepted by rd_kafka_produce() (et.al) with err set to indicate the result of the produce request. The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted. An application must call rd_kafka_poll() at regular intervals to serve queued delivery report callbacks. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* dr_msg_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_message_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a","title":"rd_kafka_conf_set_dr_msg_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_consume_cb","text":"public static rd_kafka_conf_set_consume_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $consume_cb ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*)","title":"rd_kafka_conf_set_consume_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_rebalance_cb","text":"public static rd_kafka_conf_set_rebalance_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $rebalance_cb ) : void Consumer: Set rebalance callback for use with coordinated consumer group balancing. The err field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked. Registering a rebalance_cb turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's rebalance_cb . The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where err is neither of those. Remarks In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state. Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke). Remarks The partitions list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application. The following example shows the application's responsibilities: 1 static void rebalance_cb (rd_kafka_t *rk, rd_kafka_resp_err_t err, 2 rd_kafka_topic_partition_list_t *partitions, 3 void *opaque) { 4 5 switch (err) 6 { 7 case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS: 8 // application may load offets from arbitrary external 9 // storage here and update \\p partitions 10 11 rd_kafka_assign(rk, partitions); 12 break; 13 14 case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS: 15 if (manual_commits) // Optional explicit manual commit 16 rd_kafka_commit(rk, partitions, 0); // sync commit 17 18 rd_kafka_assign(rk, NULL); 19 break; 20 21 default: 22 handle_unlikely_error(err); 23 rd_kafka_assign(rk, NULL); // sync state 24 break; 25 } 26 } Parameters conf \\FFI\\CData|null rd_kafka_conf_t* rebalance_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311","title":"rd_kafka_conf_set_rebalance_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_offset_commit_cb","text":"public static rd_kafka_conf_set_offset_commit_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $offset_commit_cb ) : void Consumer: Set offset commit callback for use with consumer groups. The results of automatic or manual offset commits will be scheduled for this callback and is served by rd_kafka_consumer_poll(). If no partitions had valid offsets to commit this callback will be called with err == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error. The offsets list contains per-partition information: offset: committed offset (attempted) err: commit error Parameters conf \\FFI\\CData|null rd_kafka_conf_t* offset_commit_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb","title":"rd_kafka_conf_set_offset_commit_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_error_cb","text":"public static rd_kafka_conf_set_error_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $error_cb ) : void Set error callback in provided conf object. The error callback is used by librdkafka to signal critical errors back to the application. If no error_cb is registered then the errors will be logged instead. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* error_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90","title":"rd_kafka_conf_set_error_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_throttle_cb","text":"public static rd_kafka_conf_set_throttle_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $throttle_cb ) : void Set throttle callback. The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests. Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero. An application must call rd_kafka_poll() or rd_kafka_consumer_poll() at regular intervals to serve queued callbacks. Remarks Requires broker version 0.9.0 or later. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* throttle_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, int32_t, int, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a04160826ad039d42c10edec456163fa7","title":"rd_kafka_conf_set_throttle_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_log_cb","text":"public static rd_kafka_conf_set_log_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $log_cb ) : void Set logger callback. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass func as NULL to disable logging. This is the configuration alternative to the deprecated rd_kafka_set_logger() Remarks The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through rd_kafka_set_log_queue() . An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded log_cb . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* log_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f","title":"rd_kafka_conf_set_log_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_stats_cb","text":"public static rd_kafka_conf_set_stats_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $stats_cb ) : void Set statistics callback in provided conf object. The statistics callback is triggered from rd_kafka_poll() every statistics.interval.ms (needs to be configured separately). Function arguments: rk - Kafka handle json - String containing the statistics data in JSON format json_len - Length of json string. opaque - Application-provided opaque. If the application wishes to hold on to the json pointer and free it at a later time it must return 1 from the stats_cb . If the application returns 0 from the stats_cb then librdkafka will immediately free the json pointer. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* stats_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , char*, size_t, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766","title":"rd_kafka_conf_set_stats_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_socket_cb","text":"public static rd_kafka_conf_set_socket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $socket_cb ) : void Set socket callback. The socket callback is responsible for opening a socket according to the supplied domain , type and protocol . The socket shall be created with CLOEXEC set in a racefree fashion, if possible. Default: on linux: racefree CLOEXEC others : non-racefree CLOEXEC Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* socket_cb \\FFI\\CData|\\Closure int( )(int, int, int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf","title":"rd_kafka_conf_set_socket_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_connect_cb","text":"public static rd_kafka_conf_set_connect_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $connect_cb ) : void Set connect callback. The connect callback is responsible for connecting socket sockfd to peer address addr . The id field contains the broker identifier. connect_cb shall return 0 on success (socket connected) or an error number (errno) on error. Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* connect_cb \\FFI\\CData|\\Closure int( )(int, struct sockaddr , int, const char*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040","title":"rd_kafka_conf_set_connect_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_closesocket_cb","text":"public static rd_kafka_conf_set_closesocket_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $closesocket_cb ) : void Set close socket callback. Close a socket (optionally opened with socket_cb()). Remarks The callback will be called from an internal librdkafka thread. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* closesocket_cb \\FFI\\CData|\\Closure int( )(int, void ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7","title":"rd_kafka_conf_set_closesocket_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_opaque","text":"public static rd_kafka_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_conf_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_conf_set_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_opaque","text":"public static rd_kafka_opaque ( \\FFI\\CData | null $rk ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_default_topic_conf","text":"public static rd_kafka_conf_set_default_topic_conf ( \\FFI\\CData | null $conf , \\FFI\\CData | null $tconf ) : void Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* tconf \\FFI\\CData|null rd_kafka_topic_conf_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63","title":"rd_kafka_conf_set_default_topic_conf()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_get","text":"public static rd_kafka_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve configuration value for property name . If dest is non-NULL the value will be written to dest with at most dest_size . *dest_size is updated to the full length of the value, thus if *dest_size initially is smaller than the full length the application may reallocate dest to fit the returned *dest_size and try again. If dest is NULL only the full length of the value is returned. Fallthrough: Topic-level configuration properties from the default_topic_conf may be retrieved using this interface. Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t - RD_KAFKA_CONF_OK if the property name matched, else RD_KAFKA_CONF_UNKNOWN . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97","title":"rd_kafka_conf_get()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_get","text":"public static rd_kafka_topic_conf_get ( \\FFI\\CData | null $conf , string | null $name , \\FFI\\CData | null $dest , \\FFI\\CData | null $dest_size ) : int Retrieve topic configuration value for property name . See also rd_kafka_conf_get() Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* dest \\FFI\\CData|null char* dest_size \\FFI\\CData|null size_t* Returns int rd_kafka_conf_res_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d","title":"rd_kafka_topic_conf_get()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dump","text":"public static rd_kafka_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c","title":"rd_kafka_conf_dump()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_dump","text":"public static rd_kafka_topic_conf_dump ( \\FFI\\CData | null $conf , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Dump the topic configuration properties and values of conf to an array with \"key\", \"value\" pairs. The number of entries in the array is returned in *cntp . The dump must be freed with rd_kafka_conf_dump_free() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const char** See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696","title":"rd_kafka_topic_conf_dump()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_dump_free","text":"public static rd_kafka_conf_dump_free ( \\FFI\\CData | null $arr , int | null $cnt ) : void Parameters arr \\FFI\\CData|null char** cnt int|null size_t","title":"rd_kafka_conf_dump_free()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_properties_show","text":"public static rd_kafka_conf_properties_show ( \\FFI\\CData | null $fp ) : void Parameters fp \\FFI\\CData|null FILE*","title":"rd_kafka_conf_properties_show()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_new","text":"public static rd_kafka_topic_conf_new ( ) : \\FFI\\CData | null Create topic configuration object. See also Same semantics as for rd_kafka_conf_new(). Returns \\FFI\\CData|null rd_kafka_topic_conf_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e","title":"rd_kafka_topic_conf_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_dup","text":"public static rd_kafka_topic_conf_dup ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_topic_conf_dup()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_default_topic_conf_dup","text":"public static rd_kafka_default_topic_conf_dup ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_default_topic_conf_dup()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_destroy","text":"public static rd_kafka_topic_conf_destroy ( \\FFI\\CData | null $topic_conf ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_topic_conf_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set","text":"public static rd_kafka_topic_conf_set ( \\FFI\\CData | null $conf , string | null $name , string | null $value , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Sets a single rd_kafka_topic_conf_t value by property name. topic_conf should have been previously set up with rd_kafka_topic_conf_new() . Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* name string|null const char* value string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t - rd_kafka_conf_res_t to indicate success or failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01","title":"rd_kafka_topic_conf_set()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_opaque","text":"public static rd_kafka_topic_conf_set_opaque ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $opaque ) : void Parameters conf \\FFI\\CData|null rd_kafka_topic_conf_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_topic_conf_set_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_partitioner_cb","text":"public static rd_kafka_topic_conf_set_partitioner_cb ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $partitioner ) : void Producer: Set partitioner callback in provided topic conf object. The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key. Partitioner function constraints: MUST NOT call any rd_kafka_*() functions except: rd_kafka_topic_partition_available() MUST NOT block or execute for prolonged periods of time. MUST return a value between 0 and partition_cnt-1, or the special RD_KAFKA_PARTITION_UA value if partitioning could not be performed. Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* partitioner \\FFI\\CData|\\Closure int32_t( )(rd_kafka_topic_t , void*, size_t, int32_t, void*, void*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf","title":"rd_kafka_topic_conf_set_partitioner_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_conf_set_msg_order_cmp","text":"public static rd_kafka_topic_conf_set_msg_order_cmp ( \\FFI\\CData | null $topic_conf , \\FFI\\CData | \\Closure $msg_order_cmp ) : void Parameters topic_conf \\FFI\\CData|null rd_kafka_topic_conf_t* msg_order_cmp \\FFI\\CData|\\Closure int( )(rd_kafka_message_t , rd_kafka_message_t*)","title":"rd_kafka_topic_conf_set_msg_order_cmp()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_partition_available","text":"public static rd_kafka_topic_partition_available ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Check if partition is available (has a leader broker). Warning This function must only be called from inside a partitioner function Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 1 if the partition is available, else 0. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758","title":"rd_kafka_topic_partition_available()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_random","text":"public static rd_kafka_msg_partitioner_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Random partitioner. Will try not to return unavailable partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a random partition between 0 and partition_cnt - 1. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8","title":"rd_kafka_msg_partitioner_random()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_consistent","text":"public static rd_kafka_msg_partitioner_consistent ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent partitioner. Uses consistent hashing to map identical keys onto identical partitions. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef","title":"rd_kafka_msg_partitioner_consistent()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_consistent_random","text":"public static rd_kafka_msg_partitioner_consistent_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Consistent-Random partitioner. This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t - a \u201crandom\u201d partition between 0 and partition_cnt - 1 based on the CRC value of the key (if provided) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb","title":"rd_kafka_msg_partitioner_consistent_random()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_murmur2","text":"public static rd_kafka_msg_partitioner_murmur2 ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_murmur2()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_murmur2_random","text":"public static rd_kafka_msg_partitioner_murmur2_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_murmur2_random()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_new","text":"public static rd_kafka_new ( int $type , \\FFI\\CData | null $conf , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Creates a new Kafka handle and starts its operation according to the specified type ( RD_KAFKA_CONSUMER or RD_KAFKA_PRODUCER ). conf is an optional struct created with rd_kafka_conf_new() that will be used instead of the default configuration. The conf object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See rd_kafka_conf_set() et.al for more information. errstr must be a pointer to memory of at least size errstr_size where rd_kafka_new() may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL. Remarks RD_KAFKA_CONSUMER: When a new RD_KAFKA_CONSUMER rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the rd_kafka_consume_start() interface, or the High-level KafkaConsumer API. An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle. See also To destroy the Kafka handle, use rd_kafka_destroy(). Parameters type int rd_kafka_type_t conf \\FFI\\CData|null rd_kafka_conf_t* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_t* - The Kafka handle on success or NULL on error (see errstr ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24","title":"rd_kafka_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_destroy","text":"public static rd_kafka_destroy ( \\FFI\\CData | null $rk ) : void Destroy Kafka handle. Remarks This is a blocking operation. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794","title":"rd_kafka_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_destroy_flags","text":"public static rd_kafka_destroy_flags ( \\FFI\\CData | null $rk , int | null $flags ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* flags int|null int","title":"rd_kafka_destroy_flags()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_name","text":"public static rd_kafka_name ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char*","title":"rd_kafka_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_type","text":"public static rd_kafka_type ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_type_t","title":"rd_kafka_type()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_memberid","text":"public static rd_kafka_memberid ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Returns this client's broker-assigned group member id. Remarks This currently requires the high-level KafkaConsumer Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null char* - An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with free() or rd_kafka_mem_free() See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6","title":"rd_kafka_memberid()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_clusterid","text":"public static rd_kafka_clusterid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null char*","title":"rd_kafka_clusterid()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_controllerid","text":"public static rd_kafka_controllerid ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int32_t","title":"rd_kafka_controllerid()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_new","text":"public static rd_kafka_topic_new ( \\FFI\\CData | null $rk , string | null $topic , \\FFI\\CData | null $conf ) : \\FFI\\CData | null Creates a new topic handle for topic named topic . conf is an optional configuration for the topic created with rd_kafka_topic_conf_new() that will be used instead of the default topic configuration. The conf object is freed by this function and must not be used or destroyed by the application sub-sequently. See rd_kafka_topic_conf_set() et.al for more information. Topic handles are refcounted internally and calling rd_kafka_topic_new() again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call rd_kafka_topic_destroy() for each succesfull call to rd_kafka_topic_new() to clear up resources. See also rd_kafka_topic_destroy() Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* conf \\FFI\\CData|null rd_kafka_topic_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_t* - the new topic handle or NULL on error (use rd_kafka_errno2err() to convert system errno to an rd_kafka_resp_err_t error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8","title":"rd_kafka_topic_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_destroy","text":"public static rd_kafka_topic_destroy ( \\FFI\\CData | null $rkt ) : void Loose application's topic handle refcount as previously created with rd_kafka_topic_new() . Remarks Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff","title":"rd_kafka_topic_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_name","text":"public static rd_kafka_topic_name ( \\FFI\\CData | null $rkt ) : string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns string|null const char*","title":"rd_kafka_topic_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_opaque","text":"public static rd_kafka_topic_opaque ( \\FFI\\CData | null $rkt ) : \\FFI\\CData | object | string | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_topic_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_poll","text":"public static rd_kafka_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int | null Polls the provided kafka handle for events. Events will cause application provided callbacks to be called. The timeout_ms argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as timeout_ms . To wait indefinately for an event, provide -1. Remarks An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called. Events: delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer] error callbacks (rd_kafka_conf_set_error_cb()) [all] stats callbacks (rd_kafka_conf_set_stats_cb()) [all] throttle callbacks (rd_kafka_conf_set_throttle_cb()) [all] Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4","title":"rd_kafka_poll()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_yield","text":"public static rd_kafka_yield ( \\FFI\\CData | null $rk ) : void Cancels the current callback dispatcher (rd_kafka_poll(), rd_kafka_consume_callback(), etc). A callback may use this to force an immediate return to the calling code (caller of e.g. rd_kafka_poll()) without processing any further events. Remarks This function MUST ONLY be called from within a librdkafka callback. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d","title":"rd_kafka_yield()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_pause_partitions","text":"public static rd_kafka_pause_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Pause producing or consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce","title":"rd_kafka_pause_partitions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_resume_partitions","text":"public static rd_kafka_resume_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Resume producing consumption for the provided list of partitions. Success or error is returned per-partition err in the partitions list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2","title":"rd_kafka_resume_partitions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_query_watermark_offsets","text":"public static rd_kafka_query_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high , int | null $timeout_ms ) : int Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. Offsets are returned in *low and *high respectively. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a4550ff7d014f08406666124573f70495","title":"rd_kafka_query_watermark_offsets()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_get_watermark_offsets","text":"public static rd_kafka_get_watermark_offsets ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition , \\FFI\\CData | null $low , \\FFI\\CData | null $high ) : int Get last known low (oldest/beginning) and high (newest/end) offsets for partition. The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker. If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset. Offsets are returned in *low and *high respectively. Remarks Shall only be used with an active consumer instance. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t low \\FFI\\CData|null int64_t* high \\FFI\\CData|null int64_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82","title":"rd_kafka_get_watermark_offsets()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offsets_for_times","text":"public static rd_kafka_offsets_for_times ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $timeout_ms ) : int Look up the offsets for the given partitions by timestamp. The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition. The timestamps to query are represented as offset in offsets on input, and offset will contain the offset on output. The function will block for at most timeout_ms milliseconds. Remarks Duplicate Topic+Partitions are not supported. Per-partition errors may be returned in rd_kafka_topic_partition_t.err Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - an error code for general errors, else RD_KAFKA_RESP_ERR_NO_ERROR in which case per-partition errors might be set. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929","title":"rd_kafka_offsets_for_times()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_free","text":"public static rd_kafka_mem_free ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ptr ) : void Free pointer returned by librdkafka. This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka. In standard setups it is usually not necessary to use this interface rather than the free(3) functione. Remarks rd_kafka_mem_free() must only be used for pointers returned by APIs that explicitly mention using this function for freeing. Parameters rk \\FFI\\CData|null rd_kafka_t* ptr \\FFI\\CData|object|string|null void* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572","title":"rd_kafka_mem_free()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_new","text":"public static rd_kafka_queue_new ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Create a new message queue. See rd_kafka_consume_start_queue(), rd_kafka_consume_queue(), et.al. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44","title":"rd_kafka_queue_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_destroy","text":"public static rd_kafka_queue_destroy ( \\FFI\\CData | null $rkqu ) : void Destroy a queue, purging all of its enqueued messages. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e","title":"rd_kafka_queue_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_main","text":"public static rd_kafka_queue_get_main ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the main librdkafka event queue. This is the queue served by rd_kafka_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863","title":"rd_kafka_queue_get_main()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_consumer","text":"public static rd_kafka_queue_get_consumer ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue prior to calling rd_kafka_consumer_close(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the librdkafka consumer queue. This is the queue served by rd_kafka_consumer_poll(). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078","title":"rd_kafka_queue_get_consumer()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_partition","text":"public static rd_kafka_queue_get_partition ( \\FFI\\CData | null $rk , string | null $topic , int | null $partition ) : \\FFI\\CData | null Use rd_kafka_queue_destroy() to loose the reference. Remarks rd_kafka_queue_destroy() MUST be called on this queue This function only works on consumers. Parameters rk \\FFI\\CData|null rd_kafka_t* topic string|null const char* partition int|null int32_t Returns \\FFI\\CData|null rd_kafka_queue_t* - a reference to the partition\u2019s queue, or NULL if partition is invalid. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d","title":"rd_kafka_queue_get_partition()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_get_background","text":"public static rd_kafka_queue_get_background ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_queue_get_background()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_forward","text":"public static rd_kafka_queue_forward ( \\FFI\\CData | null $src , \\FFI\\CData | null $dst ) : void Forward/re-route queue src to dst . If dst is NULL the forwarding is removed. The internal refcounts for both queues are increased. Remarks Regardless of whether dst is NULL or not, after calling this function, src will not forward it's fetch queue to the consumer queue. Parameters src \\FFI\\CData|null rd_kafka_queue_t* dst \\FFI\\CData|null rd_kafka_queue_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338","title":"rd_kafka_queue_forward()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_log_queue","text":"public static rd_kafka_set_log_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkqu ) : int Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. This allows an application to serve log callbacks ( log_cb ) in its thread of choice. Remarks The configuration property log.queue MUST also be set to true. librdkafka maintains its own reference to the provided queue. Parameters rk \\FFI\\CData|null rd_kafka_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* - Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue. Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d","title":"rd_kafka_set_log_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_length","text":"public static rd_kafka_queue_length ( \\FFI\\CData | null $rkqu ) : int | null Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* - ) Returns int|null size_t - the current number of elements in queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57","title":"rd_kafka_queue_length()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_io_event_enable","text":"public static rd_kafka_queue_io_event_enable ( \\FFI\\CData | null $rkqu , int | null $fd , \\FFI\\CData | object | string | null $payload , int | null $size ) : void Enable IO event triggering for queue. To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write payload (of size size ) to whenever a new element is enqueued on a previously empty queue. To remove event triggering call with fd = -1. librdkafka will maintain a copy of the payload . Remarks When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* fd int|null int payload \\FFI\\CData|object|string|null void* size int|null size_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784","title":"rd_kafka_queue_io_event_enable()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_cb_event_enable","text":"public static rd_kafka_queue_cb_event_enable ( \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $event_cb , \\FFI\\CData | object | string | null $opaque ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* event_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , void*) opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_queue_cb_event_enable()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_start","text":"public static rd_kafka_consume_start ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int | null Start consuming messages for topic rkt and partition at offset offset which may either be an absolute (0..N) or one of the logical offsets: RD_KAFKA_OFFSET_BEGINNING RD_KAFKA_OFFSET_END RD_KAFKA_OFFSET_STORED RD_KAFKA_OFFSET_TAIL rdkafka will attempt to keep queued.min.messages (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached. The application shall use one of the rd_kafka_consume*() functions to consume messages from the local queue, each kafka message being represented as a rd_kafka_message_t * object. rd_kafka_consume_start() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . Use rd_kafka_errno2err() to convert sytem errno to rd_kafka_resp_err_t Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int|null int - 0 on success or -1 on error in which case errno is set accordingly: EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT) EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG) ESRCH - requested partition is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4","title":"rd_kafka_consume_start()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_start_queue","text":"public static rd_kafka_consume_start_queue ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , \\FFI\\CData | null $rkqu ) : int | null Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which must have been previously allocated with rd_kafka_queue_new() . The application must use one of the rd_kafka_consume_*_queue() functions to receive fetched messages. rd_kafka_consume_start_queue() must not be called multiple times for the same topic and partition without stopping consumption first with rd_kafka_consume_stop() . rd_kafka_consume_start() and rd_kafka_consume_start_queue() must not be combined for the same topic and partition. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t rkqu \\FFI\\CData|null rd_kafka_queue_t* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258","title":"rd_kafka_consume_start_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_stop","text":"public static rd_kafka_consume_stop ( \\FFI\\CData | null $rkt , int | null $partition ) : int | null Stop consuming messages for topic rkt and partition , purging all messages currently in the local queue. NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method. The application needs to be stop all consumers before calling rd_kafka_destroy() on the main object handle. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t Returns int|null int - 0 on success or -1 on error (see errno ). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4","title":"rd_kafka_consume_stop()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_seek","text":"public static rd_kafka_seek ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset , int | null $timeout_ms ) : int Seek consumer for topic+partition to offset which is either an absolute or logical offset. If timeout_ms is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns RD_KAFKA_RESP_ERR__TIMED_OUT . If timeout_ms is 0 it will initiate the seek but return immediately without any error reporting (e.g., async). This call triggers a fetch queue barrier flush. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d","title":"rd_kafka_seek()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume","text":"public static rd_kafka_consume ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms ) : \\FFI\\CData | null Consume a single message from topic rkt and partition . timeout_ms is maximum amount of time to wait for a message to be received. Consumer must have been previously started with rd_kafka_consume_start() . Returns a message object on success or NULL on error. The message object must be destroyed with rd_kafka_message_destroy() when the application is done with it. Errors (when returning NULL): ETIMEDOUT - timeout_ms was reached with no new messages fetched. ENOENT - rkt + partition is unknown. (no prior rd_kafka_consume_start() call) NOTE: The returned message's ..->err must be checked for errors. NOTE: ..->err == RD_KAFKA_RESP_ERR__PARTITION_EOF signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore). Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e","title":"rd_kafka_consume()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_batch","text":"public static rd_kafka_consume_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the application provided array rkmessages (of size rkmessages_size entries). rd_kafka_consume_batch() provides higher throughput performance than rd_kafka_consume() . timeout_ms is the maximum amount of time to wait for all of rkmessages_size messages to be put into rkmessages . If no messages were available within the timeout period this function returns 0 and rkmessages remains untouched. This differs somewhat from rd_kafka_consume() . The message objects must be destroyed with rd_kafka_message_destroy() when the application is done with it. See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t - the number of rkmessages added in rkmessages , or -1 on error (same error codes as for rd_kafka_consume() . See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce","title":"rd_kafka_consume_batch()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_callback","text":"public static rd_kafka_consume_callback ( \\FFI\\CData | null $rkt , int | null $partition , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consumes messages from topic rkt and partition , calling the provided callback for each consumed messsage. rd_kafka_consume_callback() provides higher throughput performance than both rd_kafka_consume() and rd_kafka_consume_batch() . timeout_ms is the maximum amount of time to wait for one or more messages to arrive. The provided consume_cb function is called for each message, the application MUST NOT call rd_kafka_message_destroy() on the provided rkmessage . The opaque argument is passed to the 'consume_cb' as opaque . See also rd_kafka_consume() Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int - the number of messages processed or -1 on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6","title":"rd_kafka_consume_callback()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_queue","text":"public static rd_kafka_consume_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Consume from queue. See also rd_kafka_consume() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16","title":"rd_kafka_consume_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_batch_queue","text":"public static rd_kafka_consume_batch_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | null $rkmessages , int | null $rkmessages_size ) : int | null Consume batch of messages from queue. See also rd_kafka_consume_batch() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t** rkmessages_size int|null size_t Returns int|null ssize_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3d949238471993b18537855aad28fa23","title":"rd_kafka_consume_batch_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consume_callback_queue","text":"public static rd_kafka_consume_callback_queue ( \\FFI\\CData | null $rkqu , int | null $timeout_ms , \\FFI\\CData | \\Closure $consume_cb , \\FFI\\CData | object | string | null $opaque ) : int | null Consume multiple messages from queue with callback. See also rd_kafka_consume_callback() Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int consume_cb \\FFI\\CData|\\Closure void( )(rd_kafka_message_t , void*) opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532","title":"rd_kafka_consume_callback_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offset_store","text":"public static rd_kafka_offset_store ( \\FFI\\CData | null $rkt , int | null $partition , int | null $offset ) : int Store offset offset for topic rkt partition partition . The offset will be committed (written) to the offset store according to auto.commit.interval.ms . Remarks auto.commit.enable must be set to \"false\" when using this API. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t offset int|null int64_t Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4","title":"rd_kafka_offset_store()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_offsets_store","text":"public static rd_kafka_offsets_store ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_offsets_store()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_subscribe","text":"public static rd_kafka_subscribe ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Subscribe to topic set using balanced consumer groups. Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the topics list that is prefixed with \"^\" will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1","title":"rd_kafka_subscribe()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_unsubscribe","text":"public static rd_kafka_unsubscribe ( \\FFI\\CData | null $rk ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_unsubscribe()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_subscription","text":"public static rd_kafka_subscription ( \\FFI\\CData | null $rk , \\FFI\\CData | null $topics ) : int Returns the current topic subscription. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* topics \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise topic is updated to point to a newly allocated topic list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200","title":"rd_kafka_subscription()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_poll","text":"public static rd_kafka_consumer_poll ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Poll the consumer for messages or events. Will block for at most timeout_ms milliseconds. Remarks An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state. See also rd_kafka_message_t Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_message_t* - A message object which is a proper message if ->err is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf","title":"rd_kafka_consumer_poll()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_close","text":"public static rd_kafka_consumer_close ( \\FFI\\CData | null $rk ) : int Close down the KafkaConsumer. Remarks This call will block until the consumer has revoked its assignment, calling the rebalance_cb if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms. Remarks The application still needs to call rd_kafka_destroy() after this call finishes to clean up the underlying handle resources. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t - An error code indicating if the consumer close was succesful or not. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d","title":"rd_kafka_consumer_close()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assign","text":"public static rd_kafka_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Atomic assignment of partitions to consume. The new partitions will replace the existing assignment. When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state. A zero-length partitions will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a NULL value for partitions will reset and clear the internal state. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9","title":"rd_kafka_assign()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assignment","text":"public static rd_kafka_assignment ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Returns the current partition assignment. Remarks The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t** Returns int rd_kafka_resp_err_t - An error code on failure, otherwise partitions is updated to point to a newly allocated partition list (possibly empty). See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59","title":"rd_kafka_assignment()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit","text":"public static rd_kafka_commit ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int | null $async ) : int Commit offsets on broker for the provided list of partitions. offsets should contain topic , partition , offset and possibly metadata . If offsets is NULL the current partition assignment will be used instead. If async is false this operation will block until the broker offset commit is done, returning the resulting success or error code. If a rd_kafka_conf_set_offset_commit_cb() offset commit callback has been configured the callback will be enqueued for a future call to rd_kafka_poll(), rd_kafka_consumer_poll() or similar. Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87","title":"rd_kafka_commit()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_message","text":"public static rd_kafka_commit_message ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , int | null $async ) : int Commit message's offset on broker for the message's partition. See also rd_kafka_commit Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null rd_kafka_message_t* async int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883","title":"rd_kafka_commit_message()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_queue","text":"public static rd_kafka_commit_queue ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $rkqu , \\FFI\\CData | \\Closure $cb , \\FFI\\CData | object | string | null $opaque ) : int Commit offsets on broker for the provided list of partitions. See rd_kafka_commit for offsets semantics. The result of the offset commit will be posted on the provided rkqu queue. If the application uses one of the poll APIs (rd_kafka_poll(), rd_kafka_consumer_poll(), rd_kafka_queue_poll(), ..) to serve the queue the cb callback is required. opaque is passed to the callback. If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The opaque value will be available with rd_kafka_event_opaque() If rkqu is NULL a temporary queue will be created and the callback will be served by this call. See also rd_kafka_commit() rd_kafka_conf_set_offset_commit_cb() Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* rkqu \\FFI\\CData|null rd_kafka_queue_t* cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , rd_kafka_resp_err_t, rd_kafka_topic_partition_list_t*, void*) opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47","title":"rd_kafka_commit_queue()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_committed","text":"public static rd_kafka_committed ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : int Retrieve committed offsets for topics+partitions. The offset field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13","title":"rd_kafka_committed()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_position","text":"public static rd_kafka_position ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : int Retrieve current positions (offsets) for topics+partitions. The offset field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message. Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the offset or err field of each partitions\u2019 element is filled in with the stored offset, or a partition specific error. Else returns an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac","title":"rd_kafka_position()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produce","text":"public static rd_kafka_produce ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | object | string | null $payload , int | null $len , \\FFI\\CData | object | string | null $key , int | null $keylen , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Produce and send a single message to broker. rkt is the target topic which must have been previously created with rd_kafka_topic_new() . rd_kafka_produce() is an asynch non-blocking API. partition is the target partition, either: RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or a fixed partition (0..N) msgflags is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block produce* () call if queue.buffering.max.messages or queue.buffering.max.kbytes are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call rd_kafka_poll() (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on RD_KAFKA_MSG_F_BLOCK above. RD_KAFKA_MSG_F_FREE - rdkafka will free(3) payload when it is done with it. RD_KAFKA_MSG_F_COPY - the payload data will be copied and the payload pointer will not be used by rdkafka after the call returns. .._F_FREE and .._F_COPY are mutually exclusive. If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility. payload is the message payload of size len bytes. key is an optional message key of size keylen bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer. msg_opaque is an optional application-provided per-message opaque pointer that will provided in the delivery report callback ( dr_cb ) for referencing this message. Returns 0 on success or -1 on error in which case errno is set accordingly: ENOBUFS - maximum number of outstanding messages has been reached: \"queue.buffering.max.messages\" (RD_KAFKA_RESP_ERR__QUEUE_FULL) EMSGSIZE - message is larger than configured max size: \"messages.max.bytes\". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE) ESRCH - requested partition is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION) ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC) See also Use rd_kafka_errno2err() to convert errno to rdkafka error code. Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int payload \\FFI\\CData|object|string|null void* len int|null size_t key \\FFI\\CData|object|string|null void* keylen int|null size_t msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736","title":"rd_kafka_produce()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_producev","text":"public static rd_kafka_producev ( \\FFI\\CData | null $rk , mixed $args ) : int Produce and send a single message to broker. The message is defined by a va-arg list using rd_kafka_vtype_t tag tuples which must be terminated with a single RD_KAFKA_V_END . See also rd_kafka_produce, RD_KAFKA_V_END Parameters rk \\FFI\\CData|null rd_kafka_t* args mixed Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR_NO_ERROR on success, else an error code. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc","title":"rd_kafka_producev()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produce_batch","text":"public static rd_kafka_produce_batch ( \\FFI\\CData | null $rkt , int | null $partition , int | null $msgflags , \\FFI\\CData | null $rkmessages , int | null $message_cnt ) : int | null Produce multiple messages. If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster). The messages are provided in the array rkmessages of count message_cnt elements. The partition and msgflags are used for all provided messages. Honoured rkmessages [] fields are: payload,len Message payload and length key,key_len Optional message key _private Message opaque pointer (msg_opaque) err Will be set according to success or failure. Application only needs to check for errors if return value != message_cnt . Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* partition int|null int32_t msgflags int|null int rkmessages \\FFI\\CData|null rd_kafka_message_t* message_cnt int|null int Returns int|null int - the number of messages succesfully enqueued for producing. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed","title":"rd_kafka_produce_batch()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_flush","text":"public static rd_kafka_flush ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : int Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. Remarks This function will call rd_kafka_poll() and thus trigger callbacks. Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__TIMED_OUT if timeout_ms was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d","title":"rd_kafka_flush()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_purge","text":"public static rd_kafka_purge ( \\FFI\\CData | null $rk , int | null $purge_flags ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* purge_flags int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_purge()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_metadata","text":"public static rd_kafka_metadata ( \\FFI\\CData | null $rk , int | null $all_topics , \\FFI\\CData | null $only_rkt , \\FFI\\CData | null $metadatap , int | null $timeout_ms ) : int Request Metadata from broker. Parameters: all_topics if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics. only_rkt only request info about this topic metadatap pointer to hold metadata result. The *metadatap pointer must be released with rd_kafka_metadata_destroy(). timeout_ms maximum response time before failing. Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. Parameters rk \\FFI\\CData|null rd_kafka_t* all_topics int|null int only_rkt \\FFI\\CData|null rd_kafka_topic_t* metadatap \\FFI\\CData|null struct rd_kafka_metadata** timeout_ms int|null int Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344","title":"rd_kafka_metadata()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_metadata_destroy","text":"public static rd_kafka_metadata_destroy ( \\FFI\\CData | \\Closure $metadata ) : void Parameters metadata \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_metadata*)(rd_kafka_t*, int, rd_kafka_topic_t*, struct rd_kafka_metadata**, int)","title":"rd_kafka_metadata_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_list_groups","text":"public static rd_kafka_list_groups ( \\FFI\\CData | null $rk , string | null $group , \\FFI\\CData | null $grplistp , int | null $timeout_ms ) : int List and describe client groups in cluster. group is an optional group name to describe, otherwise ( NULL ) all groups are returned. timeout_ms is the (approximate) maximum time to wait for response from brokers and must be a positive value. See also Use rd_kafka_group_list_destroy() to release list memory. Parameters rk \\FFI\\CData|null rd_kafka_t* group string|null const char* grplistp \\FFI\\CData|null struct rd_kafka_group_list** timeout_ms int|null int Returns int rd_kafka_resp_err_t - RD_KAFKA_RESP_ERR__NO_ERROR on success and grplistp is updated to point to a newly allocated list of groups. Else returns an error code on failure and grplistp remains untouched. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a","title":"rd_kafka_list_groups()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_list_destroy","text":"public static rd_kafka_group_list_destroy ( \\FFI\\CData | null $grplist ) : void Parameters grplist \\FFI\\CData|null struct rd_kafka_group_list*","title":"rd_kafka_group_list_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_brokers_add","text":"public static rd_kafka_brokers_add ( \\FFI\\CData | null $rk , string | null $brokerlist ) : int | null Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata. If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion. brokerlist is a ,-separated list of brokers in the format: <broker1> ,<broker2>,.. Where each broker is in either the host or URL based format: <host> [:<port>] <proto> ://<host>[:port] <proto> is either PLAINTEXT , SSL , SASL , SASL_PLAINTEXT The two formats can be mixed but ultimately the value of the security.protocol config property decides what brokers are allowed. Example: brokerlist = \"broker1:10000,broker2\" brokerlist = \"SSL://broker3:9000,ssl://broker2\" Remarks Brokers may also be defined with the metadata.broker.list or bootstrap.servers configuration property (preferred method). Parameters rk \\FFI\\CData|null rd_kafka_t* brokerlist string|null const char* Returns int|null int - the number of brokers successfully added. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7","title":"rd_kafka_brokers_add()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_logger","text":"public static rd_kafka_set_logger ( \\FFI\\CData | null $rk , \\FFI\\CData | \\Closure $func ) : void Set logger function. The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging. Deprecated: Use rd_kafka_conf_set_log_cb() Remarks rk may be passed as NULL in the callback. Parameters rk \\FFI\\CData|null rd_kafka_t* func \\FFI\\CData|\\Closure void( )(rd_kafka_t , int, const char*, const char*) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53","title":"rd_kafka_set_logger()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_set_log_level","text":"public static rd_kafka_set_log_level ( \\FFI\\CData | null $rk , int | null $level ) : void Specifies the maximum logging level produced by internal kafka logging and debugging. If the \"debug\" configuration property is set the level is automatically adjusted to LOG_DEBUG (7). Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4","title":"rd_kafka_set_log_level()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_log_print","text":"public static rd_kafka_log_print ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char*","title":"rd_kafka_log_print()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_log_syslog","text":"public static rd_kafka_log_syslog ( \\FFI\\CData | null $rk , int | null $level , string | null $fac , string | null $buf ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* level int|null int fac string|null const char* buf string|null const char*","title":"rd_kafka_log_syslog()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_outq_len","text":"public static rd_kafka_outq_len ( \\FFI\\CData | null $rk ) : int | null Returns the current out queue length. The out queue contains messages waiting to be sent to, or acknowledged by, the broker. An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed. Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int|null int - number of messages in the out queue. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7","title":"rd_kafka_outq_len()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_dump","text":"public static rd_kafka_dump ( \\FFI\\CData | null $fp , \\FFI\\CData | null $rk ) : void Dumps rdkafka's internal state for handle rk to stream fp . This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. Parameters fp \\FFI\\CData|null FILE* rk \\FFI\\CData|null rd_kafka_t* See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1","title":"rd_kafka_dump()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_thread_cnt","text":"public static rd_kafka_thread_cnt ( ) : int | null Retrieve the current number of threads in use by librdkafka. Used by regression tests. Returns int|null int - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a0901699375c972b807ba5255773f017f","title":"rd_kafka_thread_cnt()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_wait_destroyed","text":"public static rd_kafka_wait_destroyed ( int | null $timeout_ms ) : int | null Wait for all rd_kafka_t objects to be destroyed. Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached. Since rd_kafka_destroy() is an asynch operation the rd_kafka_wait_destroyed() function can be used for applications where a clean shutdown is required. Parameters timeout_ms int|null int - ) Returns int|null int See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d","title":"rd_kafka_wait_destroyed()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_unittest","text":"public static rd_kafka_unittest ( ) : int | null Returns int|null int","title":"rd_kafka_unittest()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_poll_set_consumer","text":"public static rd_kafka_poll_set_consumer ( \\FFI\\CData | null $rk ) : int Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer's queue (rd_kafka_consumer_poll()). Warning It is not permitted to call rd_kafka_poll() after directing the main queue with rd_kafka_poll_set_consumer(). Parameters rk \\FFI\\CData|null rd_kafka_t* - ) Returns int rd_kafka_resp_err_t See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904","title":"rd_kafka_poll_set_consumer()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_type","text":"public static rd_kafka_event_type ( \\FFI\\CData | null $rkev ) : int | null Remarks As a convenience it is okay to pass rkev as NULL in which case RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null rd_kafka_event_type_t - the event type for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d","title":"rd_kafka_event_type()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_name","text":"public static rd_kafka_event_name ( \\FFI\\CData | null $rkev ) : string | null Remarks As a convenience it is okay to pass rkev as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the event type\u2019s name for the given event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866","title":"rd_kafka_event_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_destroy","text":"public static rd_kafka_event_destroy ( \\FFI\\CData | null $rkev ) : void Destroy an event. Remarks Any references to this event, such as extracted messages, will not be usable after this call. As a convenience it is okay to pass rkev as NULL in which case no action is performed. Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#af1835c85aa202caf629861f29f475099","title":"rd_kafka_event_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_next","text":"public static rd_kafka_event_message_next ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Call repeatedly until it returns NULL. Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Remarks The returned message(s) MUST NOT be freed with rd_kafka_message_destroy(). Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null const rd_kafka_message_t* - the next message from an event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c","title":"rd_kafka_event_message_next()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_array","text":"public static rd_kafka_event_message_array ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $rkmessages , int | null $size ) : int | null Extacts size message(s) from the event into the pre-allocated array rkmessages . Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* rkmessages \\FFI\\CData|null const rd_kafka_message_t** size int|null size_t Returns int|null size_t - the number of messages extracted. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8","title":"rd_kafka_event_message_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_message_count","text":"public static rd_kafka_event_message_count ( \\FFI\\CData | null $rkev ) : int | null Event types: RD_KAFKA_EVENT_FETCH (1 message) RD_KAFKA_EVENT_DR (>=1 message(s)) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int|null size_t - the number of remaining messages in the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90","title":"rd_kafka_event_message_count()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error","text":"public static rd_kafka_event_error ( \\FFI\\CData | null $rkev ) : int Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns int rd_kafka_resp_err_t - the error code for the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5","title":"rd_kafka_event_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error_string","text":"public static rd_kafka_event_error_string ( \\FFI\\CData | null $rkev ) : string | null Event types: all Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns string|null const char* - the error string (if any). An application should check that rd_kafka_event_error() returns non-zero before calling this function. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793","title":"rd_kafka_event_error_string()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_error_is_fatal","text":"public static rd_kafka_event_error_is_fatal ( \\FFI\\CData | null $rkev ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns int|null int","title":"rd_kafka_event_error_is_fatal()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_opaque","text":"public static rd_kafka_event_opaque ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | object | string | null Event types: RD_KAFKA_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|object|string|null void* - the user opaque (if any) See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525","title":"rd_kafka_event_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_log","text":"public static rd_kafka_event_log ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $fac , \\FFI\\CData | null $str , \\FFI\\CData | null $level ) : int | null Extract log message from the event. Event types: RD_KAFKA_EVENT_LOG Parameters rkev \\FFI\\CData|null rd_kafka_event_t* fac \\FFI\\CData|null char** str \\FFI\\CData|null char** level \\FFI\\CData|null int* Returns int|null int - 0 on success or -1 if unsupported event type. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a535efaa16772642d724bedca414c17c7","title":"rd_kafka_event_log()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_stats","text":"public static rd_kafka_event_stats ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char*","title":"rd_kafka_event_stats()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_topic_partition_list","text":"public static rd_kafka_event_topic_partition_list ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The list MUST NOT be freed with rd_kafka_topic_partition_list_destroy() Event types: RD_KAFKA_EVENT_REBALANCE RD_KAFKA_EVENT_OFFSET_COMMIT Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_list_t* - the topic partition list from the event. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633","title":"rd_kafka_event_topic_partition_list()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_topic_partition","text":"public static rd_kafka_event_topic_partition ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Remarks The returned pointer MUST be freed with rd_kafka_topic_partition_destroy(). Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) Parameters rkev \\FFI\\CData|null rd_kafka_event_t* - ) Returns \\FFI\\CData|null rd_kafka_topic_partition_t* - a newly allocated topic_partition container, if applicable for the event type, else NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe","title":"rd_kafka_event_topic_partition()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_createtopics_result","text":"public static rd_kafka_event_CreateTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreateTopics_result_t*","title":"rd_kafka_event_CreateTopics_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deletetopics_result","text":"public static rd_kafka_event_DeleteTopics_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t*","title":"rd_kafka_event_DeleteTopics_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_createpartitions_result","text":"public static rd_kafka_event_CreatePartitions_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t*","title":"rd_kafka_event_CreatePartitions_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_alterconfigs_result","text":"public static rd_kafka_event_AlterConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t*","title":"rd_kafka_event_AlterConfigs_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_describeconfigs_result","text":"public static rd_kafka_event_DescribeConfigs_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t*","title":"rd_kafka_event_DescribeConfigs_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_poll","text":"public static rd_kafka_queue_poll ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : \\FFI\\CData | null Poll a queue for an event for max timeout_ms . Remarks Use rd_kafka_event_destroy() to free the event. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_event_t* - an event, or NULL. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa","title":"rd_kafka_queue_poll()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_poll_callback","text":"public static rd_kafka_queue_poll_callback ( \\FFI\\CData | null $rkqu , int | null $timeout_ms ) : int | null Poll a queue for events served through callbacks for max timeout_ms . Remarks This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t* timeout_ms int|null int Returns int|null int - the number of events served. See also https://docs.confluent.io/3.2.1/clients/librdkafka/rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e","title":"rd_kafka_queue_poll_callback()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_plugin_f_conf_init_t","text":"public static rd_kafka_plugin_f_conf_init_t ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $plug_opaquep , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* plug_opaquep \\FFI\\CData|object|string|null void** errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_plugin_f_conf_init_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_set_t","text":"public static rd_kafka_interceptor_f_on_conf_set_t ( \\FFI\\CData | null $conf , string | null $name , string | null $val , \\FFI\\CData | null $errstr , int | null $errstr_size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* name string|null const char* val string|null const char* errstr \\FFI\\CData|null char* errstr_size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_conf_res_t","title":"rd_kafka_interceptor_f_on_conf_set_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_dup_t","text":"public static rd_kafka_interceptor_f_on_conf_dup_t ( \\FFI\\CData | null $new_conf , \\FFI\\CData | null $old_conf , int | null $filter_cnt , \\FFI\\CData | null $filter , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters new_conf \\FFI\\CData|null rd_kafka_conf_t* old_conf \\FFI\\CData|null rd_kafka_conf_t* filter_cnt int|null size_t filter \\FFI\\CData|null char** ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_conf_dup_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_conf_destroy_t","text":"public static rd_kafka_interceptor_f_on_conf_destroy_t ( \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_conf_destroy_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_new_t","text":"public static rd_kafka_interceptor_f_on_new_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $ic_opaque , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* conf \\FFI\\CData|null rd_kafka_conf_t* ic_opaque \\FFI\\CData|object|string|null void* errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_new_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_destroy_t","text":"public static rd_kafka_interceptor_f_on_destroy_t ( \\FFI\\CData | null $rk , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_destroy_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_send_t","text":"public static rd_kafka_interceptor_f_on_send_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_send_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_acknowledgement_t","text":"public static rd_kafka_interceptor_f_on_acknowledgement_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_acknowledgement_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_consume_t","text":"public static rd_kafka_interceptor_f_on_consume_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $rkmessage , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* rkmessage \\FFI\\CData|null const rd_kafka_message_t* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_consume_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_commit_t","text":"public static rd_kafka_interceptor_f_on_commit_t ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_commit_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_request_sent_t","text":"public static rd_kafka_interceptor_f_on_request_sent_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_request_sent_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_set","text":"public static rd_kafka_conf_interceptor_add_on_conf_set ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_set , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_set \\FFI\\CData|\\Closure rd_kafka_conf_res_t(rd_kafka_interceptor_f_on_conf_set_t*)(rd_kafka_conf_t*, const char*, const char*, char*, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_set()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_dup","text":"public static rd_kafka_conf_interceptor_add_on_conf_dup ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_dup , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_dup \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_dup_t*)(rd_kafka_conf_t*, rd_kafka_conf_t*, size_t, char**, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_dup()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_conf_destroy","text":"public static rd_kafka_conf_interceptor_add_on_conf_destroy ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_conf_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_conf_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_conf_destroy_t*)(void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_conf_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_interceptor_add_on_new","text":"public static rd_kafka_conf_interceptor_add_on_new ( \\FFI\\CData | null $conf , string | null $ic_name , \\FFI\\CData | \\Closure $on_new , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters conf \\FFI\\CData|null rd_kafka_conf_t* ic_name string|null const char* on_new \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_new_t*)(rd_kafka_t*, rd_kafka_conf_t*, void*, char*, size_t) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_conf_interceptor_add_on_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_destroy","text":"public static rd_kafka_interceptor_add_on_destroy ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_destroy , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_destroy \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_destroy_t*)(rd_kafka_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_send","text":"public static rd_kafka_interceptor_add_on_send ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_send , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_send \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_send_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_send()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_acknowledgement","text":"public static rd_kafka_interceptor_add_on_acknowledgement ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_acknowledgement , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_acknowledgement \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_acknowledgement_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_acknowledgement()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_consume","text":"public static rd_kafka_interceptor_add_on_consume ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_consume , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_consume \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_consume_t*)(rd_kafka_t*, const rd_kafka_message_t*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_consume()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_commit","text":"public static rd_kafka_interceptor_add_on_commit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_commit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_commit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_commit_t*)(rd_kafka_t*, rd_kafka_topic_partition_list_t*, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_commit()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_request_sent","text":"public static rd_kafka_interceptor_add_on_request_sent ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_request_sent , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_request_sent \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_request_sent_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_request_sent()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_error","text":"public static rd_kafka_topic_result_error ( \\FFI\\CData | null $topicres ) : int Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_topic_result_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_error_string","text":"public static rd_kafka_topic_result_error_string ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char*","title":"rd_kafka_topic_result_error_string()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_topic_result_name","text":"public static rd_kafka_topic_result_name ( \\FFI\\CData | null $topicres ) : string | null Parameters topicres \\FFI\\CData|null rd_kafka_topic_result_t* Returns string|null const char*","title":"rd_kafka_topic_result_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_new","text":"public static rd_kafka_AdminOptions_new ( \\FFI\\CData | null $rk , int $for_api ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* for_api int rd_kafka_admin_op_t Returns \\FFI\\CData|null rd_kafka_AdminOptions_t*","title":"rd_kafka_AdminOptions_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_destroy","text":"public static rd_kafka_AdminOptions_destroy ( \\FFI\\CData | null $options ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t*","title":"rd_kafka_AdminOptions_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_request_timeout","text":"public static rd_kafka_AdminOptions_set_request_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_request_timeout()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_operation_timeout","text":"public static rd_kafka_AdminOptions_set_operation_timeout ( \\FFI\\CData | null $options , int | null $timeout_ms , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* timeout_ms int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_operation_timeout()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_validate_only","text":"public static rd_kafka_AdminOptions_set_validate_only ( \\FFI\\CData | null $options , int | null $true_or_false , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* true_or_false int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_validate_only()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_broker","text":"public static rd_kafka_AdminOptions_set_broker ( \\FFI\\CData | null $options , int | null $broker_id , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* broker_id int|null int32_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_AdminOptions_set_broker()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_adminoptions_set_opaque","text":"public static rd_kafka_AdminOptions_set_opaque ( \\FFI\\CData | null $options , \\FFI\\CData | object | string | null $opaque ) : void Parameters options \\FFI\\CData|null rd_kafka_AdminOptions_t* opaque \\FFI\\CData|object|string|null void*","title":"rd_kafka_AdminOptions_set_opaque()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_new","text":"public static rd_kafka_NewTopic_new ( string | null $topic , int | null $num_partitions , int | null $replication_factor , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* num_partitions int|null int replication_factor int|null int errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewTopic_t*","title":"rd_kafka_NewTopic_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_destroy","text":"public static rd_kafka_NewTopic_destroy ( \\FFI\\CData | null $new_topic ) : void Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t*","title":"rd_kafka_NewTopic_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_destroy_array","text":"public static rd_kafka_NewTopic_destroy_array ( \\FFI\\CData | null $new_topics , int | null $new_topic_cnt ) : void Parameters new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t","title":"rd_kafka_NewTopic_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_set_replica_assignment","text":"public static rd_kafka_NewTopic_set_replica_assignment ( \\FFI\\CData | null $new_topic , int | null $partition , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* partition int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewTopic_set_replica_assignment()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newtopic_set_config","text":"public static rd_kafka_NewTopic_set_config ( \\FFI\\CData | null $new_topic , string | null $name , string | null $value ) : int Parameters new_topic \\FFI\\CData|null rd_kafka_NewTopic_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewTopic_set_config()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createtopics","text":"public static rd_kafka_CreateTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_topics , int | null $new_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_topics \\FFI\\CData|null rd_kafka_NewTopic_t** new_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_CreateTopics()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createtopics_result_topics","text":"public static rd_kafka_CreateTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreateTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_CreateTopics_result_topics()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_new","text":"public static rd_kafka_DeleteTopic_new ( string | null $topic ) : \\FFI\\CData | null Parameters topic string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteTopic_t*","title":"rd_kafka_DeleteTopic_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_destroy","text":"public static rd_kafka_DeleteTopic_destroy ( \\FFI\\CData | null $del_topic ) : void Parameters del_topic \\FFI\\CData|null rd_kafka_DeleteTopic_t*","title":"rd_kafka_DeleteTopic_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopic_destroy_array","text":"public static rd_kafka_DeleteTopic_destroy_array ( \\FFI\\CData | null $del_topics , int | null $del_topic_cnt ) : void Parameters del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t","title":"rd_kafka_DeleteTopic_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopics","text":"public static rd_kafka_DeleteTopics ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_topics , int | null $del_topic_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_topics \\FFI\\CData|null rd_kafka_DeleteTopic_t** del_topic_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteTopics()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletetopics_result_topics","text":"public static rd_kafka_DeleteTopics_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteTopics_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_DeleteTopics_result_topics()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_new","text":"public static rd_kafka_NewPartitions_new ( string | null $topic , int | null $new_total_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : \\FFI\\CData | null Parameters topic string|null const char* new_total_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns \\FFI\\CData|null rd_kafka_NewPartitions_t*","title":"rd_kafka_NewPartitions_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_destroy","text":"public static rd_kafka_NewPartitions_destroy ( \\FFI\\CData | null $new_parts ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t*","title":"rd_kafka_NewPartitions_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_destroy_array","text":"public static rd_kafka_NewPartitions_destroy_array ( \\FFI\\CData | null $new_parts , int | null $new_parts_cnt ) : void Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t","title":"rd_kafka_NewPartitions_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_newpartitions_set_replica_assignment","text":"public static rd_kafka_NewPartitions_set_replica_assignment ( \\FFI\\CData | null $new_parts , int | null $new_partition_idx , \\FFI\\CData | null $broker_ids , int | null $broker_id_cnt , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t* new_partition_idx int|null int32_t broker_ids \\FFI\\CData|null int32_t* broker_id_cnt int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_NewPartitions_set_replica_assignment()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createpartitions","text":"public static rd_kafka_CreatePartitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $new_parts , int | null $new_parts_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* new_parts \\FFI\\CData|null rd_kafka_NewPartitions_t** new_parts_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_CreatePartitions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_createpartitions_result_topics","text":"public static rd_kafka_CreatePartitions_result_topics ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_CreatePartitions_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_topic_result_t**","title":"rd_kafka_CreatePartitions_result_topics()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configsource_name","text":"public static rd_kafka_ConfigSource_name ( int $confsource ) : string | null Parameters confsource int rd_kafka_ConfigSource_t Returns string|null const char*","title":"rd_kafka_ConfigSource_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_name","text":"public static rd_kafka_ConfigEntry_name ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char*","title":"rd_kafka_ConfigEntry_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_value","text":"public static rd_kafka_ConfigEntry_value ( \\FFI\\CData | null $entry ) : string | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns string|null const char*","title":"rd_kafka_ConfigEntry_value()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_source","text":"public static rd_kafka_ConfigEntry_source ( \\FFI\\CData | null $entry ) : int Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int rd_kafka_ConfigSource_t","title":"rd_kafka_ConfigEntry_source()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_read_only","text":"public static rd_kafka_ConfigEntry_is_read_only ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_read_only()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_default","text":"public static rd_kafka_ConfigEntry_is_default ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_default()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_sensitive","text":"public static rd_kafka_ConfigEntry_is_sensitive ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_sensitive()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_is_synonym","text":"public static rd_kafka_ConfigEntry_is_synonym ( \\FFI\\CData | null $entry ) : int | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* Returns int|null int","title":"rd_kafka_ConfigEntry_is_synonym()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configentry_synonyms","text":"public static rd_kafka_ConfigEntry_synonyms ( \\FFI\\CData | null $entry , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters entry \\FFI\\CData|null rd_kafka_ConfigEntry_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t**","title":"rd_kafka_ConfigEntry_synonyms()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_resourcetype_name","text":"public static rd_kafka_ResourceType_name ( int $restype ) : string | null Parameters restype int rd_kafka_ResourceType_t Returns string|null const char*","title":"rd_kafka_ResourceType_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_new","text":"public static rd_kafka_ConfigResource_new ( int $restype , string | null $resname ) : \\FFI\\CData | null Parameters restype int rd_kafka_ResourceType_t resname string|null const char* Returns \\FFI\\CData|null rd_kafka_ConfigResource_t*","title":"rd_kafka_ConfigResource_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_destroy","text":"public static rd_kafka_ConfigResource_destroy ( \\FFI\\CData | null $config ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t*","title":"rd_kafka_ConfigResource_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_destroy_array","text":"public static rd_kafka_ConfigResource_destroy_array ( \\FFI\\CData | null $config , int | null $config_cnt ) : void Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t","title":"rd_kafka_ConfigResource_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_set_config","text":"public static rd_kafka_ConfigResource_set_config ( \\FFI\\CData | null $config , string | null $name , string | null $value ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* name string|null const char* value string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_ConfigResource_set_config()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_configs","text":"public static rd_kafka_ConfigResource_configs ( \\FFI\\CData | null $config , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigEntry_t**","title":"rd_kafka_ConfigResource_configs()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_type","text":"public static rd_kafka_ConfigResource_type ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_ResourceType_t","title":"rd_kafka_ConfigResource_type()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_name","text":"public static rd_kafka_ConfigResource_name ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char*","title":"rd_kafka_ConfigResource_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_error","text":"public static rd_kafka_ConfigResource_error ( \\FFI\\CData | null $config ) : int Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_ConfigResource_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_configresource_error_string","text":"public static rd_kafka_ConfigResource_error_string ( \\FFI\\CData | null $config ) : string | null Parameters config \\FFI\\CData|null rd_kafka_ConfigResource_t* Returns string|null const char*","title":"rd_kafka_ConfigResource_error_string()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconfigs","text":"public static rd_kafka_AlterConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_AlterConfigs()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_alterconfigs_result_resources","text":"public static rd_kafka_AlterConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_AlterConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t**","title":"rd_kafka_AlterConfigs_result_resources()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconfigs","text":"public static rd_kafka_DescribeConfigs ( \\FFI\\CData | null $rk , \\FFI\\CData | null $configs , int | null $config_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* configs \\FFI\\CData|null const rd_kafka_ConfigResource_t** config_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DescribeConfigs()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_describeconfigs_result_resources","text":"public static rd_kafka_DescribeConfigs_result_resources ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DescribeConfigs_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_ConfigResource_t**","title":"rd_kafka_DescribeConfigs_result_resources()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf","text":"public static rd_kafka_conf ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null const rd_kafka_conf_t*","title":"rd_kafka_conf()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_oauthbearer_token_refresh_cb","text":"public static rd_kafka_conf_set_oauthbearer_token_refresh_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $oauthbearer_token_refresh_cb ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* oauthbearer_token_refresh_cb \\FFI\\CData|\\Closure void( )(rd_kafka_t , const char*, void*)","title":"rd_kafka_conf_set_oauthbearer_token_refresh_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_ssl_cert_verify_cb","text":"public static rd_kafka_conf_set_ssl_cert_verify_cb ( \\FFI\\CData | null $conf , \\FFI\\CData | \\Closure $ssl_cert_verify_cb ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* ssl_cert_verify_cb \\FFI\\CData|\\Closure int( )(rd_kafka_t , const char*, int32_t, int*, int, const char*, size_t, char*, size_t, void*) Returns int rd_kafka_conf_res_t","title":"rd_kafka_conf_set_ssl_cert_verify_cb()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_ssl_cert","text":"public static rd_kafka_conf_set_ssl_cert ( \\FFI\\CData | null $conf , int $cert_type , int $cert_enc , \\FFI\\CData | object | string | null $buffer , int | null $size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* cert_type int rd_kafka_cert_type_t cert_enc int rd_kafka_cert_enc_t buffer \\FFI\\CData|object|string|null void* size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_conf_res_t","title":"rd_kafka_conf_set_ssl_cert()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_config_string","text":"public static rd_kafka_event_config_string ( \\FFI\\CData | null $rkev ) : string | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns string|null const char*","title":"rd_kafka_event_config_string()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_oauthbearer_set_token","text":"public static rd_kafka_oauthbearer_set_token ( \\FFI\\CData | null $rk , string | null $token_value , int | null $md_lifetime_ms , string | null $md_principal_name , \\FFI\\CData | null $extensions , int | null $extension_size , \\FFI\\CData | null $errstr , int | null $errstr_size ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* token_value string|null const char* md_lifetime_ms int|null int64_t md_principal_name string|null const char* extensions \\FFI\\CData|null char** extension_size int|null size_t errstr \\FFI\\CData|null char* errstr_size int|null size_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_oauthbearer_set_token()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_oauthbearer_set_token_failure","text":"public static rd_kafka_oauthbearer_set_token_failure ( \\FFI\\CData | null $rk , string | null $errstr ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* errstr string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_oauthbearer_set_token_failure()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_thread_start_t","text":"public static rd_kafka_interceptor_f_on_thread_start_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_thread_start_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_thread_exit_t","text":"public static rd_kafka_interceptor_f_on_thread_exit_t ( \\FFI\\CData | null $rk , int $thread_type , string | null $thread_name , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* thread_type int rd_kafka_thread_type_t thread_name string|null const char* ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_thread_exit_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_thread_start","text":"public static rd_kafka_interceptor_add_on_thread_start ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_start , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_start \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_start_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_thread_start()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_thread_exit","text":"public static rd_kafka_interceptor_add_on_thread_exit ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_thread_exit , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_thread_exit \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_thread_exit_t*)(rd_kafka_t*, rd_kafka_thread_type_t, const char*, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_thread_exit()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_new","text":"public static rd_kafka_mock_cluster_new ( \\FFI\\CData | null $rk , int | null $broker_cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* broker_cnt int|null int Returns \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_mock_cluster_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_destroy","text":"public static rd_kafka_mock_cluster_destroy ( \\FFI\\CData | null $mcluster ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_mock_cluster_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_handle","text":"public static rd_kafka_mock_cluster_handle ( \\FFI\\CData | null $mcluster ) : \\FFI\\CData | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns \\FFI\\CData|null rd_kafka_t*","title":"rd_kafka_mock_cluster_handle()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_cluster_bootstraps","text":"public static rd_kafka_mock_cluster_bootstraps ( \\FFI\\CData | null $mcluster ) : string | null Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* Returns string|null const char*","title":"rd_kafka_mock_cluster_bootstraps()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_push_request_errors","text":"public static rd_kafka_mock_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , mixed $args ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t args mixed","title":"rd_kafka_mock_push_request_errors()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_topic_set_error","text":"public static rd_kafka_mock_topic_set_error ( \\FFI\\CData | null $mcluster , string | null $topic , int $err ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* err int rd_kafka_resp_err_t","title":"rd_kafka_mock_topic_set_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_leader","text":"public static rd_kafka_mock_partition_set_leader ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_leader()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_follower","text":"public static rd_kafka_mock_partition_set_follower ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_follower()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_partition_set_follower_wmarks","text":"public static rd_kafka_mock_partition_set_follower_wmarks ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition , int | null $lo , int | null $hi ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition int|null int32_t lo int|null int64_t hi int|null int64_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_partition_set_follower_wmarks()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_rack","text":"public static rd_kafka_mock_broker_set_rack ( \\FFI\\CData | null $mcluster , int | null $broker_id , string | null $rack ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rack string|null const char* Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_rack()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_code","text":"public static rd_kafka_error_code ( \\FFI\\CData | null $error ) : int Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int rd_kafka_resp_err_t","title":"rd_kafka_error_code()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_name","text":"public static rd_kafka_error_name ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char*","title":"rd_kafka_error_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_string","text":"public static rd_kafka_error_string ( \\FFI\\CData | null $error ) : string | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns string|null const char*","title":"rd_kafka_error_string()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_is_fatal","text":"public static rd_kafka_error_is_fatal ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_is_fatal()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_is_retriable","text":"public static rd_kafka_error_is_retriable ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_is_retriable()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_txn_requires_abort","text":"public static rd_kafka_error_txn_requires_abort ( \\FFI\\CData | null $error ) : int | null Parameters error \\FFI\\CData|null rd_kafka_error_t* Returns int|null int","title":"rd_kafka_error_txn_requires_abort()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_destroy","text":"public static rd_kafka_error_destroy ( \\FFI\\CData | null $error ) : void Parameters error \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_error_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_error_new","text":"public static rd_kafka_error_new ( int $code , string | null $fmt , mixed $args ) : \\FFI\\CData | null Parameters code int rd_kafka_resp_err_t fmt string|null const char* args mixed Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_error_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_fnv1a","text":"public static rd_kafka_msg_partitioner_fnv1a ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_fnv1a()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_msg_partitioner_fnv1a_random","text":"public static rd_kafka_msg_partitioner_fnv1a_random ( \\FFI\\CData | null $rkt , \\FFI\\CData | object | string | null $key , int | null $keylen , int | null $partition_cnt , \\FFI\\CData | object | string | null $rkt_opaque , \\FFI\\CData | object | string | null $msg_opaque ) : int | null Parameters rkt \\FFI\\CData|null rd_kafka_topic_t* key \\FFI\\CData|object|string|null void* keylen int|null size_t partition_cnt int|null int32_t rkt_opaque \\FFI\\CData|object|string|null void* msg_opaque \\FFI\\CData|object|string|null void* Returns int|null int32_t","title":"rd_kafka_msg_partitioner_fnv1a_random()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata","text":"public static rd_kafka_consumer_group_metadata ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_new","text":"public static rd_kafka_consumer_group_metadata_new ( string | null $group_id ) : \\FFI\\CData | null Parameters group_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_destroy","text":"public static rd_kafka_consumer_group_metadata_destroy ( \\FFI\\CData | null $arg0 ) : void Parameters arg0 \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_write","text":"public static rd_kafka_consumer_group_metadata_write ( \\FFI\\CData | null $cgmd , \\FFI\\CData | object | string | null $bufferp , \\FFI\\CData | null $sizep ) : \\FFI\\CData | null Parameters cgmd \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* bufferp \\FFI\\CData|object|string|null void** sizep \\FFI\\CData|null size_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_consumer_group_metadata_write()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_read","text":"public static rd_kafka_consumer_group_metadata_read ( \\FFI\\CData | null $cgmdp , \\FFI\\CData | object | string | null $buffer , int | null $size ) : \\FFI\\CData | null Parameters cgmdp \\FFI\\CData|null rd_kafka_consumer_group_metadata_t** buffer \\FFI\\CData|object|string|null void* size int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_consumer_group_metadata_read()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_init_transactions","text":"public static rd_kafka_init_transactions ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_init_transactions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_begin_transaction","text":"public static rd_kafka_begin_transaction ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_begin_transaction()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_send_offsets_to_transaction","text":"public static rd_kafka_send_offsets_to_transaction ( \\FFI\\CData | null $rk , \\FFI\\CData | null $offsets , \\FFI\\CData | null $cgmetadata , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* offsets \\FFI\\CData|null rd_kafka_topic_partition_list_t* cgmetadata \\FFI\\CData|null rd_kafka_consumer_group_metadata_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_send_offsets_to_transaction()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_commit_transaction","text":"public static rd_kafka_commit_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_commit_transaction()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_abort_transaction","text":"public static rd_kafka_abort_transaction ( \\FFI\\CData | null $rk , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_abort_transaction()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_handle_mock_cluster","text":"public static rd_kafka_handle_mock_cluster ( \\FFI\\CData | null $rk ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns \\FFI\\CData|null rd_kafka_mock_cluster_t*","title":"rd_kafka_handle_mock_cluster()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_topic_create","text":"public static rd_kafka_mock_topic_create ( \\FFI\\CData | null $mcluster , string | null $topic , int | null $partition_cnt , int | null $replication_factor ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* topic string|null const char* partition_cnt int|null int replication_factor int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_topic_create()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_down","text":"public static rd_kafka_mock_broker_set_down ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_down()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_up","text":"public static rd_kafka_mock_broker_set_up ( \\FFI\\CData | null $mcluster , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_up()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_coordinator_set","text":"public static rd_kafka_mock_coordinator_set ( \\FFI\\CData | null $mcluster , string | null $key_type , string | null $key , int | null $broker_id ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* key_type string|null const char* key string|null const char* broker_id int|null int32_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_coordinator_set()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_set_apiversion","text":"public static rd_kafka_mock_set_apiversion ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $MinVersion , int | null $MaxVersion ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t MinVersion int|null int16_t MaxVersion int|null int16_t Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_set_apiversion()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_set_rtt","text":"public static rd_kafka_mock_broker_set_rtt ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $rtt_ms ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t rtt_ms int|null int Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_set_rtt()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_errstr","text":"public static rd_kafka_message_errstr ( \\FFI\\CData | null $rkmessage ) : string | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns string|null const char*","title":"rd_kafka_message_errstr()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_message_broker_id","text":"public static rd_kafka_message_broker_id ( \\FFI\\CData | null $rkmessage ) : int | null Parameters rkmessage \\FFI\\CData|null rd_kafka_message_t* Returns int|null int32_t","title":"rd_kafka_message_broker_id()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_produceva","text":"public static rd_kafka_produceva ( \\FFI\\CData | null $rk , \\FFI\\CData | null $vus , int | null $cnt ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* vus \\FFI\\CData|null rd_kafka_vu_t* cnt int|null size_t Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_produceva()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_debug_contexts","text":"public static rd_kafka_event_debug_contexts ( \\FFI\\CData | null $rkev , \\FFI\\CData | null $dst , int | null $dstsize ) : int | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* dst \\FFI\\CData|null char* dstsize int|null size_t Returns int|null int","title":"rd_kafka_event_debug_contexts()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_push_request_errors","text":"public static rd_kafka_mock_broker_push_request_errors ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_push_request_errors()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_get_default_topic_conf","text":"public static rd_kafka_conf_get_default_topic_conf ( \\FFI\\CData | null $conf ) : \\FFI\\CData | null Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* Returns \\FFI\\CData|null rd_kafka_topic_conf_t*","title":"rd_kafka_conf_get_default_topic_conf()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_queue_yield","text":"public static rd_kafka_queue_yield ( \\FFI\\CData | null $rkqu ) : void Parameters rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_queue_yield()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_seek_partitions","text":"public static rd_kafka_seek_partitions ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions , int | null $timeout_ms ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* timeout_ms int|null int Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_seek_partitions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incremental_assign","text":"public static rd_kafka_incremental_assign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_incremental_assign()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_incremental_unassign","text":"public static rd_kafka_incremental_unassign ( \\FFI\\CData | null $rk , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters rk \\FFI\\CData|null rd_kafka_t* partitions \\FFI\\CData|null rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_error_t*","title":"rd_kafka_incremental_unassign()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_rebalance_protocol","text":"public static rd_kafka_rebalance_protocol ( \\FFI\\CData | null $rk ) : string | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns string|null const char*","title":"rd_kafka_rebalance_protocol()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_assignment_lost","text":"public static rd_kafka_assignment_lost ( \\FFI\\CData | null $rk ) : int | null Parameters rk \\FFI\\CData|null rd_kafka_t* Returns int|null int","title":"rd_kafka_assignment_lost()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_consumer_group_metadata_new_with_genid","text":"public static rd_kafka_consumer_group_metadata_new_with_genid ( string | null $group_id , int | null $generation_id , string | null $member_id , string | null $group_instance_id ) : \\FFI\\CData | null Parameters group_id string|null const char* generation_id int|null int32_t member_id string|null const char* group_instance_id string|null const char* Returns \\FFI\\CData|null rd_kafka_consumer_group_metadata_t*","title":"rd_kafka_consumer_group_metadata_new_with_genid()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deleterecords_result","text":"public static rd_kafka_event_DeleteRecords_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t*","title":"rd_kafka_event_DeleteRecords_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deletegroups_result","text":"public static rd_kafka_event_DeleteGroups_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t*","title":"rd_kafka_event_DeleteGroups_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_event_deleteconsumergroupoffsets_result","text":"public static rd_kafka_event_DeleteConsumerGroupOffsets_result ( \\FFI\\CData | null $rkev ) : \\FFI\\CData | null Parameters rkev \\FFI\\CData|null rd_kafka_event_t* Returns \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t*","title":"rd_kafka_event_DeleteConsumerGroupOffsets_result()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_error","text":"public static rd_kafka_group_result_error ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_error_t*","title":"rd_kafka_group_result_error()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_name","text":"public static rd_kafka_group_result_name ( \\FFI\\CData | null $groupres ) : string | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns string|null const char*","title":"rd_kafka_group_result_name()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_group_result_partitions","text":"public static rd_kafka_group_result_partitions ( \\FFI\\CData | null $groupres ) : \\FFI\\CData | null Parameters groupres \\FFI\\CData|null rd_kafka_group_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t*","title":"rd_kafka_group_result_partitions()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_new","text":"public static rd_kafka_DeleteRecords_new ( \\FFI\\CData | null $before_offsets ) : \\FFI\\CData | null Parameters before_offsets \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteRecords_t*","title":"rd_kafka_DeleteRecords_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_destroy","text":"public static rd_kafka_DeleteRecords_destroy ( \\FFI\\CData | null $del_records ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t*","title":"rd_kafka_DeleteRecords_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_destroy_array","text":"public static rd_kafka_DeleteRecords_destroy_array ( \\FFI\\CData | null $del_records , int | null $del_record_cnt ) : void Parameters del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t","title":"rd_kafka_DeleteRecords_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords","text":"public static rd_kafka_DeleteRecords ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_records , int | null $del_record_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_records \\FFI\\CData|null rd_kafka_DeleteRecords_t** del_record_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteRecords()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleterecords_result_offsets","text":"public static rd_kafka_DeleteRecords_result_offsets ( \\FFI\\CData | null $result ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteRecords_result_t* Returns \\FFI\\CData|null const rd_kafka_topic_partition_list_t*","title":"rd_kafka_DeleteRecords_result_offsets()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_new","text":"public static rd_kafka_DeleteGroup_new ( string | null $group ) : \\FFI\\CData | null Parameters group string|null const char* Returns \\FFI\\CData|null rd_kafka_DeleteGroup_t*","title":"rd_kafka_DeleteGroup_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_destroy","text":"public static rd_kafka_DeleteGroup_destroy ( \\FFI\\CData | null $del_group ) : void Parameters del_group \\FFI\\CData|null rd_kafka_DeleteGroup_t*","title":"rd_kafka_DeleteGroup_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroup_destroy_array","text":"public static rd_kafka_DeleteGroup_destroy_array ( \\FFI\\CData | null $del_groups , int | null $del_group_cnt ) : void Parameters del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t","title":"rd_kafka_DeleteGroup_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroups","text":"public static rd_kafka_DeleteGroups ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_groups , int | null $del_group_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_groups \\FFI\\CData|null rd_kafka_DeleteGroup_t** del_group_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteGroups()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deletegroups_result_groups","text":"public static rd_kafka_DeleteGroups_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteGroups_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t**","title":"rd_kafka_DeleteGroups_result_groups()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_new","text":"public static rd_kafka_DeleteConsumerGroupOffsets_new ( string | null $group , \\FFI\\CData | null $partitions ) : \\FFI\\CData | null Parameters group string|null const char* partitions \\FFI\\CData|null const rd_kafka_topic_partition_list_t* Returns \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t*","title":"rd_kafka_DeleteConsumerGroupOffsets_new()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_destroy","text":"public static rd_kafka_DeleteConsumerGroupOffsets_destroy ( \\FFI\\CData | null $del_grpoffsets ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t*","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_destroy_array","text":"public static rd_kafka_DeleteConsumerGroupOffsets_destroy_array ( \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffset_cnt ) : void Parameters del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffset_cnt int|null size_t","title":"rd_kafka_DeleteConsumerGroupOffsets_destroy_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets","text":"public static rd_kafka_DeleteConsumerGroupOffsets ( \\FFI\\CData | null $rk , \\FFI\\CData | null $del_grpoffsets , int | null $del_grpoffsets_cnt , \\FFI\\CData | null $options , \\FFI\\CData | null $rkqu ) : void Parameters rk \\FFI\\CData|null rd_kafka_t* del_grpoffsets \\FFI\\CData|null rd_kafka_DeleteConsumerGroupOffsets_t** del_grpoffsets_cnt int|null size_t options \\FFI\\CData|null rd_kafka_AdminOptions_t* rkqu \\FFI\\CData|null rd_kafka_queue_t*","title":"rd_kafka_DeleteConsumerGroupOffsets()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_deleteconsumergroupoffsets_result_groups","text":"public static rd_kafka_DeleteConsumerGroupOffsets_result_groups ( \\FFI\\CData | null $result , \\FFI\\CData | null $cntp ) : \\FFI\\CData | null Parameters result \\FFI\\CData|null const rd_kafka_DeleteConsumerGroupOffsets_result_t* cntp \\FFI\\CData|null size_t* Returns \\FFI\\CData|null const rd_kafka_group_result_t**","title":"rd_kafka_DeleteConsumerGroupOffsets_result_groups()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_clear_request_errors","text":"public static rd_kafka_mock_clear_request_errors ( \\FFI\\CData | null $mcluster , int | null $ApiKey ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t","title":"rd_kafka_mock_clear_request_errors()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_push_request_errors_array","text":"public static rd_kafka_mock_push_request_errors_array ( \\FFI\\CData | null $mcluster , int | null $ApiKey , int | null $cnt , \\FFI\\CData | null $errors ) : void Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* ApiKey int|null int16_t cnt int|null size_t errors \\FFI\\CData|null rd_kafka_resp_err_t*","title":"rd_kafka_mock_push_request_errors_array()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_f_on_response_received_t","text":"public static rd_kafka_interceptor_f_on_response_received_t ( \\FFI\\CData | null $rk , int | null $sockfd , string | null $brokername , int | null $brokerid , int | null $ApiKey , int | null $ApiVersion , int | null $CorrId , int | null $size , int | null $rtt , int $err , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* sockfd int|null int brokername string|null const char* brokerid int|null int32_t ApiKey int|null int16_t ApiVersion int|null int16_t CorrId int|null int32_t size int|null size_t rtt int|null int64_t err int rd_kafka_resp_err_t ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_f_on_response_received_t()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_interceptor_add_on_response_received","text":"public static rd_kafka_interceptor_add_on_response_received ( \\FFI\\CData | null $rk , string | null $ic_name , \\FFI\\CData | \\Closure $on_response_received , \\FFI\\CData | object | string | null $ic_opaque ) : int Parameters rk \\FFI\\CData|null rd_kafka_t* ic_name string|null const char* on_response_received \\FFI\\CData|\\Closure rd_kafka_resp_err_t(rd_kafka_interceptor_f_on_response_received_t*)(rd_kafka_t*, int, const char*, int32_t, int16_t, int16_t, int32_t, size_t, int64_t, rd_kafka_resp_err_t, void*) ic_opaque \\FFI\\CData|object|string|null void* Returns int rd_kafka_resp_err_t","title":"rd_kafka_interceptor_add_on_response_received()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_conf_set_engine_callback_data","text":"public static rd_kafka_conf_set_engine_callback_data ( \\FFI\\CData | null $conf , \\FFI\\CData | object | string | null $callback_data ) : void Parameters conf \\FFI\\CData|null const rd_kafka_conf_t* callback_data \\FFI\\CData|object|string|null void*","title":"rd_kafka_conf_set_engine_callback_data()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_calloc","text":"public static rd_kafka_mem_calloc ( \\FFI\\CData | null $rk , int | null $num , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* num int|null size_t size int|null size_t Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_mem_calloc()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mem_malloc","text":"public static rd_kafka_mem_malloc ( \\FFI\\CData | null $rk , int | null $size ) : \\FFI\\CData | object | string | null Parameters rk \\FFI\\CData|null rd_kafka_t* size int|null size_t Returns \\FFI\\CData|object|string|null void*","title":"rd_kafka_mem_malloc()"},{"location":"api/RdKafka/FFI/Methods/#rd_kafka_mock_broker_push_request_error_rtts","text":"public static rd_kafka_mock_broker_push_request_error_rtts ( \\FFI\\CData | null $mcluster , int | null $broker_id , int | null $ApiKey , int | null $cnt , mixed $args ) : int Parameters mcluster \\FFI\\CData|null rd_kafka_mock_cluster_t* broker_id int|null int32_t ApiKey int|null int16_t cnt int|null size_t args mixed Returns int rd_kafka_resp_err_t","title":"rd_kafka_mock_broker_push_request_error_rtts()"},{"location":"api/RdKafka/FFI/Methods/#used-by","text":"\\RdKafka\\FFI\\Library","title":"Used by"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/","text":"Class NativePartitionerCallbackProxy \u00b6 Class \\RdKafka\\FFI\\NativePartitionerCallbackProxy Methods \u00b6 __construct() \u00b6 public __construct ( string $partitionerMethod ) : Parameters partitionerMethod string __invoke() \u00b6 public __invoke ( ? \\FFI\\CData $topic , ? \\FFI\\CData $keydata , int $keylen , int $partition_cnt , ? \\FFI\\CData $topic_opaque = null , ? \\FFI\\CData $msg_opaque = null ) : int Parameters topic ?\\FFI\\CData keydata ?\\FFI\\CData keylen int partition_cnt int topic_opaque ?\\FFI\\CData msg_opaque ?\\FFI\\CData Returns int create() \u00b6 public static create ( string $partitionerMethod ) : \\Closure Parameters partitionerMethod string Returns \\Closure Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (3 / 3)","title":"NativePartitionerCallbackProxy"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#class-nativepartitionercallbackproxy","text":"Class \\RdKafka\\FFI\\NativePartitionerCallbackProxy","title":"Class NativePartitionerCallbackProxy"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#__construct","text":"public __construct ( string $partitionerMethod ) : Parameters partitionerMethod string","title":"__construct()"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#__invoke","text":"public __invoke ( ? \\FFI\\CData $topic , ? \\FFI\\CData $keydata , int $keylen , int $partition_cnt , ? \\FFI\\CData $topic_opaque = null , ? \\FFI\\CData $msg_opaque = null ) : int Parameters topic ?\\FFI\\CData keydata ?\\FFI\\CData keylen int partition_cnt int topic_opaque ?\\FFI\\CData msg_opaque ?\\FFI\\CData Returns int","title":"__invoke()"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#create","text":"public static create ( string $partitionerMethod ) : \\Closure Parameters partitionerMethod string Returns \\Closure","title":"create()"},{"location":"api/RdKafka/FFI/NativePartitionerCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (3 / 3)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/","text":"Class OffsetCommitCallbackProxy \u00b6 Class \\RdKafka\\FFI\\OffsetCommitCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $consumer , int $err , \\FFI\\CData $nativeTopicPartitionList , ? \\FFI\\CData $opaque = null ) : void Parameters consumer \\FFI\\CData err int nativeTopicPartitionList \\FFI\\CData opaque ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"OffsetCommitCallbackProxy"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#class-offsetcommitcallbackproxy","text":"Class \\RdKafka\\FFI\\OffsetCommitCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class OffsetCommitCallbackProxy"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $consumer , int $err , \\FFI\\CData $nativeTopicPartitionList , ? \\FFI\\CData $opaque = null ) : void Parameters consumer \\FFI\\CData err int nativeTopicPartitionList \\FFI\\CData opaque ?\\FFI\\CData","title":"__invoke()"},{"location":"api/RdKafka/FFI/OffsetCommitCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/OpaqueMap/","text":"Class OpaqueMap \u00b6 Class \\RdKafka\\FFI\\OpaqueMap Methods \u00b6 get() \u00b6 public static get ( ? \\FFI\\CData $cOpaque ) : mixed | null Parameters cOpaque ?\\FFI\\CData Returns mixed|null pull() \u00b6 public static pull ( ? \\FFI\\CData $cOpaque ) : mixed | null Parameters cOpaque ?\\FFI\\CData Returns mixed|null push() \u00b6 public static push ( mixed | null $opaque ) : ? \\FFI\\CData Parameters opaque mixed|null Returns ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 96.3% (26 / 27) \ud83e\udde1 Methods: 66.67% (2 / 3)","title":"OpaqueMap"},{"location":"api/RdKafka/FFI/OpaqueMap/#class-opaquemap","text":"Class \\RdKafka\\FFI\\OpaqueMap","title":"Class OpaqueMap"},{"location":"api/RdKafka/FFI/OpaqueMap/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/OpaqueMap/#get","text":"public static get ( ? \\FFI\\CData $cOpaque ) : mixed | null Parameters cOpaque ?\\FFI\\CData Returns mixed|null","title":"get()"},{"location":"api/RdKafka/FFI/OpaqueMap/#pull","text":"public static pull ( ? \\FFI\\CData $cOpaque ) : mixed | null Parameters cOpaque ?\\FFI\\CData Returns mixed|null","title":"pull()"},{"location":"api/RdKafka/FFI/OpaqueMap/#push","text":"public static push ( mixed | null $opaque ) : ? \\FFI\\CData Parameters opaque mixed|null Returns ?\\FFI\\CData","title":"push()"},{"location":"api/RdKafka/FFI/OpaqueMap/#test-coverage","text":"\ud83d\udc9a Lines: 96.3% (26 / 27) \ud83e\udde1 Methods: 66.67% (2 / 3)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/","text":"Class PartitionerCallbackProxy \u00b6 Class \\RdKafka\\FFI\\PartitionerCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( ? \\FFI\\CData $topic , ? \\FFI\\CData $keydata , int $keylen , int $partition_cnt , ? \\FFI\\CData $topic_opaque = null , ? \\FFI\\CData $msg_opaque = null ) : int Parameters topic ?\\FFI\\CData keydata ?\\FFI\\CData keylen int partition_cnt int topic_opaque ?\\FFI\\CData msg_opaque ?\\FFI\\CData Returns int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"PartitionerCallbackProxy"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#class-partitionercallbackproxy","text":"Class \\RdKafka\\FFI\\PartitionerCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class PartitionerCallbackProxy"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#__invoke","text":"public __invoke ( ? \\FFI\\CData $topic , ? \\FFI\\CData $keydata , int $keylen , int $partition_cnt , ? \\FFI\\CData $topic_opaque = null , ? \\FFI\\CData $msg_opaque = null ) : int Parameters topic ?\\FFI\\CData keydata ?\\FFI\\CData keylen int partition_cnt int topic_opaque ?\\FFI\\CData msg_opaque ?\\FFI\\CData Returns int","title":"__invoke()"},{"location":"api/RdKafka/FFI/PartitionerCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (4 / 4) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/","text":"Class RebalanceCallbackProxy \u00b6 Class \\RdKafka\\FFI\\RebalanceCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $consumer , int $err , \\FFI\\CData $nativeTopicPartitionList , ? \\FFI\\CData $opaque = null ) : void Parameters consumer \\FFI\\CData err int nativeTopicPartitionList \\FFI\\CData opaque ?\\FFI\\CData Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"RebalanceCallbackProxy"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#class-rebalancecallbackproxy","text":"Class \\RdKafka\\FFI\\RebalanceCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class RebalanceCallbackProxy"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $consumer , int $err , \\FFI\\CData $nativeTopicPartitionList , ? \\FFI\\CData $opaque = null ) : void Parameters consumer \\FFI\\CData err int nativeTopicPartitionList \\FFI\\CData opaque ?\\FFI\\CData","title":"__invoke()"},{"location":"api/RdKafka/FFI/RebalanceCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/","text":"Class StatsCallbackProxy \u00b6 Class \\RdKafka\\FFI\\StatsCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy Methods \u00b6 __invoke() \u00b6 public __invoke ( \\FFI\\CData $consumerOrProducer , \\FFI\\CData $json , int $json_len , ? \\FFI\\CData $opaque = null ) : int Parameters consumerOrProducer \\FFI\\CData json \\FFI\\CData json_len int opaque ?\\FFI\\CData Returns int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"StatsCallbackProxy"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#class-statscallbackproxy","text":"Class \\RdKafka\\FFI\\StatsCallbackProxy extends \\RdKafka\\FFI\\CallbackProxy","title":"Class StatsCallbackProxy"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#__invoke","text":"public __invoke ( \\FFI\\CData $consumerOrProducer , \\FFI\\CData $json , int $json_len , ? \\FFI\\CData $opaque = null ) : int Parameters consumerOrProducer \\FFI\\CData json \\FFI\\CData json_len int opaque ?\\FFI\\CData Returns int","title":"__invoke()"},{"location":"api/RdKafka/FFI/StatsCallbackProxy/#test-coverage","text":"\ud83d\udc9a Lines: 100% (5 / 5) \ud83d\udc9a Methods: 100% (1 / 1)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Metadata/Broker/","text":"Class Broker \u00b6 Class \\RdKafka\\Metadata\\Broker Methods \u00b6 __construct() \u00b6 public __construct ( int $id , string $host , int $port ) : Parameters id int host string port int getHost() \u00b6 public getHost ( ) : string Returns string getId() \u00b6 public getId ( ) : int Returns int getPort() \u00b6 public getPort ( ) : int Returns int Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (4 / 4)","title":"Broker"},{"location":"api/RdKafka/Metadata/Broker/#class-broker","text":"Class \\RdKafka\\Metadata\\Broker","title":"Class Broker"},{"location":"api/RdKafka/Metadata/Broker/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Metadata/Broker/#__construct","text":"public __construct ( int $id , string $host , int $port ) : Parameters id int host string port int","title":"__construct()"},{"location":"api/RdKafka/Metadata/Broker/#gethost","text":"public getHost ( ) : string Returns string","title":"getHost()"},{"location":"api/RdKafka/Metadata/Broker/#getid","text":"public getId ( ) : int Returns int","title":"getId()"},{"location":"api/RdKafka/Metadata/Broker/#getport","text":"public getPort ( ) : int Returns int","title":"getPort()"},{"location":"api/RdKafka/Metadata/Broker/#test-coverage","text":"\ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (4 / 4)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Metadata/Collection/","text":"Class Collection \u00b6 Class \\RdKafka\\Metadata\\Collection implements \\Iterator implements \\Countable Methods \u00b6 __construct() \u00b6 public __construct ( array $items = [] ) : Parameters items array count() \u00b6 public count ( ) : int Returns int current() \u00b6 public current ( ) : mixed Returns mixed key() \u00b6 public key ( ) : int | string Returns int|string next() \u00b6 public next ( ) : void rewind() \u00b6 public rewind ( ) : void valid() \u00b6 public valid ( ) : bool Returns bool Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (10 / 10) \ud83d\udc9a Methods: 100% (7 / 7)","title":"Collection"},{"location":"api/RdKafka/Metadata/Collection/#class-collection","text":"Class \\RdKafka\\Metadata\\Collection implements \\Iterator implements \\Countable","title":"Class Collection"},{"location":"api/RdKafka/Metadata/Collection/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Metadata/Collection/#__construct","text":"public __construct ( array $items = [] ) : Parameters items array","title":"__construct()"},{"location":"api/RdKafka/Metadata/Collection/#count","text":"public count ( ) : int Returns int","title":"count()"},{"location":"api/RdKafka/Metadata/Collection/#current","text":"public current ( ) : mixed Returns mixed","title":"current()"},{"location":"api/RdKafka/Metadata/Collection/#key","text":"public key ( ) : int | string Returns int|string","title":"key()"},{"location":"api/RdKafka/Metadata/Collection/#next","text":"public next ( ) : void","title":"next()"},{"location":"api/RdKafka/Metadata/Collection/#rewind","text":"public rewind ( ) : void","title":"rewind()"},{"location":"api/RdKafka/Metadata/Collection/#valid","text":"public valid ( ) : bool Returns bool","title":"valid()"},{"location":"api/RdKafka/Metadata/Collection/#test-coverage","text":"\ud83d\udc9a Lines: 100% (10 / 10) \ud83d\udc9a Methods: 100% (7 / 7)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Metadata/Partition/","text":"Class Partition \u00b6 Class \\RdKafka\\Metadata\\Partition Methods \u00b6 __construct() \u00b6 public __construct ( int $id , int $err , int $leader , \\RdKafka\\Metadata\\Collection $replicas , \\RdKafka\\Metadata\\Collection $isrs ) : Parameters id int err int leader int replicas \\RdKafka\\Metadata\\Collection isrs \\RdKafka\\Metadata\\Collection getErr() \u00b6 public getErr ( ) : int Returns int getId() \u00b6 public getId ( ) : int Returns int getIsrs() \u00b6 public getIsrs ( ) : \\RdKafka\\Metadata\\Collection Returns \\RdKafka\\Metadata\\Collection getLeader() \u00b6 public getLeader ( ) : int Returns int getReplicas() \u00b6 public getReplicas ( ) : \\RdKafka\\Metadata\\Collection Returns \\RdKafka\\Metadata\\Collection Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 90.91% (10 / 11) \ud83d\udc9b Methods: 83.33% (5 / 6)","title":"Partition"},{"location":"api/RdKafka/Metadata/Partition/#class-partition","text":"Class \\RdKafka\\Metadata\\Partition","title":"Class Partition"},{"location":"api/RdKafka/Metadata/Partition/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Metadata/Partition/#__construct","text":"public __construct ( int $id , int $err , int $leader , \\RdKafka\\Metadata\\Collection $replicas , \\RdKafka\\Metadata\\Collection $isrs ) : Parameters id int err int leader int replicas \\RdKafka\\Metadata\\Collection isrs \\RdKafka\\Metadata\\Collection","title":"__construct()"},{"location":"api/RdKafka/Metadata/Partition/#geterr","text":"public getErr ( ) : int Returns int","title":"getErr()"},{"location":"api/RdKafka/Metadata/Partition/#getid","text":"public getId ( ) : int Returns int","title":"getId()"},{"location":"api/RdKafka/Metadata/Partition/#getisrs","text":"public getIsrs ( ) : \\RdKafka\\Metadata\\Collection Returns \\RdKafka\\Metadata\\Collection","title":"getIsrs()"},{"location":"api/RdKafka/Metadata/Partition/#getleader","text":"public getLeader ( ) : int Returns int","title":"getLeader()"},{"location":"api/RdKafka/Metadata/Partition/#getreplicas","text":"public getReplicas ( ) : \\RdKafka\\Metadata\\Collection Returns \\RdKafka\\Metadata\\Collection","title":"getReplicas()"},{"location":"api/RdKafka/Metadata/Partition/#test-coverage","text":"\ud83d\udc9a Lines: 90.91% (10 / 11) \ud83d\udc9b Methods: 83.33% (5 / 6)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Metadata/Topic/","text":"Class Topic \u00b6 Class \\RdKafka\\Metadata\\Topic Methods \u00b6 __construct() \u00b6 public __construct ( string $topic , \\RdKafka\\Metadata\\Collection $partitions , int $err ) : Parameters topic string partitions \\RdKafka\\Metadata\\Collection err int getErr() \u00b6 public getErr ( ) : int Returns int getPartitions() \u00b6 public getPartitions ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Partition [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Partition [] getTopic() \u00b6 public getTopic ( ) : string Returns string Test Coverage \ud83d\udc9a \u00b6 \ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (4 / 4)","title":"Topic"},{"location":"api/RdKafka/Metadata/Topic/#class-topic","text":"Class \\RdKafka\\Metadata\\Topic","title":"Class Topic"},{"location":"api/RdKafka/Metadata/Topic/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Metadata/Topic/#__construct","text":"public __construct ( string $topic , \\RdKafka\\Metadata\\Collection $partitions , int $err ) : Parameters topic string partitions \\RdKafka\\Metadata\\Collection err int","title":"__construct()"},{"location":"api/RdKafka/Metadata/Topic/#geterr","text":"public getErr ( ) : int Returns int","title":"getErr()"},{"location":"api/RdKafka/Metadata/Topic/#getpartitions","text":"public getPartitions ( ) : \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Partition [] Returns \\RdKafka\\Metadata\\Collection | \\RdKafka\\Metadata\\Partition []","title":"getPartitions()"},{"location":"api/RdKafka/Metadata/Topic/#gettopic","text":"public getTopic ( ) : string Returns string","title":"getTopic()"},{"location":"api/RdKafka/Metadata/Topic/#test-coverage","text":"\ud83d\udc9a Lines: 100% (7 / 7) \ud83d\udc9a Methods: 100% (4 / 4)","title":"Test Coverage \ud83d\udc9a"},{"location":"api/RdKafka/Test/ApiKey/","text":"Class ApiKey \u00b6 Class \\RdKafka\\Test\\ApiKey See also https://kafka.apache.org/protocol#protocol_api_keys Constants \u00b6 AddOffsetsToTxn \u00b6 public AddOffsetsToTxn = 25 AddPartitionsToTxn \u00b6 public AddPartitionsToTxn = 24 AlterConfigs \u00b6 public AlterConfigs = 33 AlterReplicaLogDirs \u00b6 public AlterReplicaLogDirs = 34 ApiVersion \u00b6 public ApiVersion = 18 ControlledShutdown \u00b6 public ControlledShutdown = 7 CreateAcls \u00b6 public CreateAcls = 30 CreateDelegationToken \u00b6 public CreateDelegationToken = 38 CreatePartitions \u00b6 public CreatePartitions = 37 CreateTopics \u00b6 public CreateTopics = 19 DeleteAcls \u00b6 public DeleteAcls = 31 DeleteGroups \u00b6 public DeleteGroups = 42 DeleteRecords \u00b6 public DeleteRecords = 21 DeleteTopics \u00b6 public DeleteTopics = 20 DescribeAcls \u00b6 public DescribeAcls = 29 DescribeConfigs \u00b6 public DescribeConfigs = 32 DescribeDelegationToken \u00b6 public DescribeDelegationToken = 41 DescribeGroups \u00b6 public DescribeGroups = 15 DescribeLogDirs \u00b6 public DescribeLogDirs = 35 EndTxn \u00b6 public EndTxn = 26 ExpireDelegationToken \u00b6 public ExpireDelegationToken = 40 Fetch \u00b6 public Fetch = 1 FindCoordinator \u00b6 public FindCoordinator = 10 Heartbeat \u00b6 public Heartbeat = 12 InitProducerId \u00b6 public InitProducerId = 22 JoinGroup \u00b6 public JoinGroup = 11 LeaderAndIsr \u00b6 public LeaderAndIsr = 4 LeaveGroup \u00b6 public LeaveGroup = 13 ListGroups \u00b6 public ListGroups = 16 Metadata \u00b6 public Metadata = 3 None \u00b6 public None = - 1 Offset \u00b6 public Offset = 2 OffsetCommit \u00b6 public OffsetCommit = 8 OffsetFetch \u00b6 public OffsetFetch = 9 OffsetForLeaderEpoch \u00b6 public OffsetForLeaderEpoch = 23 Produce \u00b6 public Produce = 0 RenewDelegationToken \u00b6 public RenewDelegationToken = 39 SaslAuthenticate \u00b6 public SaslAuthenticate = 36 SaslHandshake \u00b6 public SaslHandshake = 17 StopReplica \u00b6 public StopReplica = 5 SyncGroup \u00b6 public SyncGroup = 14 TxnOffsetCommit \u00b6 public TxnOffsetCommit = 28 UpdateMetadata \u00b6 public UpdateMetadata = 6 WriteTxnMarkers \u00b6 public WriteTxnMarkers = 27","title":"ApiKey"},{"location":"api/RdKafka/Test/ApiKey/#class-apikey","text":"Class \\RdKafka\\Test\\ApiKey See also https://kafka.apache.org/protocol#protocol_api_keys","title":"Class ApiKey"},{"location":"api/RdKafka/Test/ApiKey/#constants","text":"","title":"Constants"},{"location":"api/RdKafka/Test/ApiKey/#addoffsetstotxn","text":"public AddOffsetsToTxn = 25","title":"AddOffsetsToTxn"},{"location":"api/RdKafka/Test/ApiKey/#addpartitionstotxn","text":"public AddPartitionsToTxn = 24","title":"AddPartitionsToTxn"},{"location":"api/RdKafka/Test/ApiKey/#alterconfigs","text":"public AlterConfigs = 33","title":"AlterConfigs"},{"location":"api/RdKafka/Test/ApiKey/#alterreplicalogdirs","text":"public AlterReplicaLogDirs = 34","title":"AlterReplicaLogDirs"},{"location":"api/RdKafka/Test/ApiKey/#apiversion","text":"public ApiVersion = 18","title":"ApiVersion"},{"location":"api/RdKafka/Test/ApiKey/#controlledshutdown","text":"public ControlledShutdown = 7","title":"ControlledShutdown"},{"location":"api/RdKafka/Test/ApiKey/#createacls","text":"public CreateAcls = 30","title":"CreateAcls"},{"location":"api/RdKafka/Test/ApiKey/#createdelegationtoken","text":"public CreateDelegationToken = 38","title":"CreateDelegationToken"},{"location":"api/RdKafka/Test/ApiKey/#createpartitions","text":"public CreatePartitions = 37","title":"CreatePartitions"},{"location":"api/RdKafka/Test/ApiKey/#createtopics","text":"public CreateTopics = 19","title":"CreateTopics"},{"location":"api/RdKafka/Test/ApiKey/#deleteacls","text":"public DeleteAcls = 31","title":"DeleteAcls"},{"location":"api/RdKafka/Test/ApiKey/#deletegroups","text":"public DeleteGroups = 42","title":"DeleteGroups"},{"location":"api/RdKafka/Test/ApiKey/#deleterecords","text":"public DeleteRecords = 21","title":"DeleteRecords"},{"location":"api/RdKafka/Test/ApiKey/#deletetopics","text":"public DeleteTopics = 20","title":"DeleteTopics"},{"location":"api/RdKafka/Test/ApiKey/#describeacls","text":"public DescribeAcls = 29","title":"DescribeAcls"},{"location":"api/RdKafka/Test/ApiKey/#describeconfigs","text":"public DescribeConfigs = 32","title":"DescribeConfigs"},{"location":"api/RdKafka/Test/ApiKey/#describedelegationtoken","text":"public DescribeDelegationToken = 41","title":"DescribeDelegationToken"},{"location":"api/RdKafka/Test/ApiKey/#describegroups","text":"public DescribeGroups = 15","title":"DescribeGroups"},{"location":"api/RdKafka/Test/ApiKey/#describelogdirs","text":"public DescribeLogDirs = 35","title":"DescribeLogDirs"},{"location":"api/RdKafka/Test/ApiKey/#endtxn","text":"public EndTxn = 26","title":"EndTxn"},{"location":"api/RdKafka/Test/ApiKey/#expiredelegationtoken","text":"public ExpireDelegationToken = 40","title":"ExpireDelegationToken"},{"location":"api/RdKafka/Test/ApiKey/#fetch","text":"public Fetch = 1","title":"Fetch"},{"location":"api/RdKafka/Test/ApiKey/#findcoordinator","text":"public FindCoordinator = 10","title":"FindCoordinator"},{"location":"api/RdKafka/Test/ApiKey/#heartbeat","text":"public Heartbeat = 12","title":"Heartbeat"},{"location":"api/RdKafka/Test/ApiKey/#initproducerid","text":"public InitProducerId = 22","title":"InitProducerId"},{"location":"api/RdKafka/Test/ApiKey/#joingroup","text":"public JoinGroup = 11","title":"JoinGroup"},{"location":"api/RdKafka/Test/ApiKey/#leaderandisr","text":"public LeaderAndIsr = 4","title":"LeaderAndIsr"},{"location":"api/RdKafka/Test/ApiKey/#leavegroup","text":"public LeaveGroup = 13","title":"LeaveGroup"},{"location":"api/RdKafka/Test/ApiKey/#listgroups","text":"public ListGroups = 16","title":"ListGroups"},{"location":"api/RdKafka/Test/ApiKey/#metadata","text":"public Metadata = 3","title":"Metadata"},{"location":"api/RdKafka/Test/ApiKey/#none","text":"public None = - 1","title":"None"},{"location":"api/RdKafka/Test/ApiKey/#offset","text":"public Offset = 2","title":"Offset"},{"location":"api/RdKafka/Test/ApiKey/#offsetcommit","text":"public OffsetCommit = 8","title":"OffsetCommit"},{"location":"api/RdKafka/Test/ApiKey/#offsetfetch","text":"public OffsetFetch = 9","title":"OffsetFetch"},{"location":"api/RdKafka/Test/ApiKey/#offsetforleaderepoch","text":"public OffsetForLeaderEpoch = 23","title":"OffsetForLeaderEpoch"},{"location":"api/RdKafka/Test/ApiKey/#produce","text":"public Produce = 0","title":"Produce"},{"location":"api/RdKafka/Test/ApiKey/#renewdelegationtoken","text":"public RenewDelegationToken = 39","title":"RenewDelegationToken"},{"location":"api/RdKafka/Test/ApiKey/#saslauthenticate","text":"public SaslAuthenticate = 36","title":"SaslAuthenticate"},{"location":"api/RdKafka/Test/ApiKey/#saslhandshake","text":"public SaslHandshake = 17","title":"SaslHandshake"},{"location":"api/RdKafka/Test/ApiKey/#stopreplica","text":"public StopReplica = 5","title":"StopReplica"},{"location":"api/RdKafka/Test/ApiKey/#syncgroup","text":"public SyncGroup = 14","title":"SyncGroup"},{"location":"api/RdKafka/Test/ApiKey/#txnoffsetcommit","text":"public TxnOffsetCommit = 28","title":"TxnOffsetCommit"},{"location":"api/RdKafka/Test/ApiKey/#updatemetadata","text":"public UpdateMetadata = 6","title":"UpdateMetadata"},{"location":"api/RdKafka/Test/ApiKey/#writetxnmarkers","text":"public WriteTxnMarkers = 27","title":"WriteTxnMarkers"},{"location":"api/RdKafka/Test/MockCluster/","text":"Class MockCluster \u00b6 Class \\RdKafka\\Test\\MockCluster Note: MockCluster is experimental - even in librdkafka! Expect breaking changes within minor versions of this library. Methods \u00b6 __destruct() \u00b6 public __destruct ( ) : create() \u00b6 public static create ( int $brokerCount , ? \\RdKafka\\Conf $conf = null ) : self Parameters brokerCount int conf ? \\RdKafka\\Conf Returns self createTopic() \u00b6 public createTopic ( string $topic , int $partitionCount , int $replicationFactor ) : void Creates a topic. This is an alternative to automatic topic creation as performed by the client itself. The Topic Admin API (CreateTopics) is not supported by the mock broker. Parameters topic string partitionCount int replicationFactor int fromProducer() \u00b6 public static fromProducer ( \\RdKafka\\Producer $producer ) : self Derive mock cluster from Producer created by setting the test.mock.num.brokers configuration property. Parameters producer \\RdKafka\\Producer Returns self getBootstraps() \u00b6 public getBootstraps ( ) : string Returns string the mock cluster\u2019s bootstrap.servers list pushBrokerRequestErrorRtts() \u00b6 public pushBrokerRequestErrorRtts ( int $brokerId , int $apiKey , int $count , int $errorCodeAndRttTuples ) : void Same as {@link MockCluster::pushBrokerRequestErrors()} but for a specific broker. The broker errors take precedence over the cluster errors. Parameters brokerId int apiKey int count int errorCodeAndRttTuples int plain tuples of error code or 0 (int) and response RTT/delay in millisecond (int) pushBrokerRequestErrors() \u00b6 public pushBrokerRequestErrors ( int $brokerId , int $apiKey , int $count , int $errorCodes ) : void Same as {@link MockCluster::pushRequestErrors()} but for a specific broker. The broker errors take precedence over the cluster errors. Parameters brokerId int apiKey int count int errorCodes int a list of error codes or 0 pushRequestErrors() \u00b6 public pushRequestErrors ( int $apiKey , int $count , int $errorCodes ) : void Push cnt errors onto the cluster\u2019s error stack for the given apiKey. ApiKey is the Kafka protocol request type, e.g., Produce (0). The following cnt protocol requests matching apiKey will fail with the provided error code and removed from the stack, starting with the first error code, then the second, etc. Parameters apiKey int count int errorCodes int pushRequestErrorsArray() \u00b6 public pushRequestErrorsArray ( int $apiKey , int $count , int [] $errorCodes ) : void See {@link MockCluster::pushRequestErrors()} Parameters apiKey int count int errorCodes int[] setApiVersion() \u00b6 public setApiVersion ( int $apiKey , int $minVersion , int $maxVersion ) : void Set the allowed ApiVersion range for apiKey. Set minVersion and maxVersion to -1 to disable the API completely. MaxVersion MUST not exceed the maximum implemented value. Parameters apiKey int Protocol request type/key minVersion int Minimum version supported (or -1 to disable). maxVersion int Maximum version supported (or -1 to disable). setBrokerDown() \u00b6 public setBrokerDown ( int $brokerId ) : void Disconnects the broker and disallows any new connections. This does NOT trigger leader change. Parameters brokerId int setBrokerRack() \u00b6 public setBrokerRack ( int $brokerId , string $rack ) : void Sets the broker\u2019s rack as reported in Metadata to the client. Parameters brokerId int rack string setBrokerUp() \u00b6 public setBrokerUp ( int $brokerId ) : void Makes the broker accept connections again. This does NOT trigger leader change. Parameters brokerId int setCoordinator() \u00b6 public setCoordinator ( string $keyType , string $key , int $brokerId ) : void Explicitly sets the coordinator. If this API is not a standard hashing scheme will be used. Parameters keyType string \u201ctransaction\u201d or \u201cgroup\u201d key string The transactional.id or group.id brokerId int The new coordinator, does not have to be a valid broker. setPartitionFollower() \u00b6 public setPartitionFollower ( string $topic , int $partition , int $brokerId ) : void Sets the partition\u2019s preferred replica / follower. The topic will be created if it does not exist. Parameters topic string partition int brokerId int does not need to point to an existing broker. setPartitionFollowerWatermarks() \u00b6 public setPartitionFollowerWatermarks ( string $topic , int $partition , int $low , int $high ) : void Sets the partition\u2019s preferred replica / follower low and high watermarks. The topic will be created if it does not exist. Setting an offset to -1 will revert back to the leader\u2019s corresponding watermark. Parameters topic string partition int low int high int setPartitionLeader() \u00b6 public setPartitionLeader ( string $topic , int $partition , int $brokerId ) : void Sets the partition leader. The topic will be created if it does not exist. Parameters topic string partition int brokerId int needs to be an existing broker setRtt() \u00b6 public setRtt ( int $brokerId , int $roundTripTimeDelayMs ) : void Set broker round-trip-time delay in milliseconds. Parameters brokerId int roundTripTimeDelayMs int setTopicError() \u00b6 public setTopicError ( string $topic , int $errorCode ) : void Set the topic error to return in protocol requests. Currently only used for TopicMetadataRequest and AddPartitionsToTxnRequest. Parameters topic string errorCode int Test Coverage \ud83e\udde1 \u00b6 \ud83e\udde1 Lines: 67.59% (73 / 108) \u2764\ufe0f Methods: 35% (7 / 20)","title":"MockCluster"},{"location":"api/RdKafka/Test/MockCluster/#class-mockcluster","text":"Class \\RdKafka\\Test\\MockCluster Note: MockCluster is experimental - even in librdkafka! Expect breaking changes within minor versions of this library.","title":"Class MockCluster"},{"location":"api/RdKafka/Test/MockCluster/#methods","text":"","title":"Methods"},{"location":"api/RdKafka/Test/MockCluster/#__destruct","text":"public __destruct ( ) :","title":"__destruct()"},{"location":"api/RdKafka/Test/MockCluster/#create","text":"public static create ( int $brokerCount , ? \\RdKafka\\Conf $conf = null ) : self Parameters brokerCount int conf ? \\RdKafka\\Conf Returns self","title":"create()"},{"location":"api/RdKafka/Test/MockCluster/#createtopic","text":"public createTopic ( string $topic , int $partitionCount , int $replicationFactor ) : void Creates a topic. This is an alternative to automatic topic creation as performed by the client itself. The Topic Admin API (CreateTopics) is not supported by the mock broker. Parameters topic string partitionCount int replicationFactor int","title":"createTopic()"},{"location":"api/RdKafka/Test/MockCluster/#fromproducer","text":"public static fromProducer ( \\RdKafka\\Producer $producer ) : self Derive mock cluster from Producer created by setting the test.mock.num.brokers configuration property. Parameters producer \\RdKafka\\Producer Returns self","title":"fromProducer()"},{"location":"api/RdKafka/Test/MockCluster/#getbootstraps","text":"public getBootstraps ( ) : string Returns string the mock cluster\u2019s bootstrap.servers list","title":"getBootstraps()"},{"location":"api/RdKafka/Test/MockCluster/#pushbrokerrequesterrorrtts","text":"public pushBrokerRequestErrorRtts ( int $brokerId , int $apiKey , int $count , int $errorCodeAndRttTuples ) : void Same as {@link MockCluster::pushBrokerRequestErrors()} but for a specific broker. The broker errors take precedence over the cluster errors. Parameters brokerId int apiKey int count int errorCodeAndRttTuples int plain tuples of error code or 0 (int) and response RTT/delay in millisecond (int)","title":"pushBrokerRequestErrorRtts()"},{"location":"api/RdKafka/Test/MockCluster/#pushbrokerrequesterrors","text":"public pushBrokerRequestErrors ( int $brokerId , int $apiKey , int $count , int $errorCodes ) : void Same as {@link MockCluster::pushRequestErrors()} but for a specific broker. The broker errors take precedence over the cluster errors. Parameters brokerId int apiKey int count int errorCodes int a list of error codes or 0","title":"pushBrokerRequestErrors()"},{"location":"api/RdKafka/Test/MockCluster/#pushrequesterrors","text":"public pushRequestErrors ( int $apiKey , int $count , int $errorCodes ) : void Push cnt errors onto the cluster\u2019s error stack for the given apiKey. ApiKey is the Kafka protocol request type, e.g., Produce (0). The following cnt protocol requests matching apiKey will fail with the provided error code and removed from the stack, starting with the first error code, then the second, etc. Parameters apiKey int count int errorCodes int","title":"pushRequestErrors()"},{"location":"api/RdKafka/Test/MockCluster/#pushrequesterrorsarray","text":"public pushRequestErrorsArray ( int $apiKey , int $count , int [] $errorCodes ) : void See {@link MockCluster::pushRequestErrors()} Parameters apiKey int count int errorCodes int[]","title":"pushRequestErrorsArray()"},{"location":"api/RdKafka/Test/MockCluster/#setapiversion","text":"public setApiVersion ( int $apiKey , int $minVersion , int $maxVersion ) : void Set the allowed ApiVersion range for apiKey. Set minVersion and maxVersion to -1 to disable the API completely. MaxVersion MUST not exceed the maximum implemented value. Parameters apiKey int Protocol request type/key minVersion int Minimum version supported (or -1 to disable). maxVersion int Maximum version supported (or -1 to disable).","title":"setApiVersion()"},{"location":"api/RdKafka/Test/MockCluster/#setbrokerdown","text":"public setBrokerDown ( int $brokerId ) : void Disconnects the broker and disallows any new connections. This does NOT trigger leader change. Parameters brokerId int","title":"setBrokerDown()"},{"location":"api/RdKafka/Test/MockCluster/#setbrokerrack","text":"public setBrokerRack ( int $brokerId , string $rack ) : void Sets the broker\u2019s rack as reported in Metadata to the client. Parameters brokerId int rack string","title":"setBrokerRack()"},{"location":"api/RdKafka/Test/MockCluster/#setbrokerup","text":"public setBrokerUp ( int $brokerId ) : void Makes the broker accept connections again. This does NOT trigger leader change. Parameters brokerId int","title":"setBrokerUp()"},{"location":"api/RdKafka/Test/MockCluster/#setcoordinator","text":"public setCoordinator ( string $keyType , string $key , int $brokerId ) : void Explicitly sets the coordinator. If this API is not a standard hashing scheme will be used. Parameters keyType string \u201ctransaction\u201d or \u201cgroup\u201d key string The transactional.id or group.id brokerId int The new coordinator, does not have to be a valid broker.","title":"setCoordinator()"},{"location":"api/RdKafka/Test/MockCluster/#setpartitionfollower","text":"public setPartitionFollower ( string $topic , int $partition , int $brokerId ) : void Sets the partition\u2019s preferred replica / follower. The topic will be created if it does not exist. Parameters topic string partition int brokerId int does not need to point to an existing broker.","title":"setPartitionFollower()"},{"location":"api/RdKafka/Test/MockCluster/#setpartitionfollowerwatermarks","text":"public setPartitionFollowerWatermarks ( string $topic , int $partition , int $low , int $high ) : void Sets the partition\u2019s preferred replica / follower low and high watermarks. The topic will be created if it does not exist. Setting an offset to -1 will revert back to the leader\u2019s corresponding watermark. Parameters topic string partition int low int high int","title":"setPartitionFollowerWatermarks()"},{"location":"api/RdKafka/Test/MockCluster/#setpartitionleader","text":"public setPartitionLeader ( string $topic , int $partition , int $brokerId ) : void Sets the partition leader. The topic will be created if it does not exist. Parameters topic string partition int brokerId int needs to be an existing broker","title":"setPartitionLeader()"},{"location":"api/RdKafka/Test/MockCluster/#setrtt","text":"public setRtt ( int $brokerId , int $roundTripTimeDelayMs ) : void Set broker round-trip-time delay in milliseconds. Parameters brokerId int roundTripTimeDelayMs int","title":"setRtt()"},{"location":"api/RdKafka/Test/MockCluster/#settopicerror","text":"public setTopicError ( string $topic , int $errorCode ) : void Set the topic error to return in protocol requests. Currently only used for TopicMetadataRequest and AddPartitionsToTxnRequest. Parameters topic string errorCode int","title":"setTopicError()"},{"location":"api/RdKafka/Test/MockCluster/#test-coverage","text":"\ud83e\udde1 Lines: 67.59% (73 / 108) \u2764\ufe0f Methods: 35% (7 / 20)","title":"Test Coverage \ud83e\udde1"}]}